<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>innodb的体系架构</title>
    <link href="/2020/07/22/innodb-de-ti-xi-jia-gou/"/>
    <url>/2020/07/22/innodb-de-ti-xi-jia-gou/</url>
    
    <content type="html"><![CDATA[<h2 id="1-innodb的总体架构"><a href="#1-innodb的总体架构" class="headerlink" title="1. innodb的总体架构"></a>1. innodb的总体架构</h2><p>innodb线程与文件的关系:<sup><a href="#fn_4" id="reffn_4">4</a></sup></p><p><img src="innodb存储架构.png" srcset="/img/loading.gif" alt="innodb存储架构"></p><p>innodb文件结构:<sup><a href="#fn_9" id="reffn_9">9</a></sup></p><p><img src="innodb-architecture.png" srcset="/img/loading.gif" alt="InnoDB architecture diagram showing in-memory and on-disk structures"></p><p>InnoDB所有数据都被逻辑地存放在一个表空间（tablespace）中。表空间又由段（segment）、区（extent）、页（page）组成，页在一些文档中有时也称为块（block）。逻辑存储结构大致如下图:<sup><a href="#fn_8" id="reffn_8">8</a></sup></p><p><img src="v2-50b50d5c6b799c3d84d8bcf7942b0086_720w.jpg" srcset="/img/loading.gif" alt="InnoDB逻辑存储结构"></p><h3 id="table的数据结构"><a href="#table的数据结构" class="headerlink" title="table的数据结构"></a>table的数据结构</h3><pre><code class="hljs c++"><span class="hljs-comment">/** Data structure for a database table.  Most fields will be</span><span class="hljs-comment">initialized to 0, NULL or FALSE in dict_mem_table_create(). */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict_table_t</span> {</span><span class="hljs-comment">/** Get reference count.</span><span class="hljs-comment">@return current value of n_ref_count */</span><span class="hljs-function"><span class="hljs-keyword">inline</span> ulint <span class="hljs-title">get_ref_count</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">/** Acquire the table handle. */</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** Release the table handle. */</span><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** Id of the table. */</span><span class="hljs-keyword">table_id_t</span>id;<span class="hljs-comment">/** Memory heap. If you allocate from this heap after the table has</span><span class="hljs-comment">been created then be sure to account the allocation into</span><span class="hljs-comment">dict_sys-&gt;size. When closing the table we do something like</span><span class="hljs-comment">dict_sys-&gt;size -= mem_heap_get_size(table-&gt;heap) and if that is going</span><span class="hljs-comment">to become negative then we would assert. Something like this should do:</span><span class="hljs-comment">old_size = mem_heap_get_size()</span><span class="hljs-comment">mem_heap_alloc()</span><span class="hljs-comment">new_size = mem_heap_get_size()</span><span class="hljs-comment">dict_sys-&gt;size += new_size - old_size. */</span><span class="hljs-keyword">mem_heap_t</span>*heap;<span class="hljs-comment">/** Table name. */</span><span class="hljs-keyword">table_name_t</span>name;<span class="hljs-comment">/** NULL or the directory path where a TEMPORARY table that was</span><span class="hljs-comment">explicitly created by a user should be placed if innodb_file_per_table</span><span class="hljs-comment">is defined in my.cnf. In Unix this is usually "/tmp/...",</span><span class="hljs-comment">in Windows "temp\...". */</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*dir_path_of_temp_table;<span class="hljs-comment">/** NULL or the directory path specified by DATA DIRECTORY. */</span><span class="hljs-keyword">char</span>*data_dir_path;<span class="hljs-comment">/** NULL or the tablespace name that this table is assigned to,</span><span class="hljs-comment">specified by the TABLESPACE option.*/</span><span class="hljs-keyword">id_name_t</span>tablespace;<span class="hljs-comment">/** Space where the clustered index of the table is placed. */</span><span class="hljs-keyword">uint32_t</span>space;<span class="hljs-comment">/** Stores information about:</span><span class="hljs-comment">1 row format (redundant or compact),</span><span class="hljs-comment">2 compressed page size (zip shift size),</span><span class="hljs-comment">3 whether using atomic blobs,</span><span class="hljs-comment">4 whether the table has been created with the option DATA DIRECTORY.</span><span class="hljs-comment">Use DICT_TF_GET_COMPACT(), DICT_TF_GET_ZIP_SSIZE(),</span><span class="hljs-comment">DICT_TF_HAS_ATOMIC_BLOBS() and DICT_TF_HAS_DATA_DIR() to parse this</span><span class="hljs-comment">flag. */</span><span class="hljs-keyword">unsigned</span>flags:DICT_TF_BITS;<span class="hljs-comment">/** Stores information about:</span><span class="hljs-comment">1 whether the table has been created using CREATE TEMPORARY TABLE,</span><span class="hljs-comment">2 whether the table has an internally defined DOC ID column,</span><span class="hljs-comment">3 whether the table has a FTS index,</span><span class="hljs-comment">4 whether DOC ID column need to be added to the FTS index,</span><span class="hljs-comment">5 whether the table is being created its own tablespace,</span><span class="hljs-comment">6 whether the table has been DISCARDed,</span><span class="hljs-comment">7 whether the aux FTS tables names are in hex.</span><span class="hljs-comment">8 whether the table is instinc table.</span><span class="hljs-comment">9 whether the table has encryption setting.</span><span class="hljs-comment">Use DICT_TF2_FLAG_IS_SET() to parse this flag. */</span><span class="hljs-keyword">unsigned</span>flags2:DICT_TF2_BITS;<span class="hljs-comment">/** TRUE if this is in a single-table tablespace and the .ibd file is</span><span class="hljs-comment">missing. Then we must return in ha_innodb.cc an error if the user</span><span class="hljs-comment">tries to query such an orphaned table. */</span><span class="hljs-keyword">unsigned</span>ibd_file_missing:<span class="hljs-number">1</span>;<span class="hljs-comment">/** TRUE if the table object has been added to the dictionary cache. */</span><span class="hljs-keyword">unsigned</span>cached:<span class="hljs-number">1</span>;<span class="hljs-comment">/** TRUE if the table is to be dropped, but not yet actually dropped</span><span class="hljs-comment">(could in the background drop list). It is turned on at the beginning</span><span class="hljs-comment">of row_drop_table_for_mysql() and turned off just before we start to</span><span class="hljs-comment">update system tables for the drop. It is protected by</span><span class="hljs-comment">dict_operation_lock. */</span><span class="hljs-keyword">unsigned</span>to_be_dropped:<span class="hljs-number">1</span>;<span class="hljs-comment">/** Number of non-virtual columns defined so far. */</span><span class="hljs-keyword">unsigned</span>n_def:<span class="hljs-number">10</span>;<span class="hljs-comment">/** Number of non-virtual columns. */</span><span class="hljs-keyword">unsigned</span>n_cols:<span class="hljs-number">10</span>;<span class="hljs-comment">/** Number of total columns (inlcude virtual and non-virtual) */</span><span class="hljs-keyword">unsigned</span>n_t_cols:<span class="hljs-number">10</span>;<span class="hljs-comment">/** Number of total columns defined so far. */</span><span class="hljs-keyword">unsigned</span>                                n_t_def:<span class="hljs-number">10</span>;<span class="hljs-comment">/** Number of virtual columns defined so far. */</span><span class="hljs-keyword">unsigned</span>                                n_v_def:<span class="hljs-number">10</span>;<span class="hljs-comment">/** Number of virtual columns. */</span><span class="hljs-keyword">unsigned</span>                                n_v_cols:<span class="hljs-number">10</span>;<span class="hljs-comment">/** TRUE if it's not an InnoDB system table or a table that has no FK</span><span class="hljs-comment">relationships. */</span><span class="hljs-keyword">unsigned</span>can_be_evicted:<span class="hljs-number">1</span>;<span class="hljs-comment">/** TRUE if table is corrupted. */</span><span class="hljs-keyword">unsigned</span>corrupted:<span class="hljs-number">1</span>;<span class="hljs-comment">/** TRUE if some indexes should be dropped after ONLINE_INDEX_ABORTED</span><span class="hljs-comment">or ONLINE_INDEX_ABORTED_DROPPED. */</span><span class="hljs-keyword">unsigned</span>drop_aborted:<span class="hljs-number">1</span>;<span class="hljs-comment">/** Array of column descriptions. */</span><span class="hljs-keyword">dict_col_t</span>*cols;<span class="hljs-comment">/** Array of virtual column descriptions. */</span><span class="hljs-keyword">dict_v_col_t</span>*v_cols;<span class="hljs-comment">/** List of stored column descriptions. It is used only for foreign key</span><span class="hljs-comment">check during create table and copy alter operations.</span><span class="hljs-comment">During copy alter, s_cols list is filled during create table operation</span><span class="hljs-comment">and need to preserve till rename table operation. That is the</span><span class="hljs-comment">reason s_cols is a part of dict_table_t */</span>dict_s_col_list*s_cols;<span class="hljs-comment">/** Column names packed in a character string</span><span class="hljs-comment">"name1\0name2\0...nameN\0". Until the string contains n_cols, it will</span><span class="hljs-comment">be allocated from a temporary heap. The final string will be allocated</span><span class="hljs-comment">from table-&gt;heap. */</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*col_names;<span class="hljs-comment">/** Virtual column names */</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*v_col_names;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> UNIV_HOTBACKUP</span><span class="hljs-comment">/** Hash chain node. */</span><span class="hljs-keyword">hash_node_t</span>name_hash;<span class="hljs-comment">/** Hash chain node. */</span><span class="hljs-keyword">hash_node_t</span>id_hash;<span class="hljs-comment">/** The FTS_DOC_ID_INDEX, or NULL if no fulltext indexes exist */</span><span class="hljs-keyword">dict_index_t</span>*fts_doc_id_index;<span class="hljs-comment">/** List of indexes of the table. */</span>UT_LIST_BASE_NODE_T(<span class="hljs-keyword">dict_index_t</span>)indexes;<span class="hljs-comment">/** List of foreign key constraints in the table. These refer to</span><span class="hljs-comment">columns in other tables. */</span>UT_LIST_BASE_NODE_T(<span class="hljs-keyword">dict_foreign_t</span>)foreign_list;<span class="hljs-comment">/** List of foreign key constraints which refer to this table. */</span>UT_LIST_BASE_NODE_T(<span class="hljs-keyword">dict_foreign_t</span>)referenced_list;<span class="hljs-comment">/** Node of the LRU list of tables. */</span>UT_LIST_NODE_T(<span class="hljs-keyword">dict_table_t</span>)table_LRU;<span class="hljs-comment">/** Maximum recursive level we support when loading tables chained</span><span class="hljs-comment">together with FK constraints. If exceeds this level, we will stop</span><span class="hljs-comment">loading child table into memory along with its parent table. */</span><span class="hljs-keyword">unsigned</span>fk_max_recusive_level:<span class="hljs-number">8</span>;<span class="hljs-comment">/** Count of how many foreign key check operations are currently being</span><span class="hljs-comment">performed on the table. We cannot drop the table while there are</span><span class="hljs-comment">foreign key checks running on it. */</span>ulintn_foreign_key_checks_running;<span class="hljs-comment">/** Transactions whose view low limit is greater than this number are</span><span class="hljs-comment">not allowed to store to the MySQL query cache or retrieve from it.</span><span class="hljs-comment">When a trx with undo logs commits, it sets this to the value of the</span><span class="hljs-comment">current time. */</span><span class="hljs-keyword">trx_id_t</span>query_cache_inv_id;<span class="hljs-comment">/** Transaction id that last touched the table definition. Either when</span><span class="hljs-comment">loading the definition or CREATE TABLE, or ALTER TABLE (prepare,</span><span class="hljs-comment">commit, and rollback phases). */</span><span class="hljs-keyword">trx_id_t</span>def_trx_id;<span class="hljs-comment">/*!&lt; set of foreign key constraints in the table; these refer to</span><span class="hljs-comment">columns in other tables */</span>dict_foreign_setforeign_set;<span class="hljs-comment">/*!&lt; set of foreign key constraints which refer to this table */</span>dict_foreign_setreferenced_set;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> UNIV_DEBUG</span><span class="hljs-comment">/** This field is used to specify in simulations tables which are so</span><span class="hljs-comment">big that disk should be accessed. Disk access is simulated by putting</span><span class="hljs-comment">the thread to sleep for a while. NOTE that this flag is not stored to</span><span class="hljs-comment">the data dictionary on disk, and the database will forget about value</span><span class="hljs-comment">TRUE if it has to reload the table definition from disk. */</span>ibooldoes_not_fit_in_memory;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* UNIV_DEBUG */</span></span><span class="hljs-comment">/** TRUE if the maximum length of a single row exceeds BIG_ROW_SIZE.</span><span class="hljs-comment">Initialized in dict_table_add_to_cache(). */</span><span class="hljs-keyword">unsigned</span>big_rows:<span class="hljs-number">1</span>;<span class="hljs-comment">/** Statistics for query optimization. @{ */</span><span class="hljs-comment">/** Creation state of 'stats_latch'. */</span><span class="hljs-keyword">volatile</span> os_once::<span class="hljs-keyword">state_t</span>stats_latch_created;<span class="hljs-comment">/** This latch protects:</span><span class="hljs-comment">dict_table_t::stat_initialized,</span><span class="hljs-comment">dict_table_t::stat_n_rows (*),</span><span class="hljs-comment">dict_table_t::stat_clustered_index_size,</span><span class="hljs-comment">dict_table_t::stat_sum_of_other_index_sizes,</span><span class="hljs-comment">dict_table_t::stat_modified_counter (*),</span><span class="hljs-comment">dict_table_t::indexes*::stat_n_diff_key_vals[],</span><span class="hljs-comment">dict_table_t::indexes*::stat_index_size,</span><span class="hljs-comment">dict_table_t::indexes*::stat_n_leaf_pages.</span><span class="hljs-comment">(*) Those are not always protected for</span><span class="hljs-comment">performance reasons. */</span><span class="hljs-keyword">rw_lock_t</span>*stats_latch;<span class="hljs-comment">/** TRUE if statistics have been calculated the first time after</span><span class="hljs-comment">database startup or table creation. */</span><span class="hljs-keyword">unsigned</span>stat_initialized:<span class="hljs-number">1</span>;<span class="hljs-comment">/** Timestamp of last recalc of the stats. */</span><span class="hljs-keyword">ib_time_t</span>stats_last_recalc;<span class="hljs-comment">/** The two bits below are set in the 'stat_persistent' member. They</span><span class="hljs-comment">have the following meaning:</span><span class="hljs-comment">1. _ON=0, _OFF=0, no explicit persistent stats setting for this table,</span><span class="hljs-comment">the value of the global srv_stats_persistent is used to determine</span><span class="hljs-comment">whether the table has persistent stats enabled or not</span><span class="hljs-comment">2. _ON=0, _OFF=1, persistent stats are explicitly disabled for this</span><span class="hljs-comment">table, regardless of the value of the global srv_stats_persistent</span><span class="hljs-comment">3. _ON=1, _OFF=0, persistent stats are explicitly enabled for this</span><span class="hljs-comment">table, regardless of the value of the global srv_stats_persistent</span><span class="hljs-comment">4. _ON=1, _OFF=1, not allowed, we assert if this ever happens. */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DICT_STATS_PERSISTENT_ON(1 &lt;&lt; 1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DICT_STATS_PERSISTENT_OFF(1 &lt;&lt; 2)</span><span class="hljs-comment">/** Indicates whether the table uses persistent stats or not. See</span><span class="hljs-comment">DICT_STATS_PERSISTENT_ON and DICT_STATS_PERSISTENT_OFF. */</span><span class="hljs-keyword">ib_uint32_t</span>stat_persistent;<span class="hljs-comment">/** The two bits below are set in the 'stats_auto_recalc' member. They</span><span class="hljs-comment">have the following meaning:</span><span class="hljs-comment">1. _ON=0, _OFF=0, no explicit auto recalc setting for this table, the</span><span class="hljs-comment">value of the global srv_stats_persistent_auto_recalc is used to</span><span class="hljs-comment">determine whether the table has auto recalc enabled or not</span><span class="hljs-comment">2. _ON=0, _OFF=1, auto recalc is explicitly disabled for this table,</span><span class="hljs-comment">regardless of the value of the global srv_stats_persistent_auto_recalc</span><span class="hljs-comment">3. _ON=1, _OFF=0, auto recalc is explicitly enabled for this table,</span><span class="hljs-comment">regardless of the value of the global srv_stats_persistent_auto_recalc</span><span class="hljs-comment">4. _ON=1, _OFF=1, not allowed, we assert if this ever happens. */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DICT_STATS_AUTO_RECALC_ON(1 &lt;&lt; 1)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DICT_STATS_AUTO_RECALC_OFF(1 &lt;&lt; 2)</span><span class="hljs-comment">/** Indicates whether the table uses automatic recalc for persistent</span><span class="hljs-comment">stats or not. See DICT_STATS_AUTO_RECALC_ON and</span><span class="hljs-comment">DICT_STATS_AUTO_RECALC_OFF. */</span><span class="hljs-keyword">ib_uint32_t</span>stats_auto_recalc;<span class="hljs-comment">/** The number of pages to sample for this table during persistent</span><span class="hljs-comment">stats estimation. If this is 0, then the value of the global</span><span class="hljs-comment">srv_stats_persistent_sample_pages will be used instead. */</span>ulintstats_sample_pages;<span class="hljs-comment">/** Approximate number of rows in the table. We periodically calculate</span><span class="hljs-comment">new estimates. */</span><span class="hljs-keyword">ib_uint64_t</span>stat_n_rows;<span class="hljs-comment">/** Approximate clustered index size in database pages. */</span>ulintstat_clustered_index_size;<span class="hljs-comment">/** Approximate size of other indexes in database pages. */</span>ulintstat_sum_of_other_index_sizes;<span class="hljs-comment">/** How many rows are modified since last stats recalc. When a row is</span><span class="hljs-comment">inserted, updated, or deleted, we add 1 to this number; we calculate</span><span class="hljs-comment">new estimates for the table and the indexes if the table has changed</span><span class="hljs-comment">too much, see row_update_statistics_if_needed(). The counter is reset</span><span class="hljs-comment">to zero at statistics calculation. This counter is not protected by</span><span class="hljs-comment">any latch, because this is only used for heuristics. */</span><span class="hljs-keyword">ib_uint64_t</span>stat_modified_counter;<span class="hljs-comment">/** Background stats thread is not working on this table. */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BG_STAT_NONE0</span><span class="hljs-comment">/** Set in 'stats_bg_flag' when the background stats code is working</span><span class="hljs-comment">on this table. The DROP TABLE code waits for this to be cleared before</span><span class="hljs-comment">proceeding. */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BG_STAT_IN_PROGRESS(1 &lt;&lt; 0)</span><span class="hljs-comment">/** Set in 'stats_bg_flag' when DROP TABLE starts waiting on</span><span class="hljs-comment">BG_STAT_IN_PROGRESS to be cleared. The background stats thread will</span><span class="hljs-comment">detect this and will eventually quit sooner. */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BG_STAT_SHOULD_QUIT(1 &lt;&lt; 1)</span><span class="hljs-comment">/** The state of the background stats thread wrt this table.</span><span class="hljs-comment">See BG_STAT_NONE, BG_STAT_IN_PROGRESS and BG_STAT_SHOULD_QUIT.</span><span class="hljs-comment">Writes are covered by dict_sys-&gt;mutex. Dirty reads are possible. */</span><span class="hljs-keyword">byte</span>stats_bg_flag;<span class="hljs-comment">/* @} */</span><span class="hljs-comment">/** AUTOINC related members. @{ */</span><span class="hljs-comment">/* The actual collection of tables locked during AUTOINC read/write is</span><span class="hljs-comment">kept in trx_t. In order to quickly determine whether a transaction has</span><span class="hljs-comment">locked the AUTOINC lock we keep a pointer to the transaction here in</span><span class="hljs-comment">the 'autoinc_trx' member. This is to avoid acquiring the</span><span class="hljs-comment">lock_sys_t::mutex and scanning the vector in trx_t.</span><span class="hljs-comment">When an AUTOINC lock has to wait, the corresponding lock instance is</span><span class="hljs-comment">created on the trx lock heap rather than use the pre-allocated instance</span><span class="hljs-comment">in autoinc_lock below. */</span><span class="hljs-comment">/** A buffer for an AUTOINC lock for this table. We allocate the</span><span class="hljs-comment">memory here so that individual transactions can get it and release it</span><span class="hljs-comment">without a need to allocate space from the lock heap of the trx:</span><span class="hljs-comment">otherwise the lock heap would grow rapidly if we do a large insert</span><span class="hljs-comment">from a select. */</span><span class="hljs-keyword">lock_t</span>*autoinc_lock;<span class="hljs-comment">/** Creation state of autoinc_mutex member */</span><span class="hljs-keyword">volatile</span> os_once::<span class="hljs-keyword">state_t</span>autoinc_mutex_created;<span class="hljs-comment">/** Mutex protecting the autoincrement counter. */</span><span class="hljs-keyword">ib_mutex_t</span>*autoinc_mutex;<span class="hljs-comment">/** Autoinc counter value to give to the next inserted row. */</span><span class="hljs-keyword">ib_uint64_t</span>autoinc;<span class="hljs-comment">/** This counter is used to track the number of granted and pending</span><span class="hljs-comment">autoinc locks on this table. This value is set after acquiring the</span><span class="hljs-comment">lock_sys_t::mutex but we peek the contents to determine whether other</span><span class="hljs-comment">transactions have acquired the AUTOINC lock or not. Of course only one</span><span class="hljs-comment">transaction can be granted the lock but there can be multiple</span><span class="hljs-comment">waiters. */</span>ulongn_waiting_or_granted_auto_inc_locks;<span class="hljs-comment">/** The transaction that currently holds the the AUTOINC lock on this</span><span class="hljs-comment">table. Protected by lock_sys-&gt;mutex. */</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">trx_t</span>*autoinc_trx;<span class="hljs-comment">/* @} */</span><span class="hljs-comment">/** Count of how many handles are opened to this table from memcached.</span><span class="hljs-comment">DDL on the table is NOT allowed until this count goes to zero. If</span><span class="hljs-comment">it is -1, then there's DDL on the table, DML from memcached will be</span><span class="hljs-comment">blocked. */</span>lintmemcached_sync_count;<span class="hljs-comment">/** FTS specific state variables. */</span><span class="hljs-keyword">fts_t</span>*fts;<span class="hljs-comment">/** Quiescing states, protected by the dict_index_t::lock. ie. we can</span><span class="hljs-comment">only change the state if we acquire all the latches (dict_index_t::lock)</span><span class="hljs-comment">in X mode of this table's indexes. */</span><span class="hljs-keyword">ib_quiesce_t</span>quiesce;<span class="hljs-comment">/** Count of the number of record locks on this table. We use this to</span><span class="hljs-comment">determine whether we can evict the table from the dictionary cache.</span><span class="hljs-comment">It is protected by lock_sys-&gt;mutex. */</span>ulintn_rec_locks;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> UNIV_DEBUG</span><span class="hljs-keyword">private</span>:<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-comment">/** Count of how many handles are opened to this table. Dropping of the</span><span class="hljs-comment">table is NOT allowed until this count gets to zero. MySQL does NOT</span><span class="hljs-comment">itself check the number of open handles at DROP. */</span>ulintn_ref_count;<span class="hljs-keyword">public</span>:<span class="hljs-comment">/** List of locks on the table. Protected by lock_sys-&gt;mutex. */</span><span class="hljs-keyword">table_lock_list_t</span>locks;<span class="hljs-comment">/** Timestamp of the last modification of this table. */</span><span class="hljs-keyword">time_t</span>update_time;<span class="hljs-comment">/** row-id counter for use by intrinsic table for getting row-id.</span><span class="hljs-comment">Given intrinsic table semantics, row-id can be locally maintained</span><span class="hljs-comment">instead of getting it from central generator which involves mutex</span><span class="hljs-comment">locking. */</span><span class="hljs-keyword">ib_uint64_t</span>sess_row_id;<span class="hljs-comment">/** trx_id counter for use by intrinsic table for getting trx-id.</span><span class="hljs-comment">Intrinsic table are not shared so don't need a central trx-id</span><span class="hljs-comment">but just need a increased counter to track consistent view while</span><span class="hljs-comment">proceeding SELECT as part of UPDATE. */</span><span class="hljs-keyword">ib_uint64_t</span>sess_trx_id;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* !UNIV_HOTBACKUP */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> UNIV_DEBUG</span><span class="hljs-comment">/** Value of 'magic_n'. */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DICT_TABLE_MAGIC_N76333786</span><span class="hljs-comment">/** Magic number. */</span>ulintmagic_n;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* UNIV_DEBUG */</span></span><span class="hljs-comment">/** mysql_row_templ_t for base columns used for compute the virtual</span><span class="hljs-comment">columns */</span><span class="hljs-keyword">dict_vcol_templ_t</span>*vc_templ;<span class="hljs-comment">/** encryption key, it's only for export/import */</span><span class="hljs-keyword">byte</span>*encryption_key;<span class="hljs-comment">/** encryption iv, it's only for export/import */</span><span class="hljs-keyword">byte</span>*encryption_iv;};</code></pre><h3 id="index的数据结构"><a href="#index的数据结构" class="headerlink" title="index的数据结构"></a>index的数据结构</h3><pre><code class="hljs c++"><span class="hljs-comment">/** Data structure for an index.  Most fields will be</span><span class="hljs-comment">initialized to 0, NULL or FALSE in dict_mem_index_create(). */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict_index_t</span>{</span><span class="hljs-keyword">index_id_t</span>id;<span class="hljs-comment">/*!&lt; id of the index */</span><span class="hljs-keyword">mem_heap_t</span>*heap;<span class="hljs-comment">/*!&lt; memory heap */</span><span class="hljs-keyword">id_name_t</span>name;<span class="hljs-comment">/*!&lt; index name */</span><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*table_name;<span class="hljs-comment">/*!&lt; table name */</span><span class="hljs-keyword">dict_table_t</span>*table;<span class="hljs-comment">/*!&lt; back pointer to table */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> UNIV_HOTBACKUP</span><span class="hljs-keyword">unsigned</span>space:<span class="hljs-number">32</span>;<span class="hljs-comment">/*!&lt; space where the index tree is placed */</span><span class="hljs-keyword">unsigned</span>page:<span class="hljs-number">32</span>;<span class="hljs-comment">/*!&lt; index tree root page number */</span><span class="hljs-keyword">unsigned</span>merge_threshold:<span class="hljs-number">6</span>;<span class="hljs-comment">/*!&lt; In the pessimistic delete, if the page</span><span class="hljs-comment">data size drops below this limit in percent,</span><span class="hljs-comment">merging it to a neighbor is tried */</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> DICT_INDEX_MERGE_THRESHOLD_DEFAULT 50</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* !UNIV_HOTBACKUP */</span></span><span class="hljs-keyword">unsigned</span>type:DICT_IT_BITS;<span class="hljs-comment">/*!&lt; index type (DICT_CLUSTERED, DICT_UNIQUE,</span><span class="hljs-comment">DICT_IBUF, DICT_CORRUPT) */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_KEY_LENGTH_BITS 12</span><span class="hljs-keyword">unsigned</span>trx_id_offset:MAX_KEY_LENGTH_BITS;<span class="hljs-comment">/*!&lt; position of the trx id column</span><span class="hljs-comment">in a clustered index record, if the fields</span><span class="hljs-comment">before it are known to be of a fixed size,</span><span class="hljs-comment">0 otherwise */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> (1&lt;&lt;MAX_KEY_LENGTH_BITS) &lt; MAX_KEY_LENGTH</span><span class="hljs-meta"># <span class="hljs-meta-keyword">error</span> (1&lt;&lt;MAX_KEY_LENGTH_BITS) &lt; MAX_KEY_LENGTH</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-keyword">unsigned</span>n_user_defined_cols:<span class="hljs-number">10</span>;<span class="hljs-comment">/*!&lt; number of columns the user defined to</span><span class="hljs-comment">be in the index: in the internal</span><span class="hljs-comment">representation we add more columns */</span><span class="hljs-keyword">unsigned</span>allow_duplicates:<span class="hljs-number">1</span>;<span class="hljs-comment">/*!&lt; if true, allow duplicate values</span><span class="hljs-comment">even if index is created with unique</span><span class="hljs-comment">constraint */</span><span class="hljs-keyword">unsigned</span>nulls_equal:<span class="hljs-number">1</span>;<span class="hljs-comment">/*!&lt; if true, SQL NULL == SQL NULL */</span><span class="hljs-keyword">unsigned</span>disable_ahi:<span class="hljs-number">1</span>;<span class="hljs-comment">/*!&lt; in true, then disable AHI.</span><span class="hljs-comment">Currently limited to intrinsic</span><span class="hljs-comment">temporary table as index id is not</span><span class="hljs-comment">unqiue for such table which is one of the</span><span class="hljs-comment">validation criterion for ahi. */</span><span class="hljs-keyword">unsigned</span>n_uniq:<span class="hljs-number">10</span>;<span class="hljs-comment">/*!&lt; number of fields from the beginning</span><span class="hljs-comment">which are enough to determine an index</span><span class="hljs-comment">entry uniquely */</span><span class="hljs-keyword">unsigned</span>n_def:<span class="hljs-number">10</span>;<span class="hljs-comment">/*!&lt; number of fields defined so far */</span><span class="hljs-keyword">unsigned</span>n_fields:<span class="hljs-number">10</span>;<span class="hljs-comment">/*!&lt; number of fields in the index */</span><span class="hljs-keyword">unsigned</span>n_nullable:<span class="hljs-number">10</span>;<span class="hljs-comment">/*!&lt; number of nullable fields */</span><span class="hljs-keyword">unsigned</span>cached:<span class="hljs-number">1</span>;<span class="hljs-comment">/*!&lt; TRUE if the index object is in the</span><span class="hljs-comment">dictionary cache */</span><span class="hljs-keyword">unsigned</span>to_be_dropped:<span class="hljs-number">1</span>;<span class="hljs-comment">/*!&lt; TRUE if the index is to be dropped;</span><span class="hljs-comment">protected by dict_operation_lock */</span><span class="hljs-keyword">unsigned</span>online_status:<span class="hljs-number">2</span>;<span class="hljs-comment">/*!&lt; enum online_index_status.</span><span class="hljs-comment">Transitions from ONLINE_INDEX_COMPLETE (to</span><span class="hljs-comment">ONLINE_INDEX_CREATION) are protected</span><span class="hljs-comment">by dict_operation_lock and</span><span class="hljs-comment">dict_sys-&gt;mutex. Other changes are</span><span class="hljs-comment">protected by index-&gt;lock. */</span><span class="hljs-keyword">unsigned</span>uncommitted:<span class="hljs-number">1</span>;<span class="hljs-comment">/*!&lt; a flag that is set for secondary indexes</span><span class="hljs-comment">that have not been committed to the</span><span class="hljs-comment">data dictionary yet */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> UNIV_DEBUG</span><span class="hljs-keyword">uint32_t</span>magic_n;<span class="hljs-comment">/*!&lt; magic number */</span><span class="hljs-comment">/** Value of dict_index_t::magic_n */</span><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> DICT_INDEX_MAGIC_N76789786</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-keyword">dict_field_t</span>*fields;<span class="hljs-comment">/*!&lt; array of field descriptions */</span>st_mysql_ftparser*parser;<span class="hljs-comment">/*!&lt; fulltext parser plugin */</span><span class="hljs-keyword">bool</span>is_ngram;<span class="hljs-comment">/*!&lt; true if it's ngram parser */</span><span class="hljs-keyword">bool</span>has_new_v_col;<span class="hljs-comment">/*!&lt; whether it has a newly added virtual</span><span class="hljs-comment">column in ALTER */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> UNIV_HOTBACKUP</span>UT_LIST_NODE_T(<span class="hljs-keyword">dict_index_t</span>)indexes;<span class="hljs-comment">/*!&lt; list of indexes of the table */</span><span class="hljs-keyword">btr_search_t</span>*search_info;<span class="hljs-comment">/*!&lt; info used in optimistic searches */</span><span class="hljs-keyword">row_log_t</span>*online_log;<span class="hljs-comment">/*!&lt; the log of modifications</span><span class="hljs-comment">during online index creation;</span><span class="hljs-comment">valid when online_status is</span><span class="hljs-comment">ONLINE_INDEX_CREATION */</span><span class="hljs-comment">/*----------------------*/</span><span class="hljs-comment">/** Statistics for query optimization */</span><span class="hljs-comment">/* @{ */</span><span class="hljs-keyword">ib_uint64_t</span>*stat_n_diff_key_vals;<span class="hljs-comment">/*!&lt; approximate number of different</span><span class="hljs-comment">key values for this index, for each</span><span class="hljs-comment">n-column prefix where 1 &lt;= n &lt;=</span><span class="hljs-comment">dict_get_n_unique(index) (the array is</span><span class="hljs-comment">indexed from 0 to n_uniq-1); we</span><span class="hljs-comment">periodically calculate new</span><span class="hljs-comment">estimates */</span><span class="hljs-keyword">ib_uint64_t</span>*stat_n_sample_sizes;<span class="hljs-comment">/*!&lt; number of pages that were sampled</span><span class="hljs-comment">to calculate each of stat_n_diff_key_vals[],</span><span class="hljs-comment">e.g. stat_n_sample_sizes[3] pages were sampled</span><span class="hljs-comment">to get the number stat_n_diff_key_vals[3]. */</span><span class="hljs-keyword">ib_uint64_t</span>*stat_n_non_null_key_vals;<span class="hljs-comment">/* approximate number of non-null key values</span><span class="hljs-comment">for this index, for each column where</span><span class="hljs-comment">1 &lt;= n &lt;= dict_get_n_unique(index) (the array</span><span class="hljs-comment">is indexed from 0 to n_uniq-1); This</span><span class="hljs-comment">is used when innodb_stats_method is</span><span class="hljs-comment">"nulls_ignored". */</span>ulintstat_index_size;<span class="hljs-comment">/*!&lt; approximate index size in</span><span class="hljs-comment">database pages */</span>ulintstat_n_leaf_pages;<span class="hljs-comment">/*!&lt; approximate number of leaf pages in the</span><span class="hljs-comment">index tree */</span><span class="hljs-comment">/* @} */</span><span class="hljs-keyword">last_ops_cur_t</span>*last_ins_cur;<span class="hljs-comment">/*!&lt; cache the last insert position.</span><span class="hljs-comment">Currently limited to auto-generated</span><span class="hljs-comment">clustered index on intrinsic table only. */</span><span class="hljs-keyword">last_ops_cur_t</span>*last_sel_cur;<span class="hljs-comment">/*!&lt; cache the last selected position</span><span class="hljs-comment">Currently limited to intrinsic table only. */</span><span class="hljs-keyword">rec_cache_t</span>rec_cache;<span class="hljs-comment">/*!&lt; cache the field that needs to be</span><span class="hljs-comment">re-computed on each insert.</span><span class="hljs-comment">Limited to intrinsic table as this is common</span><span class="hljs-comment">share and can't be used without protection</span><span class="hljs-comment">if table is accessible to multiple-threads. */</span><span class="hljs-keyword">rtr_ssn_t</span>rtr_ssn;<span class="hljs-comment">/*!&lt; Node sequence number for RTree */</span><span class="hljs-keyword">rtr_info_track_t</span>*rtr_track;<span class="hljs-comment">/*!&lt; tracking all R-Tree search cursors */</span><span class="hljs-keyword">trx_id_t</span>trx_id; <span class="hljs-comment">/*!&lt; id of the transaction that created this</span><span class="hljs-comment">index, or 0 if the index existed</span><span class="hljs-comment">when InnoDB was started up */</span><span class="hljs-keyword">zip_pad_info_t</span>zip_pad;<span class="hljs-comment">/*!&lt; Information about state of</span><span class="hljs-comment">compression failures and successes */</span><span class="hljs-keyword">rw_lock_t</span>lock;<span class="hljs-comment">/*!&lt; read-write lock protecting the</span><span class="hljs-comment">upper levels of the index tree */</span><span class="hljs-comment">/** Determine if the index has been committed to the</span><span class="hljs-comment">data dictionary.</span><span class="hljs-comment">@return whether the index definition has been committed */</span><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_committed</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span><span class="hljs-function"></span>{ut_ad(!uncommitted || !(type &amp; DICT_CLUSTERED));<span class="hljs-keyword">return</span>(UNIV_LIKELY(!uncommitted));}<span class="hljs-comment">/** Flag an index committed or uncommitted.</span><span class="hljs-comment">@param[in]committedwhether the index is committed */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_committed</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> committed)</span></span><span class="hljs-function"></span>{ut_ad(!to_be_dropped);ut_ad(committed || !(type &amp; DICT_CLUSTERED));uncommitted = !committed;}<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* !UNIV_HOTBACKUP */</span></span>};</code></pre><h3 id="column的数据结构"><a href="#column的数据结构" class="headerlink" title="column的数据结构"></a>column的数据结构</h3><pre><code class="hljs c++"><span class="hljs-comment">/** Data structure for a column in a table */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict_col_t</span>{</span><span class="hljs-comment">/*----------------------*/</span><span class="hljs-comment">/** The following are copied from dtype_t,</span><span class="hljs-comment">so that all bit-fields can be packed tightly. */</span><span class="hljs-comment">/* @{ */</span><span class="hljs-keyword">unsigned</span>prtype:<span class="hljs-number">32</span>;<span class="hljs-comment">/*!&lt; precise type; MySQL data</span><span class="hljs-comment">type, charset code, flags to</span><span class="hljs-comment">indicate nullability,</span><span class="hljs-comment">signedness, whether this is a</span><span class="hljs-comment">binary string, whether this is</span><span class="hljs-comment">a true VARCHAR where MySQL</span><span class="hljs-comment">uses 2 bytes to store the length */</span><span class="hljs-keyword">unsigned</span>mtype:<span class="hljs-number">8</span>;<span class="hljs-comment">/*!&lt; main data type */</span><span class="hljs-comment">/* the remaining fields do not affect alphabetical ordering: */</span><span class="hljs-keyword">unsigned</span>len:<span class="hljs-number">16</span>;<span class="hljs-comment">/*!&lt; length; for MySQL data this</span><span class="hljs-comment">is field-&gt;pack_length(),</span><span class="hljs-comment">except that for a &gt;= 5.0.3</span><span class="hljs-comment">type true VARCHAR this is the</span><span class="hljs-comment">maximum byte length of the</span><span class="hljs-comment">string data (in addition to</span><span class="hljs-comment">the string, MySQL uses 1 or 2</span><span class="hljs-comment">bytes to store the string length) */</span><span class="hljs-keyword">unsigned</span>mbminmaxlen:<span class="hljs-number">5</span>;<span class="hljs-comment">/*!&lt; minimum and maximum length of a</span><span class="hljs-comment">character, in bytes;</span><span class="hljs-comment">DATA_MBMINMAXLEN(mbminlen,mbmaxlen);</span><span class="hljs-comment">mbminlen=DATA_MBMINLEN(mbminmaxlen);</span><span class="hljs-comment">mbmaxlen=DATA_MBMINLEN(mbminmaxlen) */</span><span class="hljs-comment">/*----------------------*/</span><span class="hljs-comment">/* End of definitions copied from dtype_t */</span><span class="hljs-comment">/* @} */</span><span class="hljs-keyword">unsigned</span>ind:<span class="hljs-number">10</span>;<span class="hljs-comment">/*!&lt; table column position</span><span class="hljs-comment">(starting from 0) */</span><span class="hljs-keyword">unsigned</span>ord_part:<span class="hljs-number">1</span>;<span class="hljs-comment">/*!&lt; nonzero if this column</span><span class="hljs-comment">appears in the ordering fields</span><span class="hljs-comment">of an index */</span><span class="hljs-keyword">unsigned</span>max_prefix:<span class="hljs-number">12</span>;<span class="hljs-comment">/*!&lt; maximum index prefix length on</span><span class="hljs-comment">this column. Our current max limit is</span><span class="hljs-comment">3072 for Barracuda table */</span>};</code></pre><h2 id="2-innodb线程的产生过程"><a href="#2-innodb线程的产生过程" class="headerlink" title="2. innodb线程的产生过程"></a>2. innodb线程的产生过程</h2><p>在mysql_main函数里面有一行代码是加载组件:</p><pre><code class="hljs c++"><span class="hljs-comment">//...</span><span class="hljs-comment">//MySQL 5.7.19版本mysqld.cc文件的4673行</span>  <span class="hljs-keyword">if</span> (init_server_components())    unireg_abort(MYSQLD_ABORT_EXIT);<span class="hljs-comment">//...</span></code></pre><p>其中有关于插件的初始化的函数:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">init_server_components</span><span class="hljs-params">()</span></span>{    <span class="hljs-comment">//...</span><span class="hljs-comment">/*</span><span class="hljs-comment">    Skip reading the plugin table when starting with --help in order</span><span class="hljs-comment">    to also skip initializing InnoDB. This provides a simpler and more</span><span class="hljs-comment">    uniform handling of various startup use cases, e.g. when the data</span><span class="hljs-comment">    directory does not exist, exists but is empty, exists with InnoDB</span><span class="hljs-comment">    system tablespaces present etc.</span><span class="hljs-comment">  */</span>  <span class="hljs-keyword">if</span> (plugin_init(&amp;remaining_argc, remaining_argv,                  (opt_noacl ? PLUGIN_INIT_SKIP_PLUGIN_TABLE : <span class="hljs-number">0</span>) |                  (opt_help ? (PLUGIN_INIT_SKIP_INITIALIZATION |                               PLUGIN_INIT_SKIP_PLUGIN_TABLE) : <span class="hljs-number">0</span>)))  {    sql_print_error(<span class="hljs-string">"Failed to initialize plugins."</span>);    unireg_abort(MYSQLD_ABORT_EXIT);  }    <span class="hljs-comment">//...</span>}</code></pre><p><code>plugin_init</code>函数里面又有:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">plugin_init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">int</span> flags)</span></span><span class="hljs-function"></span>{<span class="hljs-comment">//...</span>      <span class="hljs-comment">/* Register all dynamic plugins */</span>  <span class="hljs-keyword">if</span> (!(flags &amp; PLUGIN_INIT_SKIP_DYNAMIC_LOADING))  {    <span class="hljs-function">I_List_iterator&lt;i_string&gt; <span class="hljs-title">iter</span><span class="hljs-params">(opt_plugin_load_list)</span></span>;    i_string *item;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">NULL</span> != (item= iter++))      plugin_load_list(&amp;tmp_root, argc, argv, item-&gt;ptr);    <span class="hljs-keyword">if</span> (!(flags &amp; PLUGIN_INIT_SKIP_PLUGIN_TABLE))      plugin_load(&amp;tmp_root, argc, argv);  }    <span class="hljs-comment">//...</span>}</code></pre><p>其中加载插件函数:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">plugin_load</span><span class="hljs-params">(MEM_ROOT *tmp_root, <span class="hljs-keyword">int</span> *argc, <span class="hljs-keyword">char</span> **argv)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//...</span>     <span class="hljs-keyword">if</span> (plugin_add(tmp_root, &amp;name, &amp;dl, argc, argv, REPORT_TO_LOG))      sql_print_warning(<span class="hljs-string">"Couldn't load plugin named '%s' with soname '%s'."</span>,                        str_name.c_ptr(), str_dl.c_ptr());    <span class="hljs-comment">//...</span>}</code></pre><p>其中的<code>plugin_add</code>:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">plugin_add</span><span class="hljs-params">(MEM_ROOT *tmp_root,</span></span><span class="hljs-function"><span class="hljs-params">                       <span class="hljs-keyword">const</span> LEX_STRING *name, <span class="hljs-keyword">const</span> LEX_STRING *dl,</span></span><span class="hljs-function"><span class="hljs-params">                       <span class="hljs-keyword">int</span> *argc, <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">int</span> report)</span></span><span class="hljs-function"></span>{    st_plugin_int tmp;  st_mysql_plugin *plugin;  DBUG_ENTER(<span class="hljs-string">"plugin_add"</span>);  LEX_CSTRING name_cstr= {name-&gt;str, name-&gt;length};    <span class="hljs-comment">//...</span>}</code></pre><p>其中<code>st_mysql_plugin</code>:</p><pre><code class="hljs c++"><span class="hljs-comment">/*</span><span class="hljs-comment">  Plugin description structure.</span><span class="hljs-comment">*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st_mysql_plugin</span></span><span class="hljs-class">{</span>  <span class="hljs-keyword">int</span> type;             <span class="hljs-comment">/* the plugin type (a MYSQL_XXX_PLUGIN value)   */</span>  <span class="hljs-keyword">void</span> *info;           <span class="hljs-comment">/* pointer to type-specific plugin descriptor   */</span>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name;     <span class="hljs-comment">/* plugin name                                  */</span>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *author;   <span class="hljs-comment">/* plugin author (for I_S.PLUGINS)              */</span>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *descr;    <span class="hljs-comment">/* general descriptive text (for I_S.PLUGINS)   */</span>  <span class="hljs-keyword">int</span> license;          <span class="hljs-comment">/* the plugin license (PLUGIN_LICENSE_XXX)      */</span>  <span class="hljs-keyword">int</span> (*init)(MYSQL_PLUGIN);  <span class="hljs-comment">/* the function to invoke when plugin is loaded */</span>  <span class="hljs-keyword">int</span> (*deinit)(MYSQL_PLUGIN);<span class="hljs-comment">/* the function to invoke when plugin is unloaded */</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> version; <span class="hljs-comment">/* plugin version (for I_S.PLUGINS)             */</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st_mysql_show_var</span> *<span class="hljs-title">status_vars</span>;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st_mysql_sys_var</span> **<span class="hljs-title">system_vars</span>;</span>  <span class="hljs-keyword">void</span> * __reserved1;   <span class="hljs-comment">/* reserved for dependency checking             */</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;  <span class="hljs-comment">/* flags for plugin */</span>};</code></pre><p>其中的:</p><pre><code class="hljs smali">int (*init)(MYSQ<span class="hljs-class">L_PLUGIN);</span>  /* the function to<span class="hljs-built_in"> invoke </span>when plugin is loaded */</code></pre><p>这个init函数指针是调用插件的。</p><p>Innodb插件的加载定义在mysql/include/mysql/Plugin.h中的mysql_declare_plugin,具体的调用位置在ha_innodb.cc中，都是以变量的方式定义。Ha_innodb.cc是定义innodb存储引擎的初始化以及相关重要接口的定义。</p><p>插件的函数如下:</p><pre><code class="hljs c++">mysql_declare_plugin(innobase){  MYSQL_STORAGE_ENGINE_PLUGIN,  &amp;innobase_storage_engine,  innobase_hton_name,  plugin_author,  <span class="hljs-string">"Supports transactions, row-level locking, and foreign keys"</span>,  PLUGIN_LICENSE_GPL,  innobase_init, <span class="hljs-comment">/* Plugin Init */</span>  <span class="hljs-literal">NULL</span>, <span class="hljs-comment">/* Plugin Deinit */</span>  INNODB_VERSION_SHORT,  innodb_status_variables_export,<span class="hljs-comment">/* status variables             */</span>  innobase_system_variables, <span class="hljs-comment">/* system variables */</span>  <span class="hljs-literal">NULL</span>, <span class="hljs-comment">/* reserved */</span>  <span class="hljs-number">0</span>,    <span class="hljs-comment">/* flags */</span>},i_s_innodb_trx,i_s_innodb_locks,i_s_innodb_lock_waits,i_s_innodb_cmp,<span class="hljs-comment">//...</span>mysql_declare_plugin_end;</code></pre><p>当插件被载入的时候，就会调用上面代码中的innobase_init()函数:</p><pre><code class="hljs c++"><span class="hljs-keyword">static</span><span class="hljs-keyword">int</span>innobase_init(<span class="hljs-comment">/*==========*/</span><span class="hljs-keyword">void</span>*p)<span class="hljs-comment">/*!&lt; in: InnoDB handlerton */</span>{<span class="hljs-comment">//...</span><span class="hljs-comment">/* Since we in this module access directly the fields of a trx</span><span class="hljs-comment">struct, and due to different headers and flags it might happen that</span><span class="hljs-comment">ib_mutex_t has a different size in this module and in InnoDB</span><span class="hljs-comment">modules, we check at run time that the size is the same in</span><span class="hljs-comment">these compilation modules. */</span>err = innobase_start_or_create_for_mysql();<span class="hljs-comment">//...</span>}</code></pre><p>其中:<sup><a href="#fn_1" id="reffn_1">1</a></sup></p><pre><code class="hljs c++"><span class="hljs-comment">/********************************************************************</span><span class="hljs-comment">Starts InnoDB and creates a new database if database files</span><span class="hljs-comment">are not found and the user wants.</span><span class="hljs-comment">@return DB_SUCCESS or error code */</span><span class="hljs-keyword">dberr_t</span>innobase_start_or_create_for_mysql(<span class="hljs-keyword">void</span>)<span class="hljs-comment">/*====================================*/</span>{<span class="hljs-comment">//...</span><span class="hljs-comment">/* Create the master thread which does purge and other utility</span><span class="hljs-comment">operations */</span><span class="hljs-keyword">if</span> (!srv_read_only_mode) {os_thread_create(srv_master_thread,<span class="hljs-literal">NULL</span>, thread_ids + (<span class="hljs-number">1</span> + SRV_MAX_N_IO_THREADS));srv_start_state_set(SRV_START_STATE_MASTER);}<span class="hljs-comment">//...</span>}</code></pre><p>调用了<code>srv_master_thread</code>产生master线程:</p><pre><code class="hljs c++"><span class="hljs-comment">/*********************************************************************/</span><span class="hljs-comment">/**</span><span class="hljs-comment">The master thread controlling the server.</span><span class="hljs-comment">@return a dummy parameter */</span><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span><span class="hljs-keyword">os_thread_ret_t</span>DECLARE_THREAD(srv_master_thread)(<span class="hljs-comment">/*==============================*/</span><span class="hljs-keyword">void</span>*arg MY_ATTRIBUTE((unused)))<span class="hljs-comment">/*!&lt; in: a dummy parameter required by</span><span class="hljs-comment">os_thread_create */</span>;</code></pre><p>由此进入master线程</p><h2 id="3-Master-Thread工作方式"><a href="#3-Master-Thread工作方式" class="headerlink" title="3. Master Thread工作方式"></a>3. Master Thread工作方式</h2><p>流程图如下:<sup><a href="#fn_7" id="reffn_7">7</a></sup></p><p><img src="InnoDB_Master_Thread.png" srcset="/img/loading.gif" alt="InnoDB Master Thread"></p><p>上面的<code>srv_master_thread</code>已经定位到的函数的代码如下:</p><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span><span class="hljs-keyword">os_thread_ret_t</span>DECLARE_THREAD(srv_master_thread)(<span class="hljs-comment">/*==============================*/</span><span class="hljs-keyword">void</span>*arg MY_ATTRIBUTE((unused)))<span class="hljs-comment">/*!&lt; in: a dummy parameter required by</span><span class="hljs-comment">os_thread_create */</span>{<span class="hljs-comment">//...线程初始化</span>loop:<span class="hljs-keyword">if</span> (srv_force_recovery &gt;= SRV_FORCE_NO_BACKGROUND) {        <span class="hljs-comment">/*出现故障需要回复时候,如果设置恢复级别为SRV_FORCE_NO_BACKGROUND则会挂起主线程的运行,所以进入挂起*/</span><span class="hljs-keyword">goto</span> suspend_thread;}<span class="hljs-keyword">while</span> (srv_shutdown_state == SRV_SHUTDOWN_NONE) {srv_master_sleep();MONITOR_INC(MONITOR_MASTER_THREAD_SLEEP);<span class="hljs-keyword">if</span> (srv_check_activity(old_activity_count)) {old_activity_count = srv_get_activity_count();srv_master_do_active_tasks();} <span class="hljs-keyword">else</span> {srv_master_do_idle_tasks();}}<span class="hljs-keyword">while</span> (srv_shutdown_state != SRV_SHUTDOWN_EXIT_THREADS       &amp;&amp; srv_master_do_shutdown_tasks(&amp;last_print_time)) {        <span class="hljs-comment">/**/</span><span class="hljs-comment">/* Shouldn't loop here in case of very fast shutdown */</span>ut_ad(srv_fast_shutdown &lt; <span class="hljs-number">2</span>);}suspend_thread:srv_main_thread_op_info = <span class="hljs-string">"suspending"</span>;srv_suspend_thread(slot);<span class="hljs-comment">/* DO NOT CHANGE THIS STRING. innobase_start_or_create_for_mysql()</span><span class="hljs-comment">waits for database activity to die down when converting &lt; 4.1.x</span><span class="hljs-comment">databases, and relies on this string being exactly as it is. InnoDB</span><span class="hljs-comment">manual also mentions this string in several places. */</span>srv_main_thread_op_info = <span class="hljs-string">"waiting for server activity"</span>;os_event_wait(slot-&gt;event);<span class="hljs-keyword">if</span> (srv_shutdown_state != SRV_SHUTDOWN_EXIT_THREADS) {<span class="hljs-keyword">goto</span> loop;}my_thread_end();os_thread_exit();DBUG_RETURN(<span class="hljs-number">0</span>);}</code></pre><p>可以知道伪代码如下:</p><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> <span class="hljs-variable">InnoDB</span> <span class="hljs-variable">is</span> <span class="hljs-variable">idle</span>:<span class="hljs-function"><span class="hljs-title">srv_master_do_idle_tasks</span>();</span><span class="hljs-function"><span class="hljs-variable"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"><span class="hljs-title">srv_master_do_active_tasks</span>();</span></code></pre><p>在图2中可以看到，master thread作为后台程序，一直不停的在loop，而loop过程中会选择active task 或者idle task函数执行:<sup><a href="#fn_2" id="reffn_2">2</a></sup></p><ul><li><p>只有在innodb_force_recovery参数设置值大于SRV_FORCE_NO_BACKGROUND的情况下，master thread会进入suspend状态</p><p>若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend__loop，将Master Thread挂起，等待事件的发生。若用户启用（enable）了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起的状态<sup><a href="#fn_4" id="reffn_4">4</a></sup>。</p></li><li><p>在srv_shutdown_state的值不等于SRV_SHUTDOWN_NONE的情况下，master thread会去执行shutdown task。输出值srv_active，srv_idle，srv_shutdown的值分别是在函数srv_master_do_active_task，srv_master_do_idle_task，srv_master_do_shutdown_task中++。</p></li><li><p>而srv_master_do_active_task的执行是由当前activity_count与old_activity_count的值决定，只要这两个值不相等，则master调用active task。在执行数据库更改操作，如插入，删除，更新，表操作的情况下，当前的activity count的值会增加，系统调用active task。所以说，srv_active的值可以反映出系统的负载情况.</p></li><li><p>值得注意的是background thread 部分的输出值是历史统计值，即mysqld服务启动之后会一直递增。</p></li></ul><p><code>srv_master_do_active_tasks</code>做的事情如下:</p><p>当服务器处于活动状态时，执行主线程应该执行的任务。 有两种类型的任务:</p><ol><li>第一类是在此功能的每次启动时执行的此类任务。我们假设在服务器处于活动状态时大致每秒调用一次此功能。</li><li>第二类是按一定间隔执行的此类任务，例如：purge, dict_LRU cleanup等。</li></ol><p>具体代码如下:</p><ul><li><p>检查剩余的日志空间</p><pre><code class="hljs c++"><span class="hljs-comment">/* 确保redo日志文件中有足够的可重用空间*/</span>srv_main_thread_op_info = <span class="hljs-string">"checking free log space"</span>;<span class="hljs-comment">/*检查是否需要刷新日志缓冲区或新的检查点，如果是，则执行此操作。 当数据库操作修改了大约4个以上的页面时，应调用此方法。 注意，仅当OS线程除字典互斥锁外没有其他同步对象时，才可以调用此函数。*/</span>log_free_check();</code></pre></li><li><p>插入缓存<em>缓存的insert操作insert buffer,缩写ibuf</em><sup><a href="#fn_3" id="reffn_3">3</a></sup> <sup><a href="#fn_4" id="reffn_4">4</a></sup></p><p>合并插入缓冲（Insert Buffer）并不是每秒都会发生的。InnoDB存储引擎会判断当前一秒内发生的IO次数是否小于5次，如果小于5次，InnoDB认为当前的IO压力很小，可以执行合并插入缓冲的操作。<sup><a href="#fn_4" id="reffn_4">4</a></sup></p><pre><code class="hljs c++"><span class="hljs-comment">/* Do an ibuf merge */</span>srv_main_thread_op_info = <span class="hljs-string">"doing insert buffer merge"</span>;counter_time = ut_time_us(<span class="hljs-literal">NULL</span>);ibuf_merge_in_background(<span class="hljs-literal">false</span>);MONITOR_INC_TIME_IN_MICRO_SECS(MONITOR_SRV_IBUF_MERGE_MICROSECOND, counter_time);</code></pre><p><code>ibuf_merge_in_background</code>的思路:<sup><a href="#fn_4" id="reffn_4">4</a></sup></p><p>InnoDB存储引擎的开发团队参考了Google的patch，提供了类似的方法来修正该问题。因此InnoDB Plugin（从InnoDB1.0.x版本开始）提供了参数innodb_io_capacity，用来表示磁盘IO的吞吐量，默认值为200。对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来进行控制。规则如下：</p><p>❑在合并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%；</p><p>❑在从缓冲区刷新脏页时，刷新脏页的数量为innodb_io_capacity。</p><p>若用户使用了SSD类的磁盘，或者将几块磁盘做了RAID，当存储设备拥有更高的IO速度时，完全可以将innodb_io_capacity的值调得再高点，直到符合磁盘IO的吞吐量为止。</p><p>源码如下:</p><pre><code class="hljs c++"><span class="hljs-comment">/*通过将页面读到缓冲池来收缩更改缓冲区。</span><span class="hljs-comment">@param[in] full如果为true，则基于PCT_IO（100）进行完全收缩。 如果为false，则基于更改缓冲区的当前大小确定合同批的大小。 </span><span class="hljs-comment">@return 条目的组合大小的下限（以字节为单位），这些条目将从ibuf树合并到读取的页面，如果ibuf为空，则返回0*/</span><span class="hljs-function">ulint <span class="hljs-title">ibuf_merge_in_background</span><span class="hljs-params">(<span class="hljs-keyword">bool</span>full)</span></span><span class="hljs-function"></span>{ulintsum_bytes= <span class="hljs-number">0</span>;ulintsum_pages= <span class="hljs-number">0</span>;ulintn_pag2;ulintn_pages;<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined UNIV_DEBUG || defined UNIV_IBUF_DEBUG</span><span class="hljs-keyword">if</span> (srv_ibuf_disable_background_merge) {<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);}<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* UNIV_DEBUG || UNIV_IBUF_DEBUG */</span></span><span class="hljs-keyword">if</span> (full) {<span class="hljs-comment">/* Caller has requested a full batch */</span>        <span class="hljs-comment">/*IO操作数，即容量的X％。 PCT_IO（5)返回的IO操作数为最大值的5％，其中最大值为srv_io_capacity(默认为200)。*/</span>n_pages = PCT_IO(<span class="hljs-number">100</span>);} <span class="hljs-keyword">else</span> {<span class="hljs-comment">/* By default we do a batch of 5% of the io_capacity */</span>n_pages = PCT_IO(<span class="hljs-number">5</span>);mutex_enter(&amp;ibuf_mutex);<span class="hljs-comment">/* 如果ibuf-&gt; size大于max_size的一半，那么我们将进行更剧烈的收缩 */</span>        <span class="hljs-comment">/*+1是为了避免被零除*/</span><span class="hljs-keyword">if</span> (ibuf-&gt;<span class="hljs-built_in">size</span> &gt; ibuf-&gt;max_size / <span class="hljs-number">2</span>) {ulint diff = ibuf-&gt;<span class="hljs-built_in">size</span> - ibuf-&gt;max_size / <span class="hljs-number">2</span>;n_pages += PCT_IO((diff * <span class="hljs-number">100</span>)   / (ibuf-&gt;max_size + <span class="hljs-number">1</span>));}mutex_exit(&amp;ibuf_mutex);}<span class="hljs-keyword">while</span> (sum_pages &lt; n_pages) {ulintn_bytes;n_bytes = ibuf_merge(&amp;n_pag2, <span class="hljs-literal">false</span>);<span class="hljs-keyword">if</span> (n_bytes == <span class="hljs-number">0</span>) {<span class="hljs-keyword">return</span>(sum_bytes);}sum_bytes += n_bytes;sum_pages += n_pag2;}<span class="hljs-keyword">return</span>(sum_bytes);}</code></pre></li><li><p>日志缓冲刷新到磁盘,即使这个事务还没有提交</p> <pre><code class="hljs C++">  <span class="hljs-comment">/* Flush logs if needed */</span>srv_main_thread_op_info = <span class="hljs-string">"flushing log"</span>;srv_sync_log_buffer_in_background();  MONITOR_INC_TIME_IN_MICRO_SECS(  MONITOR_SRV_LOG_FLUSH_MICROSECOND, counter_time);</code></pre><p> 其中对<code>srv_sync_log_buffer_in_background()</code>的解读如下:</p> <pre><code class="hljs c++"><span class="hljs-comment">/*主线程的任务是确保在后台每秒刷新一次日志文件。 这是为了确保当innodb_flush_logs_at_trx_commit！= 1崩溃时，丢失的trx不会超过一秒钟。*/</span>srv_sync_log_buffer_in_background(<span class="hljs-keyword">void</span>)<span class="hljs-comment">/*===================================*/</span>{<span class="hljs-keyword">time_t</span>current_time = time(<span class="hljs-literal">NULL</span>);srv_main_thread_op_info = <span class="hljs-string">"flushing log"</span>;<span class="hljs-keyword">if</span> (difftime(current_time, srv_last_log_flush_time)    &gt;= srv_flush_log_at_timeout) {<span class="hljs-comment">//srv_flush_log_at_timeout=1,即1秒</span>log_buffer_sync_in_background(<span class="hljs-literal">true</span>);<span class="hljs-comment">/*此函数将日志缓冲区写入日志文件，如果设置了“ flush”，则也会强制刷新日志文件。 仅应从后台主线程调用此方法，因为它不等待写入（+可能的刷新）完成。*/</span>srv_last_log_flush_time = current_time;srv_log_writes_and_flush++;}}</code></pre></li></ul><p><code>srv_master_do_idle_tasks</code>的工作主要如下:</p><p>每当服务器空闲时，执行主线程应该执行的任务。 我们会在此功能期间检查服务器状态，如果服务器已进入关闭阶段，我们可能会在未完成所需任务的情况下从函数返回。</p><p><strong>注意:执行此功能时服务器可以进入活动状态，但函数不会监测，因为本函数和在服务器处于活动状态时执行或多或少的相同的任务。</strong></p><p>如果禁用主线程，循环sleep10秒:</p><pre><code class="hljs c++">ut_d(srv_master_do_disabled_loop());</code></pre><p>因为空闲,有时间进行全缓冲区的插入合并:</p><pre><code class="hljs c++">ibuf_merge_in_background(<span class="hljs-literal">true</span>);</code></pre><p>其余的就是一些后续的处理</p><h2 id="4-page-clean线程"><a href="#4-page-clean线程" class="headerlink" title="4. page clean线程"></a>4. page clean线程</h2><p>在上述<a href="#2. innodb线程的产生过程">2. innodb线程的产生过程</a>中已经提到的<code>innobase_start_or_create_for_mysql</code>中有page clean线程:</p><pre><code class="hljs c++">innobase_start_or_create_for_mysql(<span class="hljs-keyword">void</span>)<span class="hljs-comment">/*====================================*/</span>{    <span class="hljs-comment">//...</span><span class="hljs-comment">/* 即使在只读模式下，内部表操作也可能会产生刷新操作。 */</span>buf_flush_page_cleaner_init();os_thread_create(buf_flush_page_cleaner_coordinator,<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; srv_n_page_cleaners; ++i) {os_thread_create(buf_flush_page_cleaner_worker,<span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);}<span class="hljs-comment">/* Make sure page cleaner is active. */</span><span class="hljs-keyword">while</span> (!buf_page_cleaner_is_active) {os_thread_sleep(<span class="hljs-number">10000</span>);}    <span class="hljs-comment">//...</span>}</code></pre><p>其中的<code>buf_flush_page_cleaner_worker</code>是Page Cleaner Thread,为了提升扩展性和刷脏效率，在innodb1.2.X版本里引入了多个page cleaner线程。从而达到并行刷脏的效果<sup><a href="#fn_5" id="reffn_5">5</a></sup></p><p>在该版本中，Page cleaner并未和buffer pool绑定，其模型为一个协调线程 + 多个工作线程，协调线程本身也是工作线程。因此如果innodb_page_cleaners设置为8，那么就是一个协调线程，加7个工作线程</p><ul><li><p><strong>协调线程的入口函数为</strong><code>buf_flush_page_cleaner_coordinator</code>:</p><p>决定了需要flush的page数和lsn_limit后，会设置slot数组，将其中每个slot的状态设置为PAGE_CLEANER_STATE_REQUESTED, 并设置目标page数及lsn_limit，然后唤醒worker线程 (pc_request)\</p><p>主循环:</p><p>实际正常运行情况下的工作都包含在:<sup><a href="#fn_6" id="reffn_6">6</a></sup></p><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (srv_shutdown_state == SRV_SHUTDOWN_NONE) {    <span class="hljs-comment">//...</span>}</code></pre><p>之中.</p><ol><li><p>首先如果没有活跃的change buffer 并且没有pending的物理块，并且上次刷新的块数量为0则不需要睡眠1秒:</p><pre><code class="hljs c++"><span class="hljs-comment">/* 如果服务器空闲并且缓冲池中没有待处理的IO，并且有工作要做，则page_cleaner会跳过睡眠。 */</span><span class="hljs-keyword">if</span> (srv_check_activity(last_activity)    || buf_get_n_pending_read_ios()    || n_flushed == <span class="hljs-number">0</span>) {ret_sleep = pc_sleep_if_needed(next_loop_time, sig_count);<span class="hljs-comment">//睡眠一秒</span><span class="hljs-keyword">if</span> (srv_shutdown_state != SRV_SHUTDOWN_NONE) {<span class="hljs-keyword">break</span>;}} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ut_time_ms() &gt; next_loop_time) {          <span class="hljs-comment">//如果当前时间大于 上次刷新 时间+1 秒则 设置为OS_SYNC_TIME_EXCEEDED</span>ret_sleep = OS_SYNC_TIME_EXCEEDED;} <span class="hljs-keyword">else</span> {ret_sleep = <span class="hljs-number">0</span>;}</code></pre><p>但是这个睡眠是可以被唤醒的，比如同步刷新应该就会唤醒它（buf_flush_request_force函数）。参考函数os_event::wait_time_low</p></li><li><p>IO能力不足警告</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (curr_time &gt; next_loop_time + <span class="hljs-number">3000</span>) {<span class="hljs-comment">//如果刷新时间 大于了 上次时间 +1 秒+3 秒 则报info</span><span class="hljs-keyword">if</span> (warn_count == <span class="hljs-number">0</span>) {ib::info() &lt;&lt; <span class="hljs-string">"page_cleaner: 1000ms"</span><span class="hljs-string">" intended loop took "</span>&lt;&lt; <span class="hljs-number">1000</span> + curr_time   - next_loop_time&lt;&lt; <span class="hljs-string">"ms. The settings might not"</span><span class="hljs-string">" be optimal. (flushed="</span>&lt;&lt; n_flushed_last&lt;&lt; <span class="hljs-string">" and evicted="</span>&lt;&lt; n_evicted&lt;&lt; <span class="hljs-string">", during the time.)"</span>;<span class="hljs-keyword">if</span> (warn_interval &gt; <span class="hljs-number">300</span>) {warn_interval = <span class="hljs-number">600</span>;} <span class="hljs-keyword">else</span> {warn_interval *= <span class="hljs-number">2</span>;}warn_count = warn_interval;} <span class="hljs-keyword">else</span> {--warn_count;}} <span class="hljs-keyword">else</span> {<span class="hljs-comment">/* reset counter */</span>warn_interval = <span class="hljs-number">1</span>;warn_count = <span class="hljs-number">0</span>;}</code></pre></li><li><p>同步刷新判断</p><p><strong>触发条件</strong>:</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (ret_sleep != OS_SYNC_TIME_EXCEEDED    &amp;&amp; srv_flush_sync    &amp;&amp; buf_flush_sync_lsn &gt; <span class="hljs-number">0</span>)</code></pre><p>同步会唤醒正在睡眠状态的page clean协调工作线程,那么睡眠应该不会满足一秒的条件,所以不会被标记为OS_SYNC_TIME_EXCEEDED，同时srv_flush_sync和buf_flush_sync_lsn均会被设置,接下来就是唤醒工作线程进行刷新，同时本协调线程也完成部分任务。</p><p>  工作代码:</p><pre><code class="hljs c++"><span class="hljs-comment">/* Request flushing for threads */</span>pc_request(ULINT_MAX, lsn_limit);<span class="hljs-comment">//唤醒page clean 工作线程干活</span>       ulint tm = ut_time_ms();       <span class="hljs-comment">/* Coordinator also treats requests */</span><span class="hljs-keyword">while</span> (pc_flush_slot() &gt; <span class="hljs-number">0</span>) {}<span class="hljs-comment">////协调者同样完成部分任务</span></code></pre><p>  <strong>唤醒操作</strong>:</p><p>在checkpoint或者DML语句执行过程中都会通过log_free_check检查是否redo log处于安全的状态，如果不安全就会调用如下代码（log_preflush_pool_modified_pages函数中）唤醒page clean线程进行同步刷新</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (srv_flush_sync) {        <span class="hljs-comment">/* wake page cleaner for IO burst */</span>         buf_flush_request_force(new_oldest); <span class="hljs-comment">//设置全局变量同时通过broadcast唤醒同步刷新</span>     }     buf_flush_wait_flushed(new_oldest); <span class="hljs-comment">//所有线程等待同步刷新完成</span></code></pre></li><li><p>活跃刷新</p><p><strong>触发条件</strong>:</p><pre><code class="hljs c++"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (srv_check_activity(last_activity))</code></pre><p>这里判断是否有活跃的线程，所谓活跃就是调用srv_inc_activity_count函数进行增加的，一般来讲DML和DDL会标记为活跃，purge线程及其工作线程工作期间会标记为活跃。可以将断点做到srv_inc_activity_count进行debug。所以线上数据库DML比较多所以一般都会是活跃刷新。</p><p><strong>工作代码</strong>:</p><p>这里涉及到刷新多少个块计算主要函数为 <code>page_cleaner_flush_pages_recommendation</code></p><pre><code class="hljs c++">ulintn_to_flush;<span class="hljs-keyword">lsn_t</span>lsn_limit = <span class="hljs-number">0</span>;     <span class="hljs-comment">/* Estimate pages from flush_list to be flushed */</span><span class="hljs-keyword">if</span> (ret_sleep == OS_SYNC_TIME_EXCEEDED) {last_activity = srv_get_activity_count();n_to_flush =page_cleaner_flush_pages_recommendation(&amp;lsn_limit, last_pages);} <span class="hljs-keyword">else</span> {n_to_flush = <span class="hljs-number">0</span>;}     <span class="hljs-comment">//...</span>     pc_wait_finished(&amp;n_flushed_lru, &amp;n_flushed_list);</code></pre><p> <code>page_cleaner_flush_pages_recommendation</code>:</p><p>此函数最后计算出了需要刷新的块，其中刷新比率计算的的重点函数为af_get_pct_for_dirty和af_get_pct_for_lsn 下面将给出代码注释，其实前文中的算法就来自af_get_pct_for_dirty。</p><pre><code class="hljs c++"> {&nbsp;&nbsp;&nbsp;&nbsp;cur_lsn&nbsp;=&nbsp;log_get_lsn();<span class="hljs-comment">//获取当前的lsn&nbsp;在&nbsp;redo&nbsp;buffer中的</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(prev_lsn&nbsp;==&nbsp;<span class="hljs-number">0</span>)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//静态变量如果是0则代表是第一次执行本函数</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;First&nbsp;time&nbsp;around.&nbsp;*/</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev_lsn&nbsp;=&nbsp;cur_lsn;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev_time&nbsp;=&nbsp;ut_time();&nbsp;<span class="hljs-comment">//获取当前时间</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(prev_lsn&nbsp;==&nbsp;cur_lsn)&nbsp;{&nbsp;<span class="hljs-comment">//如果没有redo日志生成</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;sum_pages&nbsp;+=&nbsp;last_pages_in;&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">time_t</span>&nbsp;&nbsp;curr_time&nbsp;=&nbsp;ut_time();&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">double</span>&nbsp;&nbsp;time_elapsed&nbsp;=&nbsp;difftime(curr_time,&nbsp;prev_time);&nbsp;&nbsp;&nbsp;&nbsp;avg_page_rate&nbsp;=&nbsp;<span class="hljs-keyword">static_cast</span>&lt;ulint&gt;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(sum_pages)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;time_elapsed)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;avg_page_rate)&nbsp;/&nbsp;<span class="hljs-number">2</span>);&nbsp;<span class="hljs-comment">//算出上次刷新每秒刷新的pages数量，同时加上次计算的每秒平均刷新块数&nbsp;然后除以2&nbsp;得到一个每秒刷新的pages数量&nbsp;！！！第一个计算条件avg_page_rate&nbsp;生成</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;How&nbsp;much&nbsp;LSN&nbsp;we&nbsp;have&nbsp;generated&nbsp;since&nbsp;last&nbsp;call.&nbsp;*/</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lsn_rate&nbsp;=&nbsp;<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">lsn_t</span>&gt;(            <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(cur_lsn&nbsp;-&nbsp;prev_lsn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;time_elapsed);<span class="hljs-comment">//计算redo&nbsp;lsn生成率</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lsn_avg_rate&nbsp;=&nbsp;(lsn_avg_rate&nbsp;+&nbsp;lsn_rate)&nbsp;/&nbsp;<span class="hljs-number">2</span>;<span class="hljs-comment">//计算redo每秒平均生成率</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;aggregate&nbsp;stats&nbsp;of&nbsp;all&nbsp;slots&nbsp;*/</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex_enter(&amp;page_cleaner-&gt;mutex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;flush_tm&nbsp;=&nbsp;page_cleaner-&gt;flush_time;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;flush_pass&nbsp;=&nbsp;page_cleaner-&gt;flush_pass;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_cleaner-&gt;flush_time&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_cleaner-&gt;flush_pass&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;list_tm&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;list_pass&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">for</span>&nbsp;(ulint&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;i&nbsp;&lt;&nbsp;page_cleaner-&gt;n_slots;&nbsp;i++)&nbsp;{<span class="hljs-comment">//扫描所有的槽</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">page_cleaner_slot_t</span>*&nbsp;&nbsp;&nbsp;&nbsp;slot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slot&nbsp;=&nbsp;&amp;page_cleaner-&gt;slots[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_tm&nbsp;&nbsp;&nbsp;+=&nbsp;slot-&gt;flush_list_time;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_pass&nbsp;+=&nbsp;slot-&gt;flush_list_pass;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slot-&gt;flush_list_time&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slot-&gt;flush_list_pass&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex_exit(&amp;page_cleaner-&gt;mutex);&nbsp;&nbsp;&nbsp;&nbsp;oldest_lsn&nbsp;=&nbsp;buf_pool_get_oldest_modification();&nbsp;<span class="hljs-comment">//获取flush&nbsp;list中最老的ls</span>&nbsp;&nbsp;&nbsp;&nbsp;ut_ad(oldest_lsn&nbsp;&lt;=&nbsp;log_get_lsn());<span class="hljs-comment">//断言</span>&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;=&nbsp;cur_lsn&nbsp;&gt;&nbsp;oldest_lsn&nbsp;?&nbsp;cur_lsn&nbsp;-&nbsp;oldest_lsn&nbsp;:&nbsp;<span class="hljs-number">0</span>;&nbsp;<span class="hljs-comment">//获取当前LSN和最老LSN的之间的差值</span>&nbsp;&nbsp;&nbsp;&nbsp;pct_for_dirty&nbsp;=&nbsp;af_get_pct_for_dirty();&nbsp;<span class="hljs-comment">//计算出一个刷新百分比&nbsp;(比如100)&nbsp;!!!!重点</span>&nbsp;&nbsp;&nbsp;&nbsp;pct_for_lsn&nbsp;=&nbsp;af_get_pct_for_lsn(age);<span class="hljs-comment">//计算出lsn的比率&nbsp;百分比(l列如4.5)&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;pct_total&nbsp;=&nbsp;ut_max(pct_for_dirty,&nbsp;pct_for_lsn);<span class="hljs-comment">//取他们的大值</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;Estimate&nbsp;pages&nbsp;to&nbsp;be&nbsp;flushed&nbsp;for&nbsp;the&nbsp;lsn&nbsp;progress&nbsp;*/</span><span class="hljs-comment">//计算target_lsn</span>&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;sum_pages_for_lsn&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">lsn_t</span>&nbsp;&nbsp;&nbsp;target_lsn&nbsp;=&nbsp;oldest_lsn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;lsn_avg_rate&nbsp;*&nbsp;buf_flush_lsn_scan_factor;&nbsp;<span class="hljs-comment">//计算下一次刷新的&nbsp;&nbsp;目标lsn&nbsp;及target_lsnbuf_flush_lsn_scan_factor是定值3</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(ulint&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;i&nbsp;&lt;&nbsp;srv_buf_pool_instances;&nbsp;i++)&nbsp;{        <span class="hljs-comment">//循环整个buffer&nbsp;instance找到小于target_lsn的脏块</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">buf_pool_t</span>*&nbsp;buf_pool&nbsp;=&nbsp;buf_pool_from_array(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pages_for_lsn&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf_flush_list_mutex_enter(buf_pool);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        <span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">buf_page_t</span>*&nbsp;b&nbsp;=&nbsp;UT_LIST_GET_LAST(buf_pool-&gt;flush_list);             <span class="hljs-comment">//每个innodb&nbsp;buffer的末尾的flush&nbsp;list&nbsp;进行扫描，头插法?</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;!=&nbsp;<span class="hljs-literal">NULL</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;UT_LIST_GET_PREV(<span class="hljs-built_in">list</span>,&nbsp;b))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            <span class="hljs-keyword">if</span>&nbsp;(b-&gt;oldest_modification&nbsp;&gt;&nbsp;target_lsn)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                <span class="hljs-keyword">break</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++pages_for_lsn;&nbsp;            <span class="hljs-comment">//某个&nbsp;innodb&nbsp;buffer&nbsp;实例中&nbsp;flush&nbsp;list&nbsp;小于这个&nbsp;&nbsp;target&nbsp;lsn&nbsp;的&nbsp;page计数</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf_flush_list_mutex_exit(buf_pool);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum_pages_for_lsn&nbsp;+=&nbsp;pages_for_lsn;&nbsp;        <span class="hljs-comment">//这里汇总所有&nbsp;innodb&nbsp;buffer实例中&nbsp;&nbsp;flush&nbsp;list&nbsp;小于这个&nbsp;&nbsp;target&nbsp;lsn&nbsp;的&nbsp;page&nbsp;总数</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex_enter(&amp;page_cleaner-&gt;mutex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ut_ad(page_cleaner-&gt;slots[i].state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==&nbsp;PAGE_CLEANER_STATE_NONE);<span class="hljs-comment">//断言所有的槽处于没有刷新状态</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_cleaner-&gt;slots[i].n_pages_requested&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;pages_for_lsn&nbsp;/&nbsp;buf_flush_lsn_scan_factor&nbsp;+&nbsp;<span class="hljs-number">1</span>;&nbsp;<span class="hljs-comment">//确认槽的n_pages_requested值</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex_exit(&amp;page_cleaner-&gt;mutex);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;sum_pages_for_lsn&nbsp;/=&nbsp;buf_flush_lsn_scan_factor;<span class="hljs-comment">//buf_flush_lsn_scan_factor为定值3</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;Cap&nbsp;the&nbsp;maximum&nbsp;IO&nbsp;capacity&nbsp;that&nbsp;we&nbsp;are&nbsp;going&nbsp;to&nbsp;use&nbsp;by</span><span class="hljs-comment">&nbsp;&nbsp;&nbsp;&nbsp;max_io_capacity.&nbsp;Limit&nbsp;the&nbsp;value&nbsp;to&nbsp;avoid&nbsp;too&nbsp;quick&nbsp;increase&nbsp;*/</span>&nbsp;&nbsp;&nbsp;&nbsp;n_pages&nbsp;=&nbsp;PCT_IO(pct_total);&nbsp;<span class="hljs-comment">//根据&nbsp;前面得到的&nbsp;pct_total&nbsp;和&nbsp;srv_io_capacity参数得到&nbsp;刷新的块数&nbsp;!!!第二个计算参数生成。</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(age&nbsp;&lt;&nbsp;log_get_max_modified_age_async())&nbsp;{&nbsp;<span class="hljs-comment">//如果日质量小于&nbsp;异步刷新的范畴</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;pages_for_lsn&nbsp;= <span class="hljs-built_in">std</span>::<span class="hljs-built_in">min</span>&lt;ulint&gt;(sum_pages_for_lsn,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srv_max_io_capacity&nbsp;*&nbsp;<span class="hljs-number">2</span>);&nbsp;<span class="hljs-comment">//即便是需要刷新的块数很多，最多只能刷max_io_capacity*2的数量!!!第三个计算参数生成</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_pages&nbsp;=&nbsp;(n_pages&nbsp;+&nbsp;avg_page_rate&nbsp;+&nbsp;pages_for_lsn)&nbsp;/&nbsp;<span class="hljs-number">3</span>;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;3部分组成&nbsp;1、根据参数计算出来的IO能力&nbsp;2、以往每秒刷新页的数量&nbsp;3、根据target&nbsp;lsn&nbsp;计算出来的一个需要刷新的块数</span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;    <span class="hljs-keyword">if</span>&nbsp;(n_pages&nbsp;&gt;&nbsp;srv_max_io_capacity)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_pages&nbsp;=&nbsp;srv_max_io_capacity;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">return</span>(n_pages);}</code></pre><p> af_get_pct_for_dirty函数:</p><pre><code class="hljs c++"> {&nbsp;&nbsp;&nbsp;&nbsp;cur_lsn&nbsp;=&nbsp;log_get_lsn();<span class="hljs-comment">//获取当前的lsn&nbsp;在&nbsp;redo&nbsp;buffer中的</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(prev_lsn&nbsp;==&nbsp;<span class="hljs-number">0</span>)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//静态变量如果是0则代表是第一次执行本函数</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;First&nbsp;time&nbsp;around.&nbsp;*/</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev_lsn&nbsp;=&nbsp;cur_lsn;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prev_time&nbsp;=&nbsp;ut_time();&nbsp;<span class="hljs-comment">//获取当前时间</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">if</span>&nbsp;(prev_lsn&nbsp;==&nbsp;cur_lsn)&nbsp;{&nbsp;<span class="hljs-comment">//如果没有redo日志生成</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;sum_pages&nbsp;+=&nbsp;last_pages_in;&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">time_t</span>&nbsp;&nbsp;curr_time&nbsp;=&nbsp;ut_time();&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">double</span>&nbsp;&nbsp;time_elapsed&nbsp;=&nbsp;difftime(curr_time,&nbsp;prev_time);&nbsp;&nbsp;&nbsp;&nbsp;avg_page_rate&nbsp;=&nbsp;<span class="hljs-keyword">static_cast</span>&lt;ulint&gt;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(sum_pages)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;time_elapsed)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;avg_page_rate)&nbsp;/&nbsp;<span class="hljs-number">2</span>);&nbsp;<span class="hljs-comment">//算出上次刷新每秒刷新的pages数量，同时加上次计算的每秒平均刷新块数&nbsp;然后除以2&nbsp;得到一个每秒刷新的pages数量&nbsp;！！！第一个计算条件avg_page_rate&nbsp;生成</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;How&nbsp;much&nbsp;LSN&nbsp;we&nbsp;have&nbsp;generated&nbsp;since&nbsp;last&nbsp;call.&nbsp;*/</span>&nbsp;&nbsp;&nbsp;&nbsp;lsn_rate&nbsp;=&nbsp;<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">lsn_t</span>&gt;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(cur_lsn&nbsp;-&nbsp;prev_lsn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;time_elapsed);<span class="hljs-comment">//计算redo&nbsp;lsn生成率</span>&nbsp;&nbsp;&nbsp;&nbsp;lsn_avg_rate&nbsp;=&nbsp;(lsn_avg_rate&nbsp;+&nbsp;lsn_rate)&nbsp;/&nbsp;<span class="hljs-number">2</span>;<span class="hljs-comment">//计算redo每秒平均生成率</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;aggregate&nbsp;stats&nbsp;of&nbsp;all&nbsp;slots&nbsp;*/</span>&nbsp;&nbsp;&nbsp;&nbsp;mutex_enter(&amp;page_cleaner-&gt;mutex);&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;flush_tm&nbsp;=&nbsp;page_cleaner-&gt;flush_time;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;flush_pass&nbsp;=&nbsp;page_cleaner-&gt;flush_pass;&nbsp;&nbsp;&nbsp;&nbsp;page_cleaner-&gt;flush_time&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;page_cleaner-&gt;flush_pass&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;list_tm&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;list_pass&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">for</span>&nbsp;(ulint&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;i&nbsp;&lt;&nbsp;page_cleaner-&gt;n_slots;&nbsp;i++)&nbsp;{<span class="hljs-comment">//扫描所有的槽</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">page_cleaner_slot_t</span>*&nbsp;&nbsp;&nbsp;&nbsp;slot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slot&nbsp;=&nbsp;&amp;page_cleaner-&gt;slots[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_tm&nbsp;&nbsp;&nbsp;+=&nbsp;slot-&gt;flush_list_time;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_pass&nbsp;+=&nbsp;slot-&gt;flush_list_pass;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slot-&gt;flush_list_time&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slot-&gt;flush_list_pass&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;mutex_exit(&amp;page_cleaner-&gt;mutex);&nbsp;&nbsp;&nbsp;&nbsp;oldest_lsn&nbsp;=&nbsp;buf_pool_get_oldest_modification();&nbsp;<span class="hljs-comment">//获取flush&nbsp;list中最老的ls</span>&nbsp;&nbsp;&nbsp;&nbsp;ut_ad(oldest_lsn&nbsp;&lt;=&nbsp;log_get_lsn());<span class="hljs-comment">//断言</span>&nbsp;&nbsp;&nbsp;&nbsp;age&nbsp;=&nbsp;cur_lsn&nbsp;&gt;&nbsp;oldest_lsn&nbsp;?&nbsp;cur_lsn&nbsp;-&nbsp;oldest_lsn&nbsp;:&nbsp;<span class="hljs-number">0</span>;&nbsp;<span class="hljs-comment">//获取当前LSN和最老LSN的之间的差值</span>&nbsp;&nbsp;&nbsp;&nbsp;pct_for_dirty&nbsp;=&nbsp;af_get_pct_for_dirty();&nbsp;<span class="hljs-comment">//计算出一个刷新百分比&nbsp;(比如100)&nbsp;!!!!重点</span>&nbsp;&nbsp;&nbsp;&nbsp;pct_for_lsn&nbsp;=&nbsp;af_get_pct_for_lsn(age);<span class="hljs-comment">//计算出lsn的比率&nbsp;百分比(l列如4.5)&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;pct_total&nbsp;=&nbsp;ut_max(pct_for_dirty,&nbsp;pct_for_lsn);<span class="hljs-comment">//取他们的大值</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;Estimate&nbsp;pages&nbsp;to&nbsp;be&nbsp;flushed&nbsp;for&nbsp;the&nbsp;lsn&nbsp;progress&nbsp;*/</span><span class="hljs-comment">//计算target_lsn</span>&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;sum_pages_for_lsn&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">lsn_t</span>&nbsp;&nbsp;&nbsp;target_lsn&nbsp;=&nbsp;oldest_lsn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;lsn_avg_rate&nbsp;*&nbsp;buf_flush_lsn_scan_factor;&nbsp;<span class="hljs-comment">//计算下一次刷新的&nbsp;&nbsp;目标lsn&nbsp;及target_lsnbuf_flush_lsn_scan_factor是定值3</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(ulint&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;i&nbsp;&lt;&nbsp;srv_buf_pool_instances;&nbsp;i++)&nbsp;{        <span class="hljs-comment">//循环整个buffer&nbsp;instance找到小于target_lsn的脏块</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">buf_pool_t</span>*&nbsp;buf_pool&nbsp;=&nbsp;buf_pool_from_array(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pages_for_lsn&nbsp;=&nbsp;<span class="hljs-number">0</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf_flush_list_mutex_enter(buf_pool);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        <span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">buf_page_t</span>*&nbsp;b&nbsp;=&nbsp;UT_LIST_GET_LAST(buf_pool-&gt;flush_list);             <span class="hljs-comment">//每个innodb&nbsp;buffer的末尾的flush&nbsp;list&nbsp;进行扫描，头插法?</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;!=&nbsp;<span class="hljs-literal">NULL</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;UT_LIST_GET_PREV(<span class="hljs-built_in">list</span>,&nbsp;b))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            <span class="hljs-keyword">if</span>&nbsp;(b-&gt;oldest_modification&nbsp;&gt;&nbsp;target_lsn)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                <span class="hljs-keyword">break</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++pages_for_lsn;&nbsp;            <span class="hljs-comment">//某个&nbsp;innodb&nbsp;buffer&nbsp;实例中&nbsp;flush&nbsp;list&nbsp;小于这个&nbsp;&nbsp;target&nbsp;lsn&nbsp;的&nbsp;page计数</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf_flush_list_mutex_exit(buf_pool);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum_pages_for_lsn&nbsp;+=&nbsp;pages_for_lsn;&nbsp;        <span class="hljs-comment">//这里汇总所有&nbsp;innodb&nbsp;buffer实例中&nbsp;&nbsp;flush&nbsp;list&nbsp;小于这个&nbsp;&nbsp;target&nbsp;lsn&nbsp;的&nbsp;page&nbsp;总数</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex_enter(&amp;page_cleaner-&gt;mutex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ut_ad(page_cleaner-&gt;slots[i].state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==&nbsp;PAGE_CLEANER_STATE_NONE);<span class="hljs-comment">//断言所有的槽处于没有刷新状态</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_cleaner-&gt;slots[i].n_pages_requested&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;pages_for_lsn&nbsp;/&nbsp;buf_flush_lsn_scan_factor&nbsp;+&nbsp;<span class="hljs-number">1</span>;&nbsp;<span class="hljs-comment">//确认槽的n_pages_requested值</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutex_exit(&amp;page_cleaner-&gt;mutex);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;sum_pages_for_lsn&nbsp;/=&nbsp;buf_flush_lsn_scan_factor;<span class="hljs-comment">//buf_flush_lsn_scan_factor为定值3</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;Cap&nbsp;the&nbsp;maximum&nbsp;IO&nbsp;capacity&nbsp;that&nbsp;we&nbsp;are&nbsp;going&nbsp;to&nbsp;use&nbsp;by</span><span class="hljs-comment">&nbsp;&nbsp;&nbsp;&nbsp;max_io_capacity.&nbsp;Limit&nbsp;the&nbsp;value&nbsp;to&nbsp;avoid&nbsp;too&nbsp;quick&nbsp;increase&nbsp;*/</span>&nbsp;&nbsp;&nbsp;&nbsp;n_pages&nbsp;=&nbsp;PCT_IO(pct_total);&nbsp;    <span class="hljs-comment">//根据&nbsp;前面得到的&nbsp;pct_total&nbsp;和&nbsp;srv_io_capacity参数得到&nbsp;刷新的块数&nbsp;!!!第二个计算参数生成。</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(age&nbsp;&lt;&nbsp;log_get_max_modified_age_async())&nbsp;{&nbsp;<span class="hljs-comment">//如果日质量小于&nbsp;异步刷新的范畴</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ulint&nbsp;&nbsp;&nbsp;pages_for_lsn&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">min</span>&lt;ulint&gt;(sum_pages_for_lsn,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srv_max_io_capacity&nbsp;*&nbsp;<span class="hljs-number">2</span>);&nbsp;<span class="hljs-comment">//即便是需要刷新的块数很多，最多只能刷max_io_capacity*2的数量!!!第三个计算参数生成</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_pages&nbsp;=&nbsp;(n_pages&nbsp;+&nbsp;avg_page_rate&nbsp;+&nbsp;pages_for_lsn)&nbsp;/&nbsp;<span class="hljs-number">3</span>;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;3部分组成&nbsp;1、根据参数计算出来的IO能力&nbsp;2、以往每秒刷新页的数量&nbsp;3、根据target&nbsp;lsn&nbsp;计算出来的一个需要刷新的块数</span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">if</span>&nbsp;(n_pages&nbsp;&gt;&nbsp;srv_max_io_capacity)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n_pages&nbsp;=&nbsp;srv_max_io_capacity;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;    <span class="hljs-keyword">return</span>(n_pages);}</code></pre><p>af_get_pct_for_lsn函数：</p><p>注意innodb_cleaner_lsn_age_factor参数默认设置为high_checkpoint，可以看到算法最后是除以700.5，所有前文我说这个函数算出来的比率一般比较小。</p><pre><code class="hljs c++">     &nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">lsn_t</span>&nbsp;&nbsp;&nbsp;af_lwm&nbsp;=&nbsp;(srv_adaptive_flushing_lwm     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;log_get_capacity())&nbsp;/&nbsp;<span class="hljs-number">100</span>;<span class="hljs-comment">//&nbsp;srv_adaptive_flushing_lwm=10&nbsp;那么大约就是&nbsp;logtotalsize*(9/10)*(1/10)&nbsp;943349&nbsp;计算一个low&nbsp;water&nbsp;mark</span>     &nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(age&nbsp;&lt;&nbsp;af_lwm)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       <span class="hljs-comment">//如果当前生成的redo&nbsp;小于了&nbsp;low&nbsp;water&nbsp;master&nbsp;则返回0&nbsp;也就是说&nbsp;redo日志量生成量不高则不需要权衡</span>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;No&nbsp;adaptive&nbsp;flushing.&nbsp;*/</span>&nbsp;&nbsp;<span class="hljs-comment">//可以看出这里和redo设置的大小有关，如果redo文件设置越大则af_lwm越大，触发权衡的机率越小</span>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);     &nbsp;&nbsp;&nbsp;&nbsp;}     &nbsp;&nbsp;&nbsp;&nbsp;max_async_age&nbsp;=&nbsp;log_get_max_modified_age_async();&nbsp;<span class="hljs-comment">//获取需要异步刷新的的位置&nbsp;大约为logtotalsize*(9/10)*(7/8)</span>     &nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(age&nbsp;&lt;&nbsp;max_async_age&nbsp;&amp;&amp;&nbsp;!srv_adaptive_flushing)&nbsp;{&nbsp;       <span class="hljs-comment">//如果小于异步刷新&nbsp;且&nbsp;自适应flush&nbsp;没有开启</span>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;We&nbsp;have&nbsp;still&nbsp;not&nbsp;reached&nbsp;the&nbsp;max_async&nbsp;point&nbsp;and</span><span class="hljs-comment">     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;user&nbsp;has&nbsp;disabled&nbsp;adaptive&nbsp;flushing.&nbsp;*/</span>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>(<span class="hljs-number">0</span>);     &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">/*&nbsp;If&nbsp;we&nbsp;are&nbsp;here&nbsp;then&nbsp;we&nbsp;know&nbsp;that&nbsp;either:</span><span class="hljs-comment">     &nbsp;&nbsp;&nbsp;&nbsp;1)&nbsp;User&nbsp;has&nbsp;enabled&nbsp;adaptive&nbsp;flushing</span><span class="hljs-comment">     &nbsp;&nbsp;&nbsp;&nbsp;2)&nbsp;User&nbsp;may&nbsp;have&nbsp;disabled&nbsp;adaptive&nbsp;flushing&nbsp;but&nbsp;we&nbsp;have&nbsp;reached</span><span class="hljs-comment">     &nbsp;&nbsp;&nbsp;&nbsp;max_async_age.&nbsp;*/</span>     &nbsp;&nbsp;&nbsp;&nbsp;lsn_age_factor&nbsp;=&nbsp;(age&nbsp;*&nbsp;<span class="hljs-number">100</span>)&nbsp;/&nbsp;max_async_age;&nbsp;<span class="hljs-comment">//比率lsn_age_factor&nbsp;=&nbsp;(本次刷新的日志量/(logtotalsize*(9/10)*(7/8)))</span>     &nbsp;&nbsp;&nbsp;&nbsp;ut_ad(srv_max_io_capacity&nbsp;&gt;=&nbsp;srv_io_capacity);&nbsp;     &nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">switch</span>&nbsp;((<span class="hljs-keyword">srv_cleaner_lsn_age_factor_t</span>)srv_cleaner_lsn_age_factor)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;       <span class="hljs-keyword">case</span>&nbsp;SRV_CLEANER_LSN_AGE_FACTOR_LEGACY:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;           <span class="hljs-keyword">return</span>(<span class="hljs-keyword">static_cast</span>&lt;ulint&gt;(     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((srv_max_io_capacity&nbsp;/&nbsp;srv_io_capacity)     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(lsn_age_factor     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<span class="hljs-built_in">sqrt</span>((<span class="hljs-keyword">double</span>)lsn_age_factor)))     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;<span class="hljs-number">7.5</span>));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//430</span>     &nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">case</span>&nbsp;SRV_CLEANER_LSN_AGE_FACTOR_HIGH_CHECKPOINT:&nbsp;           <span class="hljs-comment">//innodb_cleaner_lsn_age_factor参数默认设置为high_checkpoint</span>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>(<span class="hljs-keyword">static_cast</span>&lt;ulint&gt;(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((srv_max_io_capacity&nbsp;/&nbsp;srv_io_capacity)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                   <span class="hljs-comment">//&nbsp;&nbsp;((max_io_cap&nbsp;/io_cap)&nbsp;*&nbsp;(sqrt(lsn_age_factor)*lsn_age_factor*lsn_age_factor))/700.5</span>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;(lsn_age_factor&nbsp;*&nbsp;lsn_age_factor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//(10&nbsp;*&nbsp;(3.3*10*10))/700&nbsp;=4.3</span>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;<span class="hljs-built_in">sqrt</span>((<span class="hljs-keyword">double</span>)lsn_age_factor)))     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/&nbsp;<span class="hljs-number">700.5</span>));</code></pre></li></ol></li><li><p><strong>工作线程的入口函数为</strong><code>buf_flush_page_cleaner_worker</code>:</p><p>线程被唤醒后，从slot数组中取一个未被占用的slot，修改其状态，表示已被调度，然后对该slot所对应的buffer pool instance进行操作</p></li></ul><h2 id="5-purge线程"><a href="#5-purge线程" class="headerlink" title="5. purge线程"></a>5. purge线程</h2><p><code>innobase_start_or_create_for_mysql</code>中的:</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (!srv_read_only_mode    &amp;&amp; srv_force_recovery &lt; SRV_FORCE_NO_BACKGROUND) {os_thread_create(srv_purge_coordinator_thread,<span class="hljs-literal">NULL</span>, thread_ids + <span class="hljs-number">5</span> + SRV_MAX_N_IO_THREADS);ut_a(UT_ARR_SIZE(thread_ids)     &gt; <span class="hljs-number">5</span> + srv_n_purge_threads + SRV_MAX_N_IO_THREADS);<span class="hljs-comment">/* We've already created the purge coordinator thread above. */</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; srv_n_purge_threads; ++i) {os_thread_create(srv_worker_thread, <span class="hljs-literal">NULL</span>,thread_ids + <span class="hljs-number">5</span> + i + SRV_MAX_N_IO_THREADS);}srv_start_wait_for_purge_to_start();srv_start_state_set(SRV_START_STATE_PURGE);} <span class="hljs-keyword">else</span> {purge_sys-&gt;state = PURGE_STATE_DISABLED;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql源码--main函数</title>
    <link href="/2020/07/03/mysql-yuan-ma-main-han-shu/"/>
    <url>/2020/07/03/mysql-yuan-ma-main-han-shu/</url>
    
    <content type="html"><![CDATA[<h1 id="1-main函数的理解"><a href="#1-main函数的理解" class="headerlink" title="1. main函数的理解"></a>1. main函数的理解</h1><p>函数的入口在<code>mysqld/main.cc</code>里面：</p><p><img src="image-20200627163326858.png" srcset="/img/loading.gif" alt="mysqld/main.cc"></p><p>而里面的函数在两个地方出现：</p><p><img src="image-20200627163411816.png" srcset="/img/loading.gif" alt="vs终端显示"></p><p>第一处在<code>mysqld.cc</code>的4364行出现：</p><p><img src="image-20200627165111499.png" srcset="/img/loading.gif" alt="第一处"></p><p>从上很明显看出，如果是WIN32系统，则函数名字是<code>win_main</code>,而我的系统是64位的系统，所以函数才会被命名为<code>mysqld_main</code>.</p><p>第二个<code>mysqld_main</code>是在WIN32系统中定义的，在此不考虑：</p><p><img src="image-20200627165736272.png" srcset="/img/loading.gif" alt="第二处"></p><p>查阅资料发现，Mysql为了实现可以在win32平台与类Uninx平台代码共用，将一些公用的函数抽象出来，但是win32和类unix平台启动方式不一样。细看win32的mysqld_main调用了mysql_service，mysql_service又调用了win_main函数，经过特殊操作处理后又回到了函数的公共定义内容：</p><pre><code class="hljs C++"><span class="hljs-comment">//win32的mysqld_main</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mysqld_main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><span class="hljs-function"></span>{<span class="hljs-comment">//...</span>mysql_service(<span class="hljs-literal">NULL</span>);<span class="hljs-comment">//...</span>}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mysql_service</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *p)</span></span><span class="hljs-function"></span>{    <span class="hljs-comment">//...</span>    <span class="hljs-keyword">if</span> (use_opt_args)    win_main(opt_argc, opt_argv);  <span class="hljs-keyword">else</span>    win_main(Service.my_argc, Service.my_argv);    <span class="hljs-comment">//...</span>}<span class="hljs-comment">//此win_main，就是第一个mysqld_main的代码内容</span></code></pre><h1 id="2-main函数的流程"><a href="#2-main函数的流程" class="headerlink" title="2. main函数的流程"></a>2. main函数的流程</h1><h2 id="2-1准备"><a href="#2-1准备" class="headerlink" title="2.1准备"></a>2.1准备</h2><ol><li><p>执行基本的线程库和malloc初始化，读取默认文件和解析选项。</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &amp;argc, &amp;argv))  {    flush_error_log_messages();    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  }</code></pre></li><li><p>是否使用PERFORMANCE_SCHEMA存储引擎</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WITH_PERFSCHEMA_STORAGE_ENGINE</span>  <span class="hljs-comment">/*</span><span class="hljs-comment">    Initialize the array of performance schema instrument configurations.</span><span class="hljs-comment">  */</span>  init_pfs_instrument_array();<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* WITH_PERFSCHEMA_STORAGE_ENGINE */</span></span></code></pre><p><img src="image-20200627203915117.png" srcset="/img/loading.gif" alt="mysql架构"><br>图源自:<a href="https://draven.co/" target="_blank" rel="noopener">https://draven.co/</a></p></li><li><p>默认配置文件的加载</p><pre><code class="hljs c++">load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &amp;argc, &amp;argv)</code></pre><p>my.ini文件的加载顺序，它会这样加载：<br>C:/WINDOWS/my.cnf　C:/WINDOWS/my.ini　C:/my.cnf 　C:/my.ini</p><p>如果指定了MYSQL_HOME，在找不到前边4个文件的时候，它会去查找$MYSQL_HOME$/my.cnf或my.ini</p><p>对应的代码如下：</p><pre><code class="hljs c++"><span class="hljs-keyword">char</span> fname_buffer[FN_REFLEN];<span class="hljs-comment">//C:/WINDOWS/my.cnf</span><span class="hljs-keyword">if</span> (my_get_system_windows_directory(fname_buffer, <span class="hljs-keyword">sizeof</span>(fname_buffer)))   errors += add_directory(alloc, fname_buffer, dirs);<span class="hljs-comment">//C:/WINDOWS/my.ini</span><span class="hljs-keyword">if</span> (GetWindowsDirectory(fname_buffer, <span class="hljs-keyword">sizeof</span>(fname_buffer)))   errors += add_directory(alloc, fname_buffer, dirs);<span class="hljs-comment">//C:/my.cnf</span>errors += add_directory(alloc, <span class="hljs-string">"C:/"</span>, dirs);<span class="hljs-comment">//C:/my.ini</span><span class="hljs-keyword">if</span> (my_get_module_parent(fname_buffer, <span class="hljs-keyword">sizeof</span>(fname_buffer)) != <span class="hljs-literal">NULL</span>)   errors += add_directory(alloc, fname_buffer, dirs);<span class="hljs-comment">//。。。如果是Linux系统。。。</span><span class="hljs-comment">//如果上面的四个位置找不到，则进行下面查找</span><span class="hljs-keyword">if</span> ((env= getenv(<span class="hljs-string">"MYSQL_HOME"</span>)))    errors += add_directory(alloc, env, dirs);  <span class="hljs-comment">/* Placeholder for --defaults-extra-file=&lt;path&gt; */</span>  errors += add_directory(alloc, <span class="hljs-string">""</span>, dirs);</code></pre></li></ol><h2 id="2-1WITH-PERFSCHEMA-STORAGE-ENGINE宏定义"><a href="#2-1WITH-PERFSCHEMA-STORAGE-ENGINE宏定义" class="headerlink" title="2.1WITH_PERFSCHEMA_STORAGE_ENGINE宏定义"></a>2.1<code>WITH_PERFSCHEMA_STORAGE_ENGINE</code>宏定义</h2><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> WITH_PERFSCHEMA_STORAGE_ENGINE</span>  <span class="hljs-comment">/*</span><span class="hljs-comment">    Initialize the array of performance schema instrument configurations.</span><span class="hljs-comment">  */</span>  init_pfs_instrument_array();<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* WITH_PERFSCHEMA_STORAGE_ENGINE */</span></span></code></pre><p>对应的编译的参数为<code>-DWITH_ARCHIVE_STORAGE_ENGINE=1</code>，对应的详细信息在：</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html</a></p><p><img src="image-20200628123338750.png" srcset="/img/loading.gif" alt="文件位置"></p><ol><li><p>初始化一些线程会用到的锁、信号量、变量等，其中封装了一些pthread的函数</p><p>接了下来调用了各种线程的初始化，过程感觉不是重点，没有继续看下去</p><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (my_init())  {    sql_print_error(<span class="hljs-string">"my_init() failed."</span>);    flush_error_log_messages();    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  }</code></pre></li><li><p>初始化SQL statement</p><p><code>init_sql_statement_names();</code></p></li><li><p>初始化系统变量</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sys_var_init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  DBUG_ENTER(<span class="hljs-string">"sys_var_init"</span>);  <span class="hljs-comment">/* Must be already initialized. */</span>  DBUG_ASSERT(system_charset_info != <span class="hljs-literal">NULL</span>);  <span class="hljs-keyword">if</span> (my_hash_init(&amp;system_variable_hash, system_charset_info, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>,                   <span class="hljs-number">0</span>, (my_hash_get_key) get_sys_var_length, <span class="hljs-number">0</span>, HASH_UNIQUE,                   PSI_INSTRUMENT_ME))    <span class="hljs-keyword">goto</span> error;  <span class="hljs-keyword">if</span> (mysql_add_sys_var_chain(all_sys_vars.first))    <span class="hljs-keyword">goto</span> error;  DBUG_RETURN(<span class="hljs-number">0</span>);error:  my_message_local(ERROR_LEVEL, <span class="hljs-string">"failed to initialize system variables"</span>);  DBUG_RETURN(<span class="hljs-number">1</span>);}</code></pre><p><code>system_variable_hash</code>是一个用于保存<code>sys_var</code>的哈希表</p><p><code>mysql_add_sys_var_chain</code>这个函数的本意应该是将<code>all_sys_vars</code>中的数据都加入<code>system_variable_hash</code>这个哈希表中</p></li><li><p>调整相关的选项</p><pre><code class="hljs c++">adjust_related_options(&amp;requested_open_files);</code></pre><p>具体的内容不是很清楚，看方法名猜测是调整函数名字对应的几个参数：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust_related_options</span><span class="hljs-params">(ulong *requested_open_files)</span></span><span class="hljs-function"></span>{  <span class="hljs-comment">/* In bootstrap, disable grant tables (we are about to create them) */</span>  <span class="hljs-keyword">if</span> (opt_bootstrap)    opt_noacl= <span class="hljs-number">1</span>;  <span class="hljs-comment">/* The order is critical here, because of dependencies. */</span>  adjust_open_files_limit(requested_open_files);  adjust_max_connections(*requested_open_files);  adjust_table_cache_size(*requested_open_files);  adjust_table_def_size();}</code></pre><p>打开文件的数量，最大连接数，表缓存大小等等</p><ul><li><p>open_files_limit值：</p><p>my.cnf里如果配置了open_files_limit，open_files_limit最后取值为 配置文件 open_files_limit，max_connections*5， wanted_files= 10+max_connections+table_cache_size*2 三者中的最大值。</p><p>如果my.cnf里如果没配置open_files_limit，open_files_limit最后取值为max_connections*5，10+max_connections+table_cache_size*2，ulimit -n中的最大者</p></li><li><p>max_connections的限制：</p><p>因为MySQL的最大连接数受到了安装平台的线程库、可用内存、每个连接需要使用的内存、每个连接的工作量、响应时间的影响，linux大概能承受500～1000并发请求，而Windows由于Posix通用接口层的限制，必须满足(open tables × 2 + open connections) &lt; 2048</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust_max_connections</span><span class="hljs-params">(ulong requested_open_files)</span></span><span class="hljs-function"></span>{  ulong limit;  limit= requested_open_files - <span class="hljs-number">10</span> - TABLE_OPEN_CACHE_MIN * <span class="hljs-number">2</span>;  <span class="hljs-keyword">if</span> (limit &lt; max_connections)  {    sql_print_warning(<span class="hljs-string">"Changed limits: max_connections: %lu (requested %lu)"</span>,                      limit, max_connections);    <span class="hljs-comment">// This can be done unprotected since it is only called on startup.</span>    max_connections= limit;  }}</code></pre><p>TABLE_OPEN_CACHE_MIN是写死的宏：400</p></li><li><p>table_open_cache</p><p>table_open_cache受到了max_connections的限制，至少需要连接数*该链接执行的join表的个数</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust_table_cache_size</span><span class="hljs-params">(ulong requested_open_files)</span></span><span class="hljs-function"></span>{  ulong limit;  limit= <span class="hljs-built_in">max</span>&lt;ulong&gt;((requested_open_files - <span class="hljs-number">10</span> - max_connections) / <span class="hljs-number">2</span>,                    TABLE_OPEN_CACHE_MIN);  <span class="hljs-keyword">if</span> (limit &lt; table_cache_size)  {    sql_print_warning(<span class="hljs-string">"Changed limits: table_open_cache: %lu (requested %lu)"</span>,                      limit, table_cache_size);    table_cache_size= limit;  }  table_cache_size_per_instance= table_cache_size / table_cache_instances;}</code></pre></li><li><p>table_definition_cache</p><p>table_definition_cache是能放在缓存中的表的定义的数量，表的定义在缓存中的时候能够加快打开表的速度，默认是400 + (table_open_cache / 2)</p><pre><code class="hljs c++">default_value= <span class="hljs-built_in">min</span>&lt;ulong&gt; (<span class="hljs-number">400</span> + table_cache_size / <span class="hljs-number">2</span>, <span class="hljs-number">2000</span>);  var= intern_find_sys_var(STRING_WITH_LEN(<span class="hljs-string">"table_definition_cache"</span>));  DBUG_ASSERT(var != <span class="hljs-literal">NULL</span>);  var-&gt;update_default(default_value);</code></pre></li></ul></li><li><p>对相关的配置进行生效</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (ho_error == <span class="hljs-number">0</span>)  {    <span class="hljs-keyword">if</span> (!opt_help &amp;&amp; !opt_bootstrap)    {      <span class="hljs-comment">/* Add sizing hints from the server sizing parameters. */</span>      pfs_param.m_hints.m_table_definition_cache= table_def_size;      pfs_param.m_hints.m_table_open_cache= table_cache_size;      pfs_param.m_hints.m_max_connections= max_connections;      pfs_param.m_hints.m_open_files_limit= requested_open_files;      pfs_param.m_hints.m_max_prepared_stmt_count= max_prepared_stmt_count;      PSI_hook= initialize_performance_schema(&amp;pfs_param);      <span class="hljs-keyword">if</span> (PSI_hook == <span class="hljs-literal">NULL</span> &amp;&amp; pfs_param.m_enabled)      {        pfs_param.m_enabled= <span class="hljs-literal">false</span>;        sql_print_warning(<span class="hljs-string">"Performance schema disabled (reason: init failed)."</span>);      }    }  }</code></pre></li></ol><h2 id="2-2HAVE-PSI-INTERFACE宏定义"><a href="#2-2HAVE-PSI-INTERFACE宏定义" class="headerlink" title="2.2HAVE_PSI_INTERFACE宏定义"></a>2.2<code>HAVE_PSI_INTERFACE</code>宏定义</h2><p>PSI代表：Performance schema instrumentation interface性能模式检测接口</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_PSI_INTERFACE</span>  <span class="hljs-comment">/*</span><span class="hljs-comment">    获取当前的性能模式检测接口，如果可供使用的话。</span><span class="hljs-comment">  */</span>  <span class="hljs-keyword">if</span> (PSI_hook)  {    PSI *psi_server= (PSI*) PSI_hook-&gt;get_interface(PSI_CURRENT_VERSION);    <span class="hljs-keyword">if</span> (likely(psi_server != <span class="hljs-literal">NULL</span>))    {      set_psi_server(psi_server);      <span class="hljs-comment">/*</span><span class="hljs-comment">        2.1解析了命令行参数，并且已经初始化了性能模式(performance schema instrument)，接下来注册所有服务器检测</span><span class="hljs-comment">      */</span>      init_server_psi_keys();      <span class="hljs-comment">/* 检测主要的线程 */</span>      PSI_thread *psi= PSI_THREAD_CALL(new_thread)(key_thread_main, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);      PSI_THREAD_CALL(set_thread_os_id)(psi);      PSI_THREAD_CALL(set_thread)(psi);      <span class="hljs-comment">/*</span><span class="hljs-comment">        一些检测已经到位,重新初始化在之前已经初始化的对象,以便更好的检测.</span><span class="hljs-comment">      */</span>      my_thread_global_reinit();    }  }<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* HAVE_PSI_INTERFACE */</span></span></code></pre><h2 id="2-3-query日志初始化"><a href="#2-3-query日志初始化" class="headerlink" title="2.3 query日志初始化"></a>2.3 query日志初始化</h2><pre><code class="hljs C++">init_error_log();  <span class="hljs-comment">/* Initialize audit interface globals. Audit plugins are inited later. */</span>  mysql_audit_initialize();<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> EMBEDDED_LIBRARY</span>  Srv_session::module_init();<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>  <span class="hljs-comment">/*</span><span class="hljs-comment">    执行基本查询日志初始化。 应该在MY_INIT之后调用，因为它会初始化互斥量。</span><span class="hljs-comment">  */</span>  query_logger.init();</code></pre><h2 id="2-4-如果错误则退出"><a href="#2-4-如果错误则退出" class="headerlink" title="2.4 如果错误则退出"></a>2.4 如果错误则退出</h2><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (ho_error){  <span class="hljs-comment">/*</span><span class="hljs-comment">   解析命令行选项失败，由于没有可行的剩下的_argc / remaining_argv来继续服务器初始化，因此代码已尽其所能。</span><span class="hljs-comment">     这是记录有意义消息的最大努力：</span><span class="hljs-comment">     -消息将打印到stderr，但尚未重定向，</span><span class="hljs-comment">     -对于Windows，消息将打印在NT事件日志中。</span><span class="hljs-comment">  */</span>  flush_error_log_messages();  <span class="hljs-comment">/*</span><span class="hljs-comment">    Not enough initializations for unireg_abort()</span><span class="hljs-comment">    Using exit() for windows.</span><span class="hljs-comment">  */</span>  <span class="hljs-built_in">exit</span> (MYSQLD_ABORT_EXIT);}<span class="hljs-keyword">if</span> (init_common_variables())  unireg_abort(MYSQLD_ABORT_EXIT);        <span class="hljs-comment">// 如果初始化失败就直接退出SQL</span>my_init_signals();</code></pre><h2 id="2-5-堆栈的大小初始化"><a href="#2-5-堆栈的大小初始化" class="headerlink" title="2.5 堆栈的大小初始化"></a>2.5 堆栈的大小初始化</h2><pre><code class="hljs C++">my_thread_attr_setstacksize(&amp;connection_attrib,                            my_thread_stack_size + guardize);  {    <span class="hljs-comment">/* Retrieve used stack size;  Needed for checking stack overflows */</span>    <span class="hljs-keyword">size_t</span> stack_size= <span class="hljs-number">0</span>;    my_thread_attr_getstacksize(&amp;connection_attrib, &amp;stack_size);    <span class="hljs-comment">/* We must check if stack_size = 0 as Solaris 2.9 can return 0 here */</span>    <span class="hljs-keyword">if</span> (stack_size &amp;&amp; stack_size &lt; (my_thread_stack_size + guardize))    {      sql_print_warning(<span class="hljs-string">"Asked for %lu thread stack, but got %ld"</span>,                        my_thread_stack_size + guardize, (<span class="hljs-keyword">long</span>) stack_size);<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(__ia64__) || defined(__ia64)</span>      my_thread_stack_size= stack_size / <span class="hljs-number">2</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>      my_thread_stack_size= <span class="hljs-keyword">static_cast</span>&lt;ulong&gt;(stack_size - guardize);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    }  }</code></pre><h2 id="2-6-开启binlog会检查server-id"><a href="#2-6-开启binlog会检查server-id" class="headerlink" title="2.6 开启binlog会检查server_id"></a>2.6 开启binlog会检查server_id</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> (opt_bin_log &amp;&amp; !(server_id_supplied) )  {    sql_print_error(<span class="hljs-string">"You have enabled the binary log, but you haven't provided "</span>                    <span class="hljs-string">"the mandatory server-id. Please refer to the proper "</span>                    <span class="hljs-string">"server start-up parameters documentation"</span>);    unireg_abort(MYSQLD_ABORT_EXIT);  }</code></pre><p>如果开启二进制日志但是没有提供操作服务器ID就会报错并退出</p><h2 id="2-7-服务器组件初始化"><a href="#2-7-服务器组件初始化" class="headerlink" title="2.7 服务器组件初始化"></a>2.7 服务器组件初始化</h2><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (init_server_components())    unireg_abort(MYSQLD_ABORT_EXIT);</code></pre><h2 id="2-8检查data目录下是否有auto-cnf"><a href="#2-8检查data目录下是否有auto-cnf" class="headerlink" title="2.8检查data目录下是否有auto.cnf"></a>2.8检查data目录下是否有auto.cnf</h2><pre><code class="hljs c++"><span class="hljs-comment">/*</span><span class="hljs-comment">  Each server should have one UUID. We will create it automatically, if it</span><span class="hljs-comment">  does not exist.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">if</span> (init_server_auto_options()){  sql_print_error(<span class="hljs-string">"Initialization of the server's UUID failed because it could"</span>                  <span class="hljs-string">" not be read from the auto.cnf file. If this is a new"</span>                  <span class="hljs-string">" server, the initialization failed because it was not"</span>                  <span class="hljs-string">" possible to generate a new UUID."</span>);  unireg_abort(MYSQLD_ABORT_EXIT);}</code></pre><h2 id="2-9将uuid加入sid-map-中"><a href="#2-9将uuid加入sid-map-中" class="headerlink" title="2.9将uuid加入sid_map()中"></a>2.9将uuid加入sid_map()中</h2><pre><code class="hljs c++"><span class="hljs-comment">/*</span><span class="hljs-comment">  Add server_uuid to the sid_map.  This must be done after</span><span class="hljs-comment">  server_uuid has been initialized in init_server_auto_options and</span><span class="hljs-comment">  after the binary log (and sid_map file) has been initialized in</span><span class="hljs-comment">  init_server_components().</span><span class="hljs-comment"></span><span class="hljs-comment">  No error message is needed: init_sid_map() prints a message.</span><span class="hljs-comment"></span><span class="hljs-comment">  Strictly speaking, this is not currently needed when</span><span class="hljs-comment">  opt_bin_log==0, since the variables that gtid_state-&gt;init</span><span class="hljs-comment">  initializes are not currently used in that case.  But we call it</span><span class="hljs-comment">  regardless to avoid possible future bugs if gtid_state ever</span><span class="hljs-comment">  needs to do anything else.</span><span class="hljs-comment">*/</span>global_sid_lock-&gt;wrlock();<span class="hljs-keyword">int</span> gtid_ret= gtid_state-&gt;init();global_sid_lock-&gt;unlock();<span class="hljs-keyword">if</span> (gtid_ret)  unireg_abort(MYSQLD_ABORT_EXIT);</code></pre><h2 id="2-10初始化gtid-state对象以及对应的操作"><a href="#2-10初始化gtid-state对象以及对应的操作" class="headerlink" title="2.10初始化gtid_state对象以及对应的操作"></a>2.10初始化gtid_state对象以及对应的操作</h2><pre><code class="hljs c++"><span class="hljs-comment">// Initialize executed_gtids from mysql.gtid_executed table.</span><span class="hljs-keyword">if</span> (gtid_state-&gt;read_gtid_executed_from_table() == <span class="hljs-number">-1</span>)  unireg_abort(<span class="hljs-number">1</span>);</code></pre><p>GTID (Global Transaction ID)是全局事务ID,当在主库上提交事务或者被从库应用时，可以定位和追踪每一个事务，对DBA来说意义就很大了，我们可以适当的解放出来，不用手工去可以找偏移量的值了，而是通过CHANGE MASTER TO MASTER_HOST=’xxx’, MASTER_AUTO_POSITION=1的即可方便的搭建从库，在故障修复中也可以采用MASTER_AUTO_POSITION=‘X’的方式。</p><p>在以下四种情况下，将未保存的GTID保存到gtid_exected表中：</p><ol><li>升级</li><li>从主服务器的备份中配置了一个从服务器，并且在此之前通过RESET MASTER和RESET SLAVE清除了从服务器。</li><li>在崩溃前从服务器上的最后一个RESET MASTER没有发生二进制日志轮换</li><li>如果服务器崩溃，则最后一个binlog的GTID集不会保存到gtid_exected表中，因此在从崩溃中恢复期间，我们将其保存到gtid_executed表和execute_gtids中。</li></ol><p>其中的代码我没有仔细研究</p><h2 id="2-11-网络连接"><a href="#2-11-网络连接" class="headerlink" title="2.11 网络连接"></a>2.11 网络连接</h2><ul><li><p>SSL支持与网络的初始化</p><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (init_ssl())  unireg_abort(MYSQLD_ABORT_EXIT);<span class="hljs-keyword">if</span> (network_init())  unireg_abort(MYSQLD_ABORT_EXIT);</code></pre><p>network_init主要做了以下几件事情：</p><blockquote><p><a href="https://blog.csdn.net/Martin201609/article/details/100747413" target="_blank" rel="noopener">https://blog.csdn.net/Martin201609/article/details/100747413</a></p></blockquote><p>set_ports() 进行相应的初始化端口,创建监听对象Mysqld_socket_listener，并对其进行相应的初始化操作。然后对listener进行相应的侦听动作</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">network_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> (opt_bootstrap)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  set_ports(); <span class="hljs-comment">//端口设置</span>  <span class="hljs-comment">//...</span> Mysqld_socket_listener *mysqld_socket_listener=      <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::nothrow) Mysqld_socket_listener(bind_addr_str,                                                mysqld_port, back_log,                                                mysqld_port_timeout,                                                unix_sock_name);}<span class="hljs-comment">//监听对象</span><span class="hljs-comment">// ...</span>mysqld_socket_acceptor=      <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::nothrow) Connection_acceptor&lt;Mysqld_socket_listener&gt;(mysqld_socket_listener);<span class="hljs-comment">//</span><span class="hljs-comment">//...</span>    <span class="hljs-keyword">if</span> (mysqld_socket_acceptor-&gt;init_connection_acceptor())<span class="hljs-comment">//实例化并监听</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// mysqld_socket_acceptor would be freed in unireg_abort.</span></code></pre><p><code>set_port()</code>:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set_ports</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">char</span>  *env;  <span class="hljs-keyword">if</span> (!mysqld_port &amp;&amp; !opt_disable_networking)  {         <span class="hljs-comment">// Get port if not from commandline</span>    mysqld_port= MYSQL_PORT;    <span class="hljs-comment">/*</span><span class="hljs-comment">      如果构建器明确要求使用默认端口，则使用该端口（即使它与默认值一致）。 只有在他们没有这样做的情况下，我们才检查/etc/services（如果失败，则退回到出厂默认值3306）。 这两个默认值都可以被环境变量MYSQL_TCP_PORT覆盖，而环境变量又可以由命令行选项覆盖。</span><span class="hljs-comment">    */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> MYSQL_PORT_DEFAULT == 0 <span class="hljs-comment">//这个参数是在make编译生成之后，在include/mysql_version.h生成，其值为 #define MYSQL_PORT_DEFAULT          @MYSQL_TCP_PORT_DEFAULT@</span></span><span class="hljs-comment">//MYSQL_TCP_PORT_DEFAULT这个值是在cmake/mysql_version.cmake的文件中配置的</span><span class="hljs-comment">/*</span><span class="hljs-comment">[root@pcserver mysql-5.7.27]# grep -rn "MYSQL_TCP_PORT_DEFAULT" *</span><span class="hljs-comment">cmake/mysql_version.cmake:88:SET(MYSQL_TCP_PORT_DEFAULT "3306")</span><span class="hljs-comment">cmake/mysql_version.cmake:91:  SET(MYSQL_TCP_PORT ${MYSQL_TCP_PORT_DEFAULT})</span><span class="hljs-comment">cmake/mysql_version.cmake:92:  SET(MYSQL_TCP_PORT_DEFAULT "0")</span><span class="hljs-comment">cmake/mysql_version.cmake:93:ELSEIF(MYSQL_TCP_PORT EQUAL MYSQL_TCP_PORT_DEFAULT)</span><span class="hljs-comment">cmake/mysql_version.cmake:94:  SET(MYSQL_TCP_PORT_DEFAULT "0")</span><span class="hljs-comment">include/mysql_version.h.in:18:#define MYSQL_PORT_DEFAULT          @MYSQL_TCP_PORT_DEFAULT@</span><span class="hljs-comment">scripts/mysql_config.pl.in:161:if ( '@MYSQL_TCP_PORT_DEFAULT@' == 0 ) {</span><span class="hljs-comment">scripts/mysql_config.sh:106:if [ @MYSQL_TCP_PORT_DEFAULT@ -eq 0 ]; then</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">servent</span> *<span class="hljs-title">serv_ptr</span>;</span>    <span class="hljs-keyword">if</span> ((serv_ptr= getservbyname(<span class="hljs-string">"mysql"</span>, <span class="hljs-string">"tcp"</span>)))      mysqld_port= ntohs((u_short) serv_ptr-&gt;s_port); <span class="hljs-comment">/* purecov: inspected */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-keyword">if</span> ((env = getenv(<span class="hljs-string">"MYSQL_TCP_PORT"</span>)))       mysqld_port= (uint) atoi(env);    <span class="hljs-comment">/* purecov: inspected 通过getenv获取启动配置命令行的端口*/</span>  }  <span class="hljs-keyword">if</span> (!mysqld_unix_port)  {<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32</span>    mysqld_unix_port= (<span class="hljs-keyword">char</span>*) MYSQL_NAMEDPIPE;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    mysqld_unix_port= (<span class="hljs-keyword">char</span>*) MYSQL_UNIX_ADDR;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-keyword">if</span> ((env = getenv(<span class="hljs-string">"MYSQL_UNIX_PORT"</span>)))      mysqld_unix_port= env;      <span class="hljs-comment">/* purecov: inspected */</span>  }}</code></pre><p>创建监听:</p><p>创建 Mysqld_socket_listener 类型对象</p><pre><code class="hljs c++">Mysqld_socket_listener *mysqld_socket_listener=      <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::nothrow) Mysqld_socket_listener(bind_addr_str,                                                mysqld_port, back_log,                                                mysqld_port_timeout,                                                unix_sock_name);</code></pre><p>通过Connection_acceptor模板进行Mysqld_socket_listener的初始化，通过循环监控不同类型的client connection event的，也就是通过循环监听客户端来的连接</p><p>创建mysql_socket_acceptor对象：</p><pre><code class="hljs c++">mysqld_socket_acceptor=      <span class="hljs-keyword">new</span> (<span class="hljs-built_in">std</span>::nothrow) Connection_acceptor&lt;Mysqld_socket_listener&gt;(mysqld_socket_listener);</code></pre><p>初始化listener：</p><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (mysqld_socket_acceptor-&gt;init_connection_acceptor())     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// mysqld_socket_acceptor would be freed in unireg_abort.</span></code></pre><p>查看Mysqld_socket_listener中的setup_listener()具体的实现：<br>通过以下关键变量来记录listener的主要信息<br><strong>m_tcp_port</strong>:记录tcp socket连接<br><strong>m_unix_sockname</strong>: 使用的是std::string类型记录如果使用socket文件，则文件名（路径+文件）<br>通过使用m_socket_map来区分所使用的连接是tcp_socket还是unix socket的连接方式</p><p>通过两个if判断，分别判断是否tcp还是socket文件连接，并记录于m_socket_map中然后通过迭代器循环实现监听事件的记录，代码通过pool_info_t实现监听相应的事件</p></li><li><p>UDP初始化</p><pre><code class="hljs C++">udf_init();</code></pre></li><li><p>slave初始化</p></li></ul><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (server_id != <span class="hljs-number">0</span>)      init_slave(); <span class="hljs-comment">/* Ignoring errors while configuring replication. */</span></code></pre><h2 id="2-12-初始化线程"><a href="#2-12-初始化线程" class="headerlink" title="2.12 初始化线程"></a>2.12 初始化线程</h2><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32</span>  create_shutdown_thread();<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>  start_handle_manager();  create_compress_gtid_table_thread();  sql_print_information(ER_DEFAULT(ER_STARTUP),                        my_progname,                        server_version,#ifdef HAVE_SYS_UN_H                        (opt_bootstrap ? (<span class="hljs-keyword">char</span>*) <span class="hljs-string">""</span> : mysqld_unix_port),#<span class="hljs-keyword">else</span>                        (<span class="hljs-keyword">char</span>*) <span class="hljs-string">""</span>,#endif                         mysqld_port,                         MYSQL_COMPILATION_COMMENT);<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_WIN32)</span>  Service.SetRunning();<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>start_processing_signals();</code></pre><h2 id="2-13循环监听客户端"><a href="#2-13循环监听客户端" class="headerlink" title="2.13循环监听客户端"></a>2.13循环监听客户端</h2><p><strong>此处循环监听客户端,直到客户端选择退出再进行后续的操作,所以此函数一般情况是SQL的耗时最多,执行代码最多的地方,也是mysql的核心算法的代码</strong></p><p>此时要分为两种系统讨论:windows和Linux</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> defined(_WIN32)</span>  setup_conn_event_handler_threads();<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>  mysql_mutex_lock(&amp;LOCK_socket_listener_active);  <span class="hljs-comment">// Make it possible for the signal handler to kill the listener.</span>  socket_listener_active= <span class="hljs-literal">true</span>;  mysql_mutex_unlock(&amp;LOCK_socket_listener_active);  <span class="hljs-keyword">if</span> (opt_daemonize)    mysqld::runtime::signal_parent(pipe_write_fd,<span class="hljs-number">1</span>);  mysqld_socket_acceptor-&gt;connection_event_loop();<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* _WIN32 */</span></span></code></pre><h3 id="2-13-1-linux系统"><a href="#2-13-1-linux系统" class="headerlink" title="2.13.1 linux系统"></a>2.13.1 linux系统</h3><pre><code class="hljs c++">mysql_mutex_lock(&amp;LOCK_socket_listener_active);<span class="hljs-comment">// Make it possible for the signal handler to kill the listener.</span>socket_listener_active= <span class="hljs-literal">true</span>;<span class="hljs-comment">//从这里开始，服务器启动线程一直等待，直到shutdown后，继续向下执行</span>mysql_mutex_unlock(&amp;LOCK_socket_listener_active);<span class="hljs-keyword">if</span> (opt_daemonize)  mysqld::runtime::signal_parent(pipe_write_fd,<span class="hljs-number">1</span>);mysqld_socket_acceptor-&gt;connection_event_loop();</code></pre><p>通过nysqld_socket_acceptor变量引用connect_event_loop()方法，循环监听客户端来的连接。通过模板调用如下 ：</p><pre><code class="hljs c++"><span class="hljs-comment">/**</span><span class="hljs-comment">    Connection acceptor loop to accept connections from clients.</span><span class="hljs-comment">  */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connection_event_loop</span><span class="hljs-params">()</span></span><span class="hljs-function">  </span>{    Connection_handler_manager *mgr= Connection_handler_manager::get_instance();    <span class="hljs-keyword">while</span> (!abort_loop)    {      Channel_info *channel_info= m_listener-&gt;listen_for_connection_event();      <span class="hljs-keyword">if</span> (channel_info != <span class="hljs-literal">NULL</span>)        mgr-&gt;process_new_connection(channel_info);    }  }</code></pre><p>通过查看Mysqld_socket_listener类中listen_for_connection_event()来得到Channel_info信息，然后通过process_new_connection创建新的连接来。再进一步查看Connection_handler_manager的process_new_connection的方法，发现有m_connection_handler-&gt;add_connection(channel_info)在connection_handler中增加一个connection,并记录数量增加:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Connection_handler_manager::process_new_connection</span><span class="hljs-params">(Channel_info* channel_info)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">if</span> (abort_loop || !check_and_incr_conn_count())  {    channel_info-&gt;send_error_and_close_channel(ER_CON_COUNT_ERROR, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);    <span class="hljs-keyword">delete</span> channel_info;    <span class="hljs-keyword">return</span>;  }  <span class="hljs-keyword">if</span> (m_connection_handler-&gt;add_connection(channel_info)) <span class="hljs-comment">//增加一个connection</span>  {    inc_aborted_connects(); <span class="hljs-comment">//记录数量增加</span>    <span class="hljs-keyword">delete</span> channel_info;  }}</code></pre><p>对于m_connection_handler的add_connection增加connection，看具体的实现：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Per_thread_connection_handler::add_connection</span><span class="hljs-params">(Channel_info* channel_info)</span></span><span class="hljs-function"></span>{  <span class="hljs-keyword">int</span> error= <span class="hljs-number">0</span>;  my_thread_handle id;  DBUG_ENTER(<span class="hljs-string">"Per_thread_connection_handler::add_connection"</span>);  <span class="hljs-comment">// Simulate thread creation for test case before we check thread cache</span>  DBUG_EXECUTE_IF(<span class="hljs-string">"fail_thread_create"</span>, error= <span class="hljs-number">1</span>; <span class="hljs-keyword">goto</span> handle_error;);  <span class="hljs-keyword">if</span> (!check_idle_thread_and_enqueue_connection(channel_info))    DBUG_RETURN(<span class="hljs-literal">false</span>);  <span class="hljs-comment">/*</span><span class="hljs-comment">    There are no idle threads avaliable to take up the new</span><span class="hljs-comment">    connection. Create a new thread to handle the connection</span><span class="hljs-comment">  */</span>  channel_info-&gt;set_prior_thr_create_utime();  error= mysql_thread_create(key_thread_one_connection, &amp;id,                             &amp;connection_attrib,                             handle_connection,                             (<span class="hljs-keyword">void</span>*) channel_info);<span class="hljs-comment">//给定信息，创建thread进程</span>                             <span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DBUG_OFF</span>handle_error:<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// !DBUG_OFF</span></span>  <span class="hljs-keyword">if</span> (error)  {    connection_errors_internal++;    <span class="hljs-keyword">if</span> (!create_thd_err_log_throttle.<span class="hljs-built_in">log</span>())      sql_print_error(<span class="hljs-string">"Can't create thread to handle new connection(errno= %d)"</span>,                      error);    channel_info-&gt;send_error_and_close_channel(ER_CANT_CREATE_THREAD,                                               error, <span class="hljs-literal">true</span>);    Connection_handler_manager::dec_connection_count();    DBUG_RETURN(<span class="hljs-literal">true</span>);  }  Global_THD_manager::get_instance()-&gt;inc_thread_created();  DBUG_PRINT(<span class="hljs-string">"info"</span>,(<span class="hljs-string">"Thread created"</span>));  DBUG_RETURN(<span class="hljs-literal">false</span>);}</code></pre><p>创建mysql_thread_create创建thread，并接收一个方法参数 handle_connection，这个是一个函数:</p><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">handle_connection</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><span class="hljs-function"></span>{<span class="hljs-comment">//...</span> THD *thd= init_new_thd(channel_info); <span class="hljs-comment">//创建线程对象</span> <span class="hljs-comment">//...</span>mysql_thread_set_psi_id(thd-&gt;thread_id()); <span class="hljs-comment">//初始化线程信息等</span>    mysql_thread_set_psi_THD(thd);    mysql_socket_set_thread_owner(      thd-&gt;get_protocol_classic()-&gt;get_vio()-&gt;mysql_socket);    thd_manager-&gt;add_thd(thd);<span class="hljs-comment">//向线程管理器增加一个线程信息</span>    <span class="hljs-keyword">if</span> (thd_prepare_connection(thd))      handler_manager-&gt;inc_aborted_connects();    <span class="hljs-keyword">else</span>    {      <span class="hljs-keyword">while</span> (thd_connection_alive(thd))<span class="hljs-comment">//循环检测线程状态</span>      {        <span class="hljs-keyword">if</span> (do_command(thd)) <span class="hljs-comment">// 执行相关参数命令</span>          <span class="hljs-keyword">break</span>;      }      end_connection(thd);    }    close_connection(thd, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);    thd-&gt;get_stmt_da()-&gt;reset_diagnostics_area();    thd-&gt;release_resources();<span class="hljs-comment">//...</span>}</code></pre><blockquote><p><a href="https://www.itread01.com/content/1546137727.html" target="_blank" rel="noopener">https://www.itread01.com/content/1546137727.html</a></p></blockquote><p>在handle_connection中,通过while回圈呼叫sql_parse.cc中的do_command()，回圈的作用是从使用者输入的多个命令中依次选择一个命令去执行.在do_command()中，呼叫Protocol_classic::get_command()，进入Protocol_classic::parse_packet()读取一个数据包，解析为command命令,command命令有COM_QUERY、 COM_FIELD_LIST、COM_STMT_EXECUTE等。在在do_command()中继续呼叫sql_parse()档案中的dispatch_command().在dispatch_command()中包含了各种型别的command怎么处理的switch case。比如select的进入case COM_QUERY.先alloc_query()复制执行绪执行绪过来的查询命令。再进入sql_parse.cc档案中的mysql_parse()方法,开始sql语法解析.</p><p><strong>sql语法解析阶段</strong>:</p><ul><li>在mysql_parse()中,主要完成三个工作。检查查询快取里是否有以前执行过的某个查询。呼叫词法解析器(通过parse_sql()方法)，呼叫查询优化器(通过mysql_execute_command()方法).</li><li>依次进入sql_parse.cc中的parse_sql(),进入sql_class.cc中的THD::sql_parser() ,进入MYSQLparse().MYSQLparse是个巨集定义,为#define yyparse MYSQLparse.这时进入yacc的sql_yacc.cc档案中的语法解析器函式yyparse()开始语法解析.解析器基于sql_yacc.yy档案通过yacc生成.Mysql的词法解析器没有用flex,自己编写的。语法解析器用的Bison.</li><li>在mysql_parse()中继续呼叫sql_parse()档案中的mysql_execute_command()方法,为sql优化做准备.在该方法中,通过switch case为各种sql命令优化做准备.如果是select查询，进入case SQLCOM_SELECT，进入Sql_cmd_dml::execute()方法.在execute()方法中,先呼叫precheck()查询是否有许可权，然后呼叫open_tables_for_query()开启要查询的表，然后呼叫lock_tables()锁定相关的表，然后呼叫Sql_cmd_dml::execute_inner(),进入真正的查询优化.</li></ul><p><strong>sql查询优化阶段</strong>:</p><ul><li>在Sql_cmd_dml::execute_inner()方法中，先进入sql_optimizer.cc档案中的JOIN::optimize(),再进入sql_executor.cc档案中的JOIN::exec()开始查询执行器。</li></ul><p><strong>sql查询执行器</strong>:</p><ul><li>在sql_executor.cc档案中的JOIN::exec()中.先呼叫send_result_set_metadata()生成查询标题，再进入sql_executor.cc中的do_select()生成查询结果.在do_select()中呼叫sub_select ().在sub_select()中，先判断是否是最后一条记录.然后while回圈每次读取一条记录。</li></ul><p><strong>sql查询优化阶段</strong>:</p><ul><li>在Sql_cmd_dml::execute_inner()方法中，先进入sql_optimizer.cc档案中的JOIN::optimize(),再进入sql_executor.cc档案中的JOIN::exec()开始查询执行器。</li></ul><p><strong>sql查询执行器</strong>:</p><ul><li>在sql_executor.cc档案中的JOIN::exec()中.先呼叫send_result_set_metadata()生成查询标题，再进入sql_executor.cc中的do_select()生成查询结果.在do_select()中呼叫sub_select ().在sub_select()中，先判断是否是最后一条记录.然后while回圈每次读取一条记录。</li></ul><h3 id="2-13-2-windows系统"><a href="#2-13-2-windows系统" class="headerlink" title="2.13.2 windows系统"></a>2.13.2 windows系统</h3><p>调用函数<code>setup_conn_event_handler_threads();</code>,此时创建监听线程,启动三个单独线程处理不同的连接方式，即Mysqld_socket_listener/Named_pipe_listener/Shared_mem_listener,函数执行了的操作如下:</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup_conn_event_handler_threads</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>{  my_thread_handle hThread;  <span class="hljs-comment">//...</span>      <span class="hljs-comment">//互斥锁</span>  mysql_mutex_lock(&amp;LOCK_handler_count);  handler_count=<span class="hljs-number">0</span>;    <span class="hljs-comment">//类似于上面Linux的`对于m_connection_handler的add_connection增加connection`</span>  <span class="hljs-keyword">if</span> (opt_enable_named_pipe)  {    <span class="hljs-keyword">int</span> error= mysql_thread_create(key_thread_handle_con_namedpipes,                                   &amp;hThread, &amp;connection_attrib,                                   named_pipe_conn_event_handler,                                   named_pipe_acceptor);    <span class="hljs-keyword">if</span> (!error)      handler_count++;    <span class="hljs-keyword">else</span>      sql_print_warning(<span class="hljs-string">"Can't create thread to handle named pipes"</span>                        <span class="hljs-string">" (errno= %d)"</span>, error);  }  <span class="hljs-keyword">if</span> (have_tcpip &amp;&amp; !opt_disable_networking)  {    <span class="hljs-keyword">int</span> error= mysql_thread_create(key_thread_handle_con_sockets,                                   &amp;hThread, &amp;connection_attrib,                                   socket_conn_event_handler,                                   mysqld_socket_acceptor);    <span class="hljs-keyword">if</span> (!error)      handler_count++;    <span class="hljs-keyword">else</span>      sql_print_warning(<span class="hljs-string">"Can't create thread to handle TCP/IP (errno= %d)"</span>,                        error);  }  <span class="hljs-keyword">if</span> (opt_enable_shared_memory)  {    <span class="hljs-keyword">int</span> error= mysql_thread_create(key_thread_handle_con_sharedmem,                                   &amp;hThread, &amp;connection_attrib,                                   shared_mem_conn_event_handler,                                   shared_mem_acceptor);    <span class="hljs-keyword">if</span> (!error)      handler_count++;    <span class="hljs-keyword">else</span>      sql_print_warning(<span class="hljs-string">"Can't create thread to handle shared memory"</span>                        <span class="hljs-string">" (errno= %d)"</span>, error);  }  <span class="hljs-comment">// Block until all connection listener threads have exited.</span>  <span class="hljs-keyword">while</span> (handler_count &gt; <span class="hljs-number">0</span>)    mysql_cond_wait(&amp;COND_handler_count, &amp;LOCK_handler_count);  mysql_mutex_unlock(&amp;LOCK_handler_count);  DBUG_VOID_RETURN;}</code></pre><p>拿第一个<code>opt_enable_named_pipe</code>为例,调用了’死’循环函数<code>named_pipe_conn_event_handler</code>:</p><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">named_pipe_conn_event_handler</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><span class="hljs-function"></span>{  my_thread_init();  Connection_acceptor&lt;Named_pipe_listener&gt; *conn_acceptor=    <span class="hljs-keyword">static_cast</span>&lt;Connection_acceptor&lt;Named_pipe_listener&gt;*&gt;(arg);  conn_acceptor-&gt;connection_event_loop();  decrement_handler_count();  my_thread_end();  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p>和Linux分析一样,<code>conn_acceptor-&gt;connection_event_loop();</code>进行’通过nysqld_socket_acceptor变量引用connect_event_loop()方法，循环监听客户端来的连接’,接着就回到了Linux的分析</p><h2 id="2-14-后续的结束收尾工作"><a href="#2-14-后续的结束收尾工作" class="headerlink" title="2.14 后续的结束收尾工作"></a>2.14 后续的结束收尾工作</h2><p>略</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>本次源码的分析主要是针对main函数的分析,初步了解了main函数的工作流程,后续将会主要针对Innodb引擎进行分析</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql5.7+vs安装源码调试环境</title>
    <link href="/2020/07/03/mysql5-7-vs-an-zhuang-yuan-ma-diao-shi-huan-jing/"/>
    <url>/2020/07/03/mysql5-7-vs-an-zhuang-yuan-ma-diao-shi-huan-jing/</url>
    
    <content type="html"><![CDATA[<h1 id="1-源码以及软件下载"><a href="#1-源码以及软件下载" class="headerlink" title="1. 源码以及软件下载"></a>1. 源码以及软件下载</h1><ol><li>Visual Code community 2019</li><li>MySQL源码5.7.19</li><li>与MySQL5.7.19配套的boost_1_59_0-msvc-14.0-64</li><li>ActivePerl-5.28</li><li>cmake-3.18.0</li></ol><h1 id="2-源码的编译"><a href="#2-源码的编译" class="headerlink" title="2. 源码的编译"></a>2. 源码的编译</h1><p><img src="image-20200626142031305.png" srcset="/img/loading.gif" alt="源码的编译"></p><h1 id="3-VS编译遇到的报错问题"><a href="#3-VS编译遇到的报错问题" class="headerlink" title="3. VS编译遇到的报错问题"></a>3. VS编译遇到的报错问题</h1><h2 id="3-1-Call-Stack-most-recent-call-first-cmake-boost-cmake-238-COULD-NOT-FIND-BOOST-CMakeList"><a href="#3-1-Call-Stack-most-recent-call-first-cmake-boost-cmake-238-COULD-NOT-FIND-BOOST-CMakeList" class="headerlink" title="3.1 Call Stack (most recent call first): cmake/boost.cmake:238 (COULD_NOT_FIND_BOOST) CMakeList"></a>3.1 Call Stack (most recent call first): cmake/boost.cmake:238 (COULD_NOT_FIND_BOOST) CMakeList</h2><p>boost的版本不对,改为boost_1_59_0就成功编译</p><h2 id="3-2-“对COM-组件的调用返回了错误-HRESULT-E-FAIL”无法加载项目"><a href="#3-2-“对COM-组件的调用返回了错误-HRESULT-E-FAIL”无法加载项目" class="headerlink" title="3.2 “对COM 组件的调用返回了错误 HRESULT E_FAIL”无法加载项目"></a>3.2 “对COM 组件的调用返回了错误 HRESULT E_FAIL”无法加载项目</h2><ol><li><p><img src="20200607002041265.png" srcset="/img/loading.gif" alt="1"></p></li><li><p><img src="20200607002123675.png" srcset="/img/loading.gif" alt="2"></p></li><li><p><img src="20200607002217417.png" srcset="/img/loading.gif" alt="3"></p></li></ol><h2 id="3-3-“该文件包含不能在当前代码页-936-中表示的字符。请将该文件保存为-Unicode-格式以防止数据丢失”"><a href="#3-3-“该文件包含不能在当前代码页-936-中表示的字符。请将该文件保存为-Unicode-格式以防止数据丢失”" class="headerlink" title="3.3 “该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失”"></a>3.3 “该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失”</h2><p><a href="https://www.cnblogs.com/leokale-zz/p/11423953.html" target="_blank" rel="noopener">https://www.cnblogs.com/leokale-zz/p/11423953.html</a></p><h2 id="3-4-运行报错"><a href="#3-4-运行报错" class="headerlink" title="3.4 运行报错"></a>3.4 运行报错</h2><p>mysql.cc 文件中函数test_lc_time_sz 最后的DBUG_ASSERT(0); 需要改成DBUG_ASSERT(1);</p><h2 id="3-5-编译成功后运行：mysqld-Could-not-create-or-access-the-registry-key-needed-for-the-MySQL-app"><a href="#3-5-编译成功后运行：mysqld-Could-not-create-or-access-the-registry-key-needed-for-the-MySQL-app" class="headerlink" title="3.5 编译成功后运行：mysqld: Could not create or access the registry key needed for the MySQL app"></a>3.5 编译成功后运行：mysqld: Could not create or access the registry key needed for the MySQL app</h2><p>以管理员方式进行运行程序</p><p><a href="https://blog.csdn.net/zeqi1991/article/details/96195127" target="_blank" rel="noopener">https://blog.csdn.net/zeqi1991/article/details/96195127</a></p><h2 id="3-6-运行报错Table-‘mysql-plugin’-doesn’t-exist"><a href="#3-6-运行报错Table-‘mysql-plugin’-doesn’t-exist" class="headerlink" title="3.6 运行报错Table ‘mysql.plugin’ doesn’t exist"></a>3.6 运行报错Table ‘mysql.plugin’ doesn’t exist</h2><ol><li><p>删除data的文件夹内的所有的内容</p></li><li><p>sql \Debug \ .\mysqld —initialize</p><p><img src="image-20200627012830324.png" srcset="/img/loading.gif" alt="sql \Debug \ .\mysqld --initialize"></p></li></ol><h1 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h1><p><img src="image-20200626150116025.png" srcset="/img/loading.gif" alt="结果"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manim学习--camera类(一)</title>
    <link href="/2020/07/02/manim-xue-xi-camera-lei/"/>
    <url>/2020/07/02/manim-xue-xi-camera-lei/</url>
    
    <content type="html"><![CDATA[<h2 id="1-camera的所有子类以及相关的类"><a href="#1-camera的所有子类以及相关的类" class="headerlink" title="1. camera的所有子类以及相关的类"></a>1. camera的所有子类以及相关的类</h2><p><img src="Camera.png" srcset="/img/loading.gif" alt="Camera"></p><h2 id="2-camera主要的变量与属性"><a href="#2-camera主要的变量与属性" class="headerlink" title="2. camera主要的变量与属性"></a>2. camera主要的变量与属性</h2><h3 id="2-1-CONFIG"><a href="#2-1-CONFIG" class="headerlink" title="2.1 CONFIG"></a>2.1 CONFIG</h3><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"background_image"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"pixel_height"</span>: DEFAULT_PIXEL_HEIGHT,        <span class="hljs-string">"pixel_width"</span>: DEFAULT_PIXEL_WIDTH,        <span class="hljs-string">"frame_rate"</span>: DEFAULT_FRAME_RATE,        <span class="hljs-comment"># Note: 帧的高度和宽度将被调整大小以匹配像素长宽比</span>    <span class="hljs-comment"># 这个在constant.py中可以看到：</span>    <span class="hljs-comment"># FRAME_WIDTH = FRAME_HEIGHT * DEFAULT_PIXEL_WIDTH / DEFAULT_PIXEL_HEIGHT</span>        <span class="hljs-string">"frame_height"</span>: FRAME_HEIGHT,        <span class="hljs-string">"frame_width"</span>: FRAME_WIDTH,        <span class="hljs-string">"frame_center"</span>: ORIGIN,        <span class="hljs-string">"background_color"</span>: BLACK,        <span class="hljs-string">"background_opacity"</span>: <span class="hljs-number">1</span>,        <span class="hljs-comment"># vectorized mobjects的点在大于下面的范围时候会缩小</span>        <span class="hljs-string">"max_allowable_norm"</span>: FRAME_WIDTH,    <span class="hljs-comment"># 图像的模式，此处默认是RGBA，参见数字图像处理</span>        <span class="hljs-string">"image_mode"</span>: <span class="hljs-string">"RGBA"</span>,    <span class="hljs-comment"># 图像通道，参见数字图像处理</span>        <span class="hljs-string">"n_channels"</span>: <span class="hljs-number">4</span>,        <span class="hljs-string">"pixel_array_dtype"</span>: <span class="hljs-string">'uint8'</span>,        <span class="hljs-comment"># z_buff_func is only used if the flag above is set to True.</span>        <span class="hljs-comment"># 比较时将z坐标舍入到最接近的百分之一</span>        <span class="hljs-string">"z_buff_func"</span>: <span class="hljs-keyword">lambda</span> m: np.round(m.get_center()[<span class="hljs-number">2</span>], <span class="hljs-number">2</span>),        <span class="hljs-string">"cairo_line_width_multiple"</span>: <span class="hljs-number">0.01</span>,    }</code></pre><h3 id="2-2-init-函数"><a href="#2-2-init-函数" class="headerlink" title="2.2__init__()函数"></a>2.2<code>__init__()</code>函数</h3><ul><li><p><code>rgb_max_val</code>RGB色彩的取值的最大值，默认的<code>uint8</code>取值最大值是255</p></li><li><p><code>pixel_array_to_cairo_context</code>将像素变成cairo能处理的形式</p></li></ul><h2 id="3-camera的主要方法"><a href="#3-camera的主要方法" class="headerlink" title="3. camera的主要方法"></a>3. camera的主要方法</h2><ol><li><p><code>reset_pixel_shape(new_height, new_width)</code>设置帧的像素宽与高</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test_pixel</span><span class="hljs-params">(ThreeDScene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        axes = ThreeDAxes()        cube = Cube(fill_color=GREEN).scale([<span class="hljs-number">2</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])        theta_0 = <span class="hljs-number">0</span> <span class="hljs-comment"># 起始角度</span>        theta =  <span class="hljs-number">-120</span> * DEGREES <span class="hljs-comment"># 目标角度</span>        self.set_camera(ThreeDCamera(background_color=BLUE))        self.camera.reset_pixel_shape(<span class="hljs-number">854</span>,<span class="hljs-number">854</span>)        self.set_camera_orientation(<span class="hljs-number">60</span> * DEGREES, theta=theta_0)        self.add(axes, cube)        self.wait()        dt = <span class="hljs-number">1</span>/<span class="hljs-number">15</span>        delta_theta = (theta - theta_0) / <span class="hljs-number">60</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">60</span>):            theta_0 += delta_theta            self.set_camera_orientation(theta=theta_0)            self.wait(dt)        self.wait(<span class="hljs-number">2</span>)</code></pre><p>上面代码设置宽高为854*854，最后就会产生大小为854*854的视频：</p><p><img src="Test_pixel.gif" srcset="/img/loading.gif" alt="Test_pixel"></p></li><li><p>一些get,set函数：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pixel_height</span><span class="hljs-params">(self)</span>:</span>    <span class="hljs-keyword">return</span> self.pixel_height   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_pixel_width</span><span class="hljs-params">(self)</span>:</span>    <span class="hljs-keyword">return</span> self.pixel_width   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_frame_height</span><span class="hljs-params">(self)</span>:</span>    <span class="hljs-keyword">return</span> self.frame_height   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_frame_width</span><span class="hljs-params">(self)</span>:</span>    <span class="hljs-keyword">return</span> self.frame_width   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_frame_center</span><span class="hljs-params">(self)</span>:</span>    <span class="hljs-keyword">return</span> self.frame_center   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_frame_height</span><span class="hljs-params">(self, frame_height)</span>:</span>    self.frame_height = frame_height   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_frame_width</span><span class="hljs-params">(self, frame_width)</span>:</span>    self.frame_width = frame_width   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_frame_center</span><span class="hljs-params">(self, frame_center)</span>:</span>    self.frame_center = frame_center</code></pre><p>frame和pixel的区别是：一个是将帧分为多少格，一个是将帧的大小设置为多少，前者仅仅会改变坐标的间隔，后者会改变视频的宽高</p><p>原始的默认为frame_width=14，frame_height=8：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Set_frame1</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        numberplane = NumberPlane()        numberplane.add_coordinates()        text = Text(<span class="hljs-string">"frame_width=14\nframe_height=8"</span>).shift(LEFT*<span class="hljs-number">5</span>+UP*<span class="hljs-number">3</span>)        self.add(numberplane,text)        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="set_frame14.png" srcset="/img/loading.gif" alt="set_frame14"></p><p>重新设置frame_width:</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Set_frame1</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        numberplane = NumberPlane()        numberplane.add_coordinates()        self.camera.set_frame_width(<span class="hljs-number">8</span>)        text = Text(<span class="hljs-string">"frame_width=8\nframe_height=8"</span>).shift(UP*<span class="hljs-number">3</span>)        self.add(numberplane,text)        self.wait(<span class="hljs-number">2</span>)</code></pre><p>可以看到宽也被拉长了：</p><p><img src="set_frame8.png" srcset="/img/loading.gif" alt="set_frame8"></p></li><li><p><code>resize_frame_shape(fixed_dimension=0)</code>:</p><p>更改frame_shape以匹配像素的长宽比，其中fixed_dimension确定frame_height或frame_width是否保持固定，而其他值则相应改变。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Set_frame1</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        numberplane = NumberPlane()        numberplane.add_coordinates()        self.camera.set_frame_width(<span class="hljs-number">8</span>)        self.camera.resize_frame_shape()        text = Text(<span class="hljs-string">"frame_width=8"</span>)        self.add(numberplane,text)        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="resize_frame_shape.png" srcset="/img/loading.gif" alt="resize_frame_shape"></p></li><li><p><code>get_image(pixel_array=None)</code></p><p>返回<code>pixel_array</code>对应的Image类型的对象，如果<code>pixel_array</code>为空,则返回自身的<code>pixel_array</code>对应的Image图像,此函数一般不用</p></li><li><p><code>get_pixel_array()</code></p><p>返回自身的<code>pixel_array</code></p></li><li><p><code>convert_pixel_array(pixel_array, convert_from_floats=False)</code></p><p>将格式为<code>PIL</code> 的<code>pixel_array</code>图片转换为<code>np.array</code>的格式</p><p>其中<code>pixel_array</code>的形式可能有两种,第一种是RGB的格式进行表示,第二种是被归一化到[0,1]的小数形式,此时需要启用<code>convert_from_floats=True</code></p></li><li><p><code>set_pixel_array(pixel_array, convert_from_floats=False)</code></p><p>设置camera的<code>pixel_array</code>为参数中的pixel_array,对应的选项同理于`convert_pixel_array</p></li><li><p><code>set_background(pixel_array, convert_from_floats=False)</code></p><p>设置背景(本人没有成功尝试出来换背景图片不知道出了什么问题,代码如下)</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Set_background</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        image = Image.open(<span class="hljs-string">r"XXX.png"</span>)        self.camera.set_background(image)        <span class="hljs-comment"># self.camera.init_background()</span>        numberplane = NumberPlane()        numberplane.add_coordinates()        self.add(numberplane)        self.wait(<span class="hljs-number">2</span>)</code></pre><p>上面就是随便加了个物体,不知道为什么出现这个问题</p></li><li><p><code>make_background_from_func(coords_to_colors_func)</code></p><p>另一个函数是<code>set_background_from_func(coords_to_colors_func)</code>功能一样</p><p>使用coords_to_colors_func设置背景以确定每个像素的颜色。 coords_to_colors_func的每个输入在空间中都是（x，y）对（在frame对应的普通空间坐标,不是像素坐标），并且每个输出应为4个浮点数的RGBA数组。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coords_to_colors_func</span><span class="hljs-params">(point)</span>:</span>    <span class="hljs-keyword">return</span> (int)(<span class="hljs-number">255</span>*(point[<span class="hljs-number">0</span>]+<span class="hljs-number">7</span>)/<span class="hljs-number">17</span>),(int)(<span class="hljs-number">255</span>*(point[<span class="hljs-number">1</span>]+<span class="hljs-number">4</span>)/<span class="hljs-number">8</span>),(int)(<span class="hljs-number">255</span>*(point[<span class="hljs-number">0</span>]+<span class="hljs-number">11</span>)/<span class="hljs-number">22</span>),<span class="hljs-number">1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Set_bacground_func</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        self.camera.set_background_from_func(coords_to_colors_func)        square = Square()        self.add(square)        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="set_background_func.jpg" srcset="/img/loading.gif" alt="set_background_func"></p></li><li><p><code>reset()</code></p><p>重设背景</p></li><li><p><code>get_mobjects_to_display()</code></p><p>得到要展示的mobject</p></li><li><p><code>is_in_frame(mobject)</code></p><p>判断mobject是否在frame里面</p></li><li><p><code>points_to_pixel_coords(mobject, points)</code></p><p>将普通坐标,转换为像素坐标</p></li></ol><p>其他的函数本人也没有很理解,而且涉及到cairo库的学习,个人觉得没有必要深入了解其他的函数,因为有的函数3b1b仅仅是用来子类实现或者根本没有用过,如果需要请自行阅读源码</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本次学习camera很多函数偏于底层,我们平时绘制的时候应该用不上,camera的很多关于背景(background)的函数感觉很多都难以使用或者有各种bug(不知道是不是我自己不会用的原因),如果有人发现错误欢迎评论留言<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>manim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>manim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex入门</title>
    <link href="/2020/07/01/latex-ru-men/"/>
    <url>/2020/07/01/latex-ru-men/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Latex框架和总体设置"><a href="#1-Latex框架和总体设置" class="headerlink" title="1. Latex框架和总体设置"></a>1. Latex框架和总体设置</h1><h2 id="1-1-框架"><a href="#1-1-框架" class="headerlink" title="1.1 框架"></a>1.1 框架</h2><pre><code class="hljs latex">\documentclass[UTF8,a4paper,12pt]{ctexart}\title{LaTeX入门教程}\date{} %不显示时间\begin{document}  \maketitle  中文内容\end{document}</code></pre><h1 id="1-2-标题-section"><a href="#1-2-标题-section" class="headerlink" title="1.2 标题 section"></a>1.2 标题 section</h1><h3 id="1-2-1-一级标题"><a href="#1-2-1-一级标题" class="headerlink" title="1.2.1 一级标题"></a>1.2.1 一级标题</h3><pre><code class="hljs latex">\section{一级标题}  % 有序号\section*{一级标题} % 无序号</code></pre><h3 id="1-2-2-二级标题"><a href="#1-2-2-二级标题" class="headerlink" title="1.2.2 二级标题"></a>1.2.2 二级标题</h3><pre><code class="hljs latex">\subsection{二级标题}  % 有序号\subsection*{二级标题} % 无序号</code></pre><h3 id="1-2-3-标题label"><a href="#1-2-3-标题label" class="headerlink" title="1.2.3 标题label"></a>1.2.3 标题label</h3><pre><code class="hljs latex">\section{System} % 章节标题\label{sec:system} %标题的标签\ref{sec:conclusions} %在正文中引用这个标题名</code></pre><h2 id="1-3-标题形式"><a href="#1-3-标题形式" class="headerlink" title="1.3 标题形式"></a>1.3 标题形式</h2><pre><code class="hljs latex">% 章节序号 和 序号字体大小\renewcommand{\thesection}{{\zihao{4} \chinese{section}.}} % 一.\renewcommand{\thesubsection}{{\zihao{-4}\arabic{section}.\arabic{subsection}}} % 1.1\arabic (1, 2, 3, ...)\alph (a, b, c, ...)\Alph (A, B, C, ...)\roman (i, ii, iii, ...)\Roman (I, II, III, ...)\chinese (一，二，三，四，...)</code></pre><h2 id="1-4-字体字号"><a href="#1-4-字体字号" class="headerlink" title="1.4 字体字号"></a>1.4 字体字号</h2><pre><code class="hljs latex">{\songti 你好} % 宋体{\heiti 你好}  % 黑体\textbf{你好}  % 加粗</code></pre><pre><code class="hljs tex">{<span class="hljs-tag">\<span class="hljs-name">zihao</span><span class="hljs-string">{4}</span></span> 你好} <span class="hljs-comment">% 四号字体</span>{<span class="hljs-tag">\<span class="hljs-name">zihao</span><span class="hljs-string">{-4}</span></span> 你好} <span class="hljs-comment">% 小四号字体</span></code></pre><h2 id="1-5-行距"><a href="#1-5-行距" class="headerlink" title="1.5 行距"></a>1.5 行距</h2><p>在导言部分</p><pre><code class="hljs latex">% 行距，单倍行距\usepackage{setspace}\setstretch{1}1：单倍行距1.2：1.5倍行距1.6：2倍行距</code></pre><p>或者</p><pre><code class="hljs latex">\linespread{1}1：单倍行距1.2：1.5倍行距1.6：2倍行距</code></pre><h2 id="1-6-页眉页脚"><a href="#1-6-页眉页脚" class="headerlink" title="1.6 页眉页脚"></a>1.6 页眉页脚</h2><pre><code class="hljs latex">% 页眉页脚\usepackage{fancyhdr}\pagestyle{fancy}\fancyhf{}\cfoot{\thepage} % 页脚居中写页码\fancyhead[R]{\textbf{参赛队号 $\#\,6794$}} % 页脚写队名</code></pre><h2 id="1-7-图表公式的编号形式"><a href="#1-7-图表公式的编号形式" class="headerlink" title="1.7 图表公式的编号形式"></a>1.7 图表公式的编号形式</h2><pre><code class="hljs latex">% 图、表、公式的编号\renewcommand{\thefigure}{\arabic{section}-\arabic{figure}} # 5-1\renewcommand{\thetable}{\arabic{section}-\arabic{table}} # 5-1\renewcommand{\theequation}{\arabic{section}-\arabic{equation}} # 5-1% 单独一个图的引用如图 \ref{Fig:character}所示 % 如图5-1所示% 对多个图中的字图的引用如图 \arabic{section}-\ref{Fig:character:a}所示 % 如图5-1(a)所示</code></pre><h2 id="1-8-字体"><a href="#1-8-字体" class="headerlink" title="1.8 字体"></a>1.8 字体</h2><pre><code class="hljs latex">\textbf{字体} % 粗体\textit{字体} % 斜体\emph{重点}   % 强调</code></pre><h2 id="1-9-颜色"><a href="#1-9-颜色" class="headerlink" title="1.9 颜色"></a>1.9 颜色</h2><pre><code class="hljs latex">\definecolor{Red}{RGB}{225,0,0}\definecolor{Green}{RGB}{0,225,0}\definecolor{Blue}{RGB}{0,0,225}\textcolor{Red}{text}\textcolor{Green}{text}\textcolor{Blue}{text}</code></pre><h2 id="1-10-空格"><a href="#1-10-空格" class="headerlink" title="1.10 空格"></a>1.10 空格</h2><pre><code class="hljs latex">\quad\qquad\,\ (空格)\/</code></pre><h1 id="2-插入图片"><a href="#2-插入图片" class="headerlink" title="2. 插入图片"></a>2. 插入图片</h1><h2 id="2-1-单个图片"><a href="#2-1-单个图片" class="headerlink" title="2.1 单个图片"></a>2.1 单个图片</h2><pre><code class="hljs latex">% 添加包% figure 1\usepackage{graphicx}\usepackage{float}% 需要添加图片的地方\begin{figure}[H] % 此处需要用到宏包 float\centering % 图片居中\includegraphics[width = 8.3cm]{figures/figure_1.png}\caption{The caption of this figure.}\label{fig:figure1label}\end{figure}% 在中文中需要引用图片的地方如图 \ref{fig:figure1label} 所示</code></pre><h2 id="2-2-两个图片并列"><a href="#2-2-两个图片并列" class="headerlink" title="2.2 两个图片并列"></a>2.2 两个图片并列</h2><h3 id="2-2-1-两个并排图片，单独标题"><a href="#2-2-1-两个并排图片，单独标题" class="headerlink" title="2.2.1 两个并排图片，单独标题"></a>2.2.1 两个并排图片，单独标题</h3><pre><code class="hljs latex">% 使用的宏包\begin{minipage}[t]{0.5\linewidth}\end{minipage}</code></pre><pre><code class="hljs latex">\begin{figure}[H]\begin{minipage}[t]{0.5\linewidth}\centering\includegraphics[width=6cm]{figures/butterfly.jpg}\caption{left}\label{Fig:left}\end{minipage}\begin{minipage}[t]{0.5\linewidth}\centering\includegraphics[width=6cm]{figures/butterfly.jpg}\caption{right}\label{Fig:right}\end{minipage}\end{figure}</code></pre><h3 id="2-2-2-两个并排图片，单独小标题，共享大标题"><a href="#2-2-2-两个并排图片，单独小标题，共享大标题" class="headerlink" title="2.2.2 两个并排图片，单独小标题，共享大标题"></a>2.2.2 两个并排图片，单独小标题，共享大标题</h3><pre><code class="hljs latex">% 使用宏包\subfigure[小标题]{}</code></pre><pre><code class="hljs latex">% 添加红包 \usepackage{subfigure}\begin{figure}[H]\subfigure[left]{\begin{minipage}[t]{0.5\linewidth}\centering\includegraphics[width=6cm]{figures/butterfly.jpg}\label{Fig:left}\end{minipage}}\subfigure[right]{\begin{minipage}[t]{0.5\linewidth}\centering\includegraphics[width=6cm]{figures/butterfly.jpg}\label{Fig:right}\end{minipage}}\caption{G1 after first step of algorithm.}\end{figure}</code></pre><h1 id="3-插入表格"><a href="#3-插入表格" class="headerlink" title="3. 插入表格"></a>3. 插入表格</h1><h2 id="3-1-生成表格"><a href="#3-1-生成表格" class="headerlink" title="3.1 生成表格"></a>3.1 生成表格</h2><pre><code class="hljs latex">\usepackage{booktabs} % 绘制三线表</code></pre><pre><code class="hljs latex">\begin{table}[htp]\centering\caption{常用符号说明}\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}ll}%表格两边顶格\toprule符号             &amp; 说明 \\\midrule$s(x)$   &amp; 径向基函数      \\$I_1,I_2$        &amp; 不同纹理特征的图像\\\bottomrule\end{tabular*}\label{tab:symbol}\end{table}</code></pre><ul><li>latex表格生成网站:<a href="http://www.tablesgenerator.com/" target="_blank" rel="noopener">http://www.tablesgenerator.com/</a></li><li>excel转latex:<a href="https://tableconvert.com/" target="_blank" rel="noopener">https://tableconvert.com/</a></li></ul><h2 id="3-2-表格引用"><a href="#3-2-表格引用" class="headerlink" title="3.2 表格引用"></a>3.2 表格引用</h2><pre><code class="hljs latex">如表格 \ref{tab:DH}所示。</code></pre><h1 id="4-数学公式"><a href="#4-数学公式" class="headerlink" title="4. 数学公式"></a>4. 数学公式</h1><h2 id="4-0-包"><a href="#4-0-包" class="headerlink" title="4.0 包"></a>4.0 包</h2><pre><code class="hljs latex">\usepackage{amsmath}\usepackage{bm} % 数学公式中使用的黑体 \bm{R}</code></pre><h2 id="4-1-单个方程"><a href="#4-1-单个方程" class="headerlink" title="4.1 单个方程"></a>4.1 单个方程</h2><pre><code class="hljs latex">\begin{equation}y = ax+b\end{equation}</code></pre><script type="math/tex; mode=display">\begin{equation}y = ax+b\end{equation}</script><h2 id="4-2-方程组"><a href="#4-2-方程组" class="headerlink" title="4.2 方程组"></a>4.2 方程组</h2><pre><code class="hljs latex">% 左大括号\begin{equation}    \begin{cases}    y_1 = a_1x + b_1\\    y_2 = a_2x + b_2    \end{cases}\end{equation}% 两个方程是一组(使用1个编号)，没有左大括号\begin{equation}    \begin{gathered}    y_1 = a_1x + b_1\\    y_2 = a_2x + b_2    \end{gathered}\end{equation}% 两个方程是一组(使用1个编号)，有左大括号\begin{equation}\left \{\begin{gathered}y_1 = a_1x + b_1\\y_2 = a_2x + b_2\end{gathered}\right .\end{equation}</code></pre><script type="math/tex; mode=display">% 左大括号\begin{equation}    \begin{cases}    y_1 = a_1x + b_1\\    y_2 = a_2x + b_2    \end{cases}\end{equation}</script><script type="math/tex; mode=display">% 两个方程是一组(使用1个编号)，没有左大括号\begin{equation}    \begin{gathered}    y_1 = a_1x + b_1\\    y_2 = a_2x + b_2    \end{gathered}\end{equation}</script><script type="math/tex; mode=display">% 两个方程是一组(使用1个编号)，有左大括号\begin{equation}    \left \{        \begin{gathered}            y_1 = a_1x + b_1\\            y_2 = a_2x + b_2        \end{gathered}    \right .\end{equation}</script><h2 id="4-3-拆分单个公式"><a href="#4-3-拆分单个公式" class="headerlink" title="4.3 拆分单个公式"></a>4.3 拆分单个公式</h2><pre><code class="hljs latex">% 将一个长的公式分两行写\begin{equation}    \begin{split}    y =&amp; a + b + c\\       &amp; + d + e    \end{split}\end{equation}</code></pre><script type="math/tex; mode=display">% 将一个长的公式分两行写\begin{equation}    \begin{split}    y =& a + b + c\\       & + d + e    \end{split}\end{equation}</script><h2 id="4-4-分段函数"><a href="#4-4-分段函数" class="headerlink" title="4.4 分段函数"></a>4.4 分段函数</h2><pre><code class="hljs latex">\begin{equation}T=    \begin{cases}        0       &amp; a&lt;2\\        1       &amp; a=2\\        3       &amp; a&gt;2    \end{cases}\end{equation}</code></pre><script type="math/tex; mode=display">\begin{equation}T=    \begin{cases}        0       & a<2\\        1       & a=2\\        3       & a>2    \end{cases}\end{equation}</script><h2 id="4-5-矩阵"><a href="#4-5-矩阵" class="headerlink" title="4.5 矩阵"></a>4.5 矩阵</h2><pre><code class="hljs latex">\begin{equation}    \begin{bmatrix}        a &amp; b\\        c &amp; d    \end{bmatrix}\end{equation}</code></pre><script type="math/tex; mode=display">\begin{equation}    \begin{bmatrix}        a & b\\        c & d    \end{bmatrix}\end{equation}</script><h2 id="4-6-分子分母"><a href="#4-6-分子分母" class="headerlink" title="4.6 分子分母"></a>4.6 分子分母</h2><pre><code class="hljs latex">\begin{equation}    \frac{a+b}{c+d}\end{equation}</code></pre><script type="math/tex; mode=display">\begin{equation}    \frac{a+b}{c+d}\end{equation}</script><h2 id="4-7-希腊字母"><a href="#4-7-希腊字母" class="headerlink" title="4.7 希腊字母"></a>4.7 希腊字母</h2><pre><code class="hljs latex">% 小写希腊字母(大写希腊字母时，首字母大写即可)\alpha\beta\gamma\delta\epsilon\eta\theta\lambda\mu\sigma\tau\phi\varphi\chi\psi\omega</code></pre><script type="math/tex; mode=display">% 小写希腊字母(大写希腊字母时，首字母大写即可)\alpha\beta\gamma\delta\epsilon\eta\theta\lambda\mu\sigma\tau\phi\varphi\chi\psi\omega</script><h2 id="4-8-数学算子"><a href="#4-8-数学算子" class="headerlink" title="4.8 数学算子"></a>4.8 数学算子</h2><pre><code class="hljs latex">\sum     % 求和\prod    % 乘积\partial % 微分\int     % 积分\iint    % 二级积分\iiint   % 三级积分</code></pre><script type="math/tex; mode=display">\sum     \\ % 求和 \prod    \\ % 乘积 \partial \\ % 微分\int     \\ % 积分\iint    \\ % 二级积分\iiint   \\ % 三级积分</script><h1 id="5-一些符号"><a href="#5-一些符号" class="headerlink" title="5. 一些符号"></a>5. 一些符号</h1><h2 id="5-1-度"><a href="#5-1-度" class="headerlink" title="5.1 度"></a>5.1 度</h2><pre><code class="hljs latex">90^{\circ}</code></pre><script type="math/tex; mode=display">90^{\circ}</script><h2 id="5-2-角"><a href="#5-2-角" class="headerlink" title="5.2 角"></a>5.2 角</h2><pre><code class="hljs latex">\angle A = 90^{\circ}</code></pre><script type="math/tex; mode=display">\angle A = 90^{\circ}</script><h2 id="5-3-单引号，双引号"><a href="#5-3-单引号，双引号" class="headerlink" title="5.3 单引号，双引号"></a>5.3 单引号，双引号</h2><pre><code class="hljs latex">'单引号'\\''双引号''</code></pre><script type="math/tex; mode=display">'单引号'\\''双引号''</script><h2 id="5-4-横杠"><a href="#5-4-横杠" class="headerlink" title="5.4 横杠"></a>5.4 横杠</h2><pre><code class="hljs latex">-   \\ % 连字符--  \\ % 数字范围--- \\ % 破折号</code></pre><h2 id="5-5-下划线"><a href="#5-5-下划线" class="headerlink" title="5.5 下划线"></a>5.5 下划线</h2><pre><code class="hljs latex">\underline{论文} % 单下划线\uuline{论文}    % 双下划线</code></pre><h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6. 列表"></a>6. 列表</h1><h2 id="6-1-列表"><a href="#6-1-列表" class="headerlink" title="6.1 列表"></a>6.1 列表</h2><pre><code class="hljs latex">% 列表里面嵌套列表\begin{enumerate}\item [1.] 大学\begin{enumerate}\item [1.1] 大一\item [1.2] 大二\item [1.3] 大三\item [1.4] 大四\end{enumerate}\item [2.] 研究生\end{enumerate}</code></pre><h1 id="7-插入代码"><a href="#7-插入代码" class="headerlink" title="7. 插入代码"></a>7. 插入代码</h1><h2 id="7-1-包"><a href="#7-1-包" class="headerlink" title="7.1 包"></a>7.1 包</h2><pre><code class="hljs latex">\usepackage{listings} % 插入代码的包\usepackage{xcolor} %颜色包\lstset{ %language=Matlab,                % the language of the codebasicstyle=\zihao{-4},       % the size of the fonts that are used for the codenumbers=left,                   % where to put the line-numbersnumberstyle=\tiny\color{gray},  % the style that is used for the line-numbersstepnumber=1,                   % the step between two line-numbers. If it is 1, each line will be numberednumbersep=5pt,                  % how far the line-numbers are from the codebackgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}showspaces=false,               % show spaces adding particular underscoresshowstringspaces=false,         % underline spaces within stringsshowtabs=false,                 % show tabs within strings adding particular underscoresframe=single,                   % adds a frame around the coderulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))tabsize=2,                      % sets default tabsize to 2 spacescaptionpos=b,                   % sets the caption-position to bottombreaklines=true,                % sets automatic line breakingbreakatwhitespace=false,        % sets if automatic breaks should only happen at whitespacetitle=\lstname,                 % show the filename of files included with \lstinputlisting;% also try caption instead of titlekeywordstyle=\color{blackred},          % keyword stylecommentstyle=\color{dkgreen},   % comment stylestringstyle=\color{MidnightBlue},         % string literal styleescapeinside={\%*}{*)},         % if you want to add LaTeX within your codemorekeywords={*,...},           % if you want to add more keywords to the setescapechar=`,                    % 中文注释columns=flexible                % 非等款输出}</code></pre><h2 id="7-2-代码"><a href="#7-2-代码" class="headerlink" title="7.2 代码"></a>7.2 代码</h2><pre><code class="hljs latex">% 先定义颜色\definecolor{dkgreen}{rgb}{0,0.6,0}\definecolor{gray}{rgb}{0.5,0.5,0.5}\definecolor{MidnightBlue}{RGB}{25,25,112}\definecolor{blackred}{RGB}{199,21,133} % 关键字颜色% 代码\begin{lstlisting}[language = Matlab]  function [W, Z, mu, mse] = pcaEm(X, m)  % Perform EM-like algorithm for PCA (by Sam Roweis).  % Input:  %   X: d x n data matrix  %   m: dimension of target space  % Output:  %   W: d x m weight matrix  %   Z: m x n projected data matrix  %   mu: d x 1 mean vector  %   mse: mean square error  % Reference:   %   Pattern Recognition and Machine Learning by Christopher M. Bishop   %   EM algorithms for PCA and SPCA by Sam Roweis   % Written by Mo Chen (sth4nth@gmail.com).  d = size(X,1);  mu = mean(X,2);  X = bsxfun(@minus,X,mu);  W = rand(d,m);   tol = 1e-6;  mse = inf;  maxIter = 200;  for iter = 1:maxIter  Z = (W'*W)\(W'*X);             % 12.58  W = (X*Z')/(Z*Z');              % 12.59  %...\end{lstlisting}</code></pre><h1 id="8-文献引用"><a href="#8-文献引用" class="headerlink" title="8. 文献引用"></a>8. 文献引用</h1><h2 id="8-1-文献的下载"><a href="#8-1-文献的下载" class="headerlink" title="8.1 文献的下载"></a>8.1 文献的下载</h2><p>谷歌学术上下载文献后,点击如下图标:</p><p><img src="image-20200111205436290.png" srcset="/img/loading.gif" alt="谷歌学术上下载文献"></p><p>得到如下文本:</p><pre><code class="hljs tex">@article{李德毅2004不确定性人工智能,  title={不确定性人工智能},  author={李德毅 and 刘常昱 and 杜鹢 and 韩旭},  journal={软件学报},  volume={15},  number={11},  year={2004}}</code></pre><p>复制到剪切板,打开zotero,文件=&gt;从剪切板导入:</p><p><img src="image-20200111205718228.png" srcset="/img/loading.gif" alt="剪切板导入文本"></p><p>右键该条目,添加附件=&gt;附加文件副本,可以将文件添加入内:</p><p><img src="image-20200111205910856.png" srcset="/img/loading.gif" alt="添加文件副本"></p><p>当有多条的时候,将需要的选中,然后右键导出条目.可以将所有选中条目导出为bibtex(.bib)文件:</p><p><img src="image-20200111210233332.png" srcset="/img/loading.gif" alt="导出为bibtex"></p><h2 id="8-2-bibtex文件的使用"><a href="#8-2-bibtex文件的使用" class="headerlink" title="8.2 bibtex文件的使用"></a>8.2 bibtex文件的使用</h2><p>latex文件使用cite包:</p><pre><code class="hljs latex">\usepackage{cite}</code></pre><p>文档的结尾使用这两句话:</p><pre><code class="hljs latex">\bibliographystyle{plain}\bibliography{ref}</code></pre><p>其中ref是bibtex文件的名字(此代码处为ref.bib)</p><p>当上面的文章需要使用bibtex中的文件,使用:</p><pre><code class="hljs latex">\cite{__2004}</code></pre><p>其中”__2004”是你要引用的条目的第一句话,例如本ref.bib文件如下:</p><pre><code class="hljs latex">@article{__2004,title = {不确定性人工智能},volume = {15},number = {11},journal = {软件学报},author = {{李德毅} and {刘常昱} and {杜鹢} and {韩旭}},year = {2004},file = {李德毅 等。 - 2004 - 不确定性人工智能.pdf:C\:\\Users\\25648\\Zotero\\storage\\TV4IWQII\\李德毅 等。 - 2004 - 不确定性人工智能.pdf:application/pdf}}@article{__2012,title = {人工智能及其发展应用},volume = {12},number = {2},journal = {信息网络安全},author = {{邹蕾} and {张先锋}},year = {2012},pages = {0--0},file = {邹蕾 和 张先锋 - 2012 - 人工智能及其发展应用.pdf:C\:\\Users\\25648\\Zotero\\storage\\3U4NZ6YF\\邹蕾 和 张先锋 - 2012 - 人工智能及其发展应用.pdf:application/pdf}}</code></pre><p>所以”__2004”显示后就是如下效果:</p><p>代码部分:</p><pre><code class="hljs latex">李德毅的文章\cite{__2004}\bibliographystyle{plain}\bibliography{ref}</code></pre><p>效果:</p><p><img src="image-20200111211644798.png" srcset="/img/loading.gif" alt="效果"></p><p>注意,在没有前文引用的情况下,文献是不会显示的,如上面的&lt;&lt;人工智能及其发展应用&gt;&gt;没有被引用所以没有对应的条目.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>latex</category>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记</title>
    <link href="/2020/04/25/python-bi-ji/"/>
    <url>/2020/04/25/python-bi-ji/</url>
    
    <content type="html"><![CDATA[<h2 id="函数参数中含有列表的问题"><a href="#函数参数中含有列表的问题" class="headerlink" title="函数参数中含有列表的问题"></a>函数参数中含有列表的问题</h2><p><strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888</a></p></blockquote><p>有如下函数</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_end</span><span class="hljs-params">(L=[])</span>:</span>    L.append(<span class="hljs-string">'END'</span>)    <span class="hljs-keyword">return</span> L</code></pre><p>正常使用没问题,但是如果如下操作:</p><pre><code class="hljs bash">&gt;&gt;&gt; add_end()[<span class="hljs-string">'END'</span>, <span class="hljs-string">'END'</span>]&gt;&gt;&gt; add_end()[<span class="hljs-string">'END'</span>, <span class="hljs-string">'END'</span>, <span class="hljs-string">'END'</span>]</code></pre><p>则会出现令人费解的问题,原因如下:</p><p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p><p>为了避免这个问题,可以用<code>None</code>这个不变对象来实现:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_end</span><span class="hljs-params">(L=None)</span>:</span>    <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        L = []    L.append(<span class="hljs-string">'END'</span>)    <span class="hljs-keyword">return</span> L</code></pre><h2 id="可变参数与列表的结合-与-的使用"><a href="#可变参数与列表的结合-与-的使用" class="headerlink" title="可变参数与列表的结合:*与**的使用"></a>可变参数与列表的结合:*与**的使用</h2><p>如果python代码看的比较多的时候,就会发现有类似如下的写法:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function</span><span class="hljs-params">(*args,**kwargs)</span>:</span>...</code></pre><p>*args 用来将参数打包成tuple给函数体调用, **kwargs 打包关键字参数成dict给函数体调用</p><p>如果某函数如下:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">function</span><span class="hljs-params">(arg1,arg2,*args,**kwargs)</span>:</span>    print(arg1,arg2,args,kwargs)</code></pre><p>调用如下:</p><pre><code class="hljs bash">&gt;&gt;&gt; funtion(1,2,3,4,5,6,7,a=1,b=2,c=3)1 2 (3, 4, 5, 6, 7) {<span class="hljs-string">'a'</span>: 1, <span class="hljs-string">'b'</span>: 2, <span class="hljs-string">'c'</span>: 3}</code></pre><p>可以看到对应的结果</p><p>如果想传入现成的列表和字典的时候可以使用*和**进行输入:</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lst = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>dict={<span class="hljs-string">"a"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"b"</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"c"</span>:<span class="hljs-number">3</span>}<span class="hljs-meta">&gt;&gt;&gt; </span>function(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,*lst,**dict)<span class="hljs-number">1</span> <span class="hljs-number">2</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) {<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>}</code></pre><p>甚至对于普通的函数也可以用**进行输入参数:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(name,age)</span>:</span>    print(name,age)&gt;&gt;&gt;dicts = {<span class="hljs-string">"name"</span>:<span class="hljs-string">"cc"</span>,<span class="hljs-string">"age"</span>:<span class="hljs-number">11</span>}&gt;&gt;&gt;func(**dicts)&gt;&gt;&gt;cc <span class="hljs-number">11</span></code></pre><blockquote><p>下段代码来源:<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888</a></p></blockquote><p>当需要限定关键字,可以使用*作为分隔符，*后面的参数被视为命名关键字参数</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">person</span><span class="hljs-params">(name, age, *, city, job)</span>:</span>    print(name, age, city, job)    <span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">'Jack'</span>, <span class="hljs-number">24</span>, city=<span class="hljs-string">'Beijing'</span>, job=<span class="hljs-string">'Engineer'</span>)Jack <span class="hljs-number">24</span> Beijing Engineer</code></pre><h2 id="列表的等间隔切片"><a href="#列表的等间隔切片" class="headerlink" title="列表的等间隔切片"></a>列表的等间隔切片</h2><p>给个例子就很明确了:</p><pre><code class="hljs python">&gt;&gt;&gt;lst = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]&gt;&gt;&gt;lst[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>][<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]</code></pre><h2 id="生成器generator与yield结合的用法"><a href="#生成器generator与yield结合的用法" class="headerlink" title="生成器generator与yield结合的用法"></a>生成器generator与yield结合的用法</h2><p>详见<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856/" target="_blank" rel="noopener">https://blog.csdn.net/mieleizhi0522/article/details/82142856/</a></p><h2 id="map和reduce"><a href="#map和reduce" class="headerlink" title="map和reduce"></a>map和reduce</h2><p>map就是映射函数于列表,非常方便产生列表,例子如下:</p><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span>:</span><span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> x * x...<span class="hljs-meta">&gt;&gt;&gt; </span>r = map(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>list(r)[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]</code></pre><p>reduce函数用一个例子表述,功能是不用<code>int()</code>进行字符串转整型数:</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduceDIGITS = {<span class="hljs-string">'0'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'1'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'2'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'3'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'4'</span>: <span class="hljs-number">4</span>, <span class="hljs-string">'5'</span>: <span class="hljs-number">5</span>, <span class="hljs-string">'6'</span>: <span class="hljs-number">6</span>, <span class="hljs-string">'7'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'8'</span>: <span class="hljs-number">8</span>, <span class="hljs-string">'9'</span>: <span class="hljs-number">9</span>}<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">char2num</span><span class="hljs-params">(s)</span>:</span>    <span class="hljs-keyword">return</span> DIGITS[s]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">str2int</span><span class="hljs-params">(s)</span>:</span>    <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x * <span class="hljs-number">10</span> + y, map(char2num, s))</code></pre><h2 id="lambda表达式和列表生成式产生的奇妙反应"><a href="#lambda表达式和列表生成式产生的奇妙反应" class="headerlink" title="lambda表达式和列表生成式产生的奇妙反应"></a>lambda表达式和列表生成式产生的奇妙反应</h2><p>先看一段代码:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> [<span class="hljs-keyword">lambda</span> x:i*x <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)]&gt;&gt;&gt;[m(<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> num()][<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>]</code></pre><p>如果你不知道为什么会这样,具体原因见:</p><p><a href="https://blog.csdn.net/CxsGhost/article/details/103697506" target="_blank" rel="noopener">https://blog.csdn.net/CxsGhost/article/details/103697506</a></p><p>个人的解释是:上面的代码可以等价为下列代码:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num</span><span class="hljs-params">()</span>:</span>    i = <span class="hljs-number">0</span>    lst = []    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fun</span><span class="hljs-params">(x)</span>:</span>        <span class="hljs-keyword">return</span> i * x    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):        i = j        lst.append(fun)    <span class="hljs-keyword">return</span> lst&gt;&gt;&gt;[m(<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> num()]</code></pre><p>因为i是命名空间lambda里面所以外部的i是不会进入内部的,首先产生<code>[lambda x:i*x,lambda x:i*x,lambda x:i*x,lambda x:i*x]</code>,循环完了后,i=3,所以返回<code>[lambda x:3*x,lambda x:3*x,lambda x:3*x,lambda x:3*x]</code></p><h2 id="偏函数的用法"><a href="#偏函数的用法" class="headerlink" title="偏函数的用法"></a>偏函数的用法</h2><p>有的时候,希望某些函数的参数固定,就可以使用如下方法进行固定</p><pre><code class="hljs python">functools.partial()</code></pre><p>用法详见网上</p><h2 id="类与对象的方法"><a href="#类与对象的方法" class="headerlink" title="类与对象的方法"></a>类与对象的方法</h2><ol><li><p>getattr(),setattr(),hasattr()三种方法的</p></li><li><p><code>__getitem__()</code>:</p><p>如果想要一个类既有索引又可以切片,需要类似如下的操作</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fib</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-keyword">if</span> isinstance(n, int): <span class="hljs-comment"># n是索引</span>            a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(n):                a, b = b, a + b            <span class="hljs-keyword">return</span> a        <span class="hljs-keyword">if</span> isinstance(n, slice): <span class="hljs-comment"># n是切片</span>            start = n.start            stop = n.stop            <span class="hljs-keyword">if</span> start <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:                start = <span class="hljs-number">0</span>            a, b = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>            L = []            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(stop):                <span class="hljs-keyword">if</span> x &gt;= start:                    L.append(a)                a, b = b, a + b            <span class="hljs-keyword">return</span> L</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络第一章</title>
    <link href="/2020/04/25/ji-suan-ji-wang-luo-di-yi-zhang/"/>
    <url>/2020/04/25/ji-suan-ji-wang-luo-di-yi-zhang/</url>
    
    <content type="html"><![CDATA[<h2 id="1-2-互联网概述"><a href="#1-2-互联网概述" class="headerlink" title="1.2 互联网概述"></a>1.2 互联网概述</h2><h3 id="1-2-1网络的网络"><a href="#1-2-1网络的网络" class="headerlink" title="1.2.1网络的网络"></a>1.2.1网络的网络</h3><p><strong>计算机网络（简称为网络）</strong>由若干结点（node）和连接这些结点的链路（link）组成。网络中的结点可以是计算机、集线器、交换机或路由器等</p><p><img src="image-20200422123653298.png" srcset="/img/loading.gif" alt="网络"></p><p>(a)图三个计算机和一个节点组成了一个网络,上面一片云代表一个网络,(b)图中,很多网络连接起来组成更大的网络,成为网络的网络,即互联网</p><p>习惯上，与网络相连的计算机或手机等终端常称为<strong>主机</strong>（host）。</p><h3 id="1-2-2-互联网基础结构发展的三个阶段"><a href="#1-2-2-互联网基础结构发展的三个阶段" class="headerlink" title="1.2.2 互联网基础结构发展的三个阶段"></a>1.2.2 互联网基础结构发展的三个阶段</h3><ol><li><p>第一阶段是从单个网络ARPANET向互连网发展的过程</p><p>1969年美国国防部创建的第一个分组交换网ARPANET最初只是一个单个的分组交换网（并不是一个互连的<br>网络）。</p><p>1983年TCP/IP协议成为ARPANET上的标准协议，使得所有使用TCP/IP协议的计算机都能利用互连网相互通信，因而人们就把1983年作为互联网的诞生时间。</p><p><strong>internet和Internet的区别:</strong></p><ul><li><p>以小写字母i开始的internet（互连网）是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。在这些网络之间的通信协议（即通信规则）可以任意选择，不一定非要使用TCP/IP协议。</p></li><li><p>以大写字母I开始的Internet（互联网，或因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用TCP/IP协议族作为通信的规则，且其前身是美国的ARPANET。</p></li></ul></li><li><p>第二阶段的特点是建成了三级结构的互联网</p><p>从1985年起，美国国家科学基金会NSF（National Science Foundation）就围绕六个大型计算机中心建设计算机网络，即国家科学基金网NSFNET。它是一个三级计算机网络，分为主干网、地区网和校园网（或企业网）。</p></li><li><p>第三阶段的特点是逐渐形成了多层次ISP结构的互联网</p><p>1993年开始出现互联网服务提供者ISP（Internet Service Provider）。在许多情况下，ISP就是一个进行商业活动的公司，因此ISP又常译为互联网服务提供商。例如，中国电信、中国联通和中国移动等公司都是我国最有名的ISP。</p></li></ol><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><p>可以划分为以下两大块：</p><ul><li>边缘部分　由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享</li><li>核心部分　由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）</li></ul><p><img src="image-20200423114135405.png" srcset="/img/loading.gif" alt="互联网边缘部分和核心部分"></p><h3 id="1-3-1-互联网的边缘部分"><a href="#1-3-1-互联网的边缘部分" class="headerlink" title="1.3.1 互联网的边缘部分"></a>1.3.1 互联网的边缘部分</h3><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为端系统（end system）</p><p><strong>“主机A和主机B进行通信”，实际上是指：“运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。由于“进程”就是“运行着的程序”，因此这也就是指：“主机A的某个进程和主机B上的另一个进程进行通信”。这种比较严密的说法通常可以简称为“计算机之间通信”。</strong></p><p>在网络边缘的端系统之间的通信方式通常可划分为两大类：客户-服务器方式（C/S方式）和对等方式（P2P方式):</p><ol><li><p>客户-服务器方式</p><p>上网发送电子邮件或在网站上查找资料时，都是使用客户-服务器方式（有时写为客户/服务器方式）。</p><p>客户（client）和服务器（server）都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服务和被服务的关系。</p><p>客户程序的特点:</p><ul><li>被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和很复杂的操作系统。</li></ul><p>服务器程序：</p><ul><li>是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li><li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</li><li>一般需要有强大的硬件和高级的操作系统支持。</li></ul></li><li><p>对等连接方式</p><p>对等连接（peer-to-peer，简写为P2P）是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。</p><p>对等连接方式从本质上看仍然是使用客户-服务器方式，只是对等连接中的每一台主机既是客户又同时是服务器。</p><p>对等连接工作方式可支持大量对等用户（如上百万个）同时工作。</p></li></ol><h3 id="1-3-2-互联网的核心部分"><a href="#1-3-2-互联网的核心部分" class="headerlink" title="1.3.2 互联网的核心部分"></a>1.3.2 互联网的核心部分</h3><p>在网络核心部分起特殊作用的是路由器（router），它是一种专用计算机（但不叫做主机）。路由器是实现分组交换（packet switching）的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</p><ol><li><p>电路交换的主要特点</p><p><strong>从通信资源的分配角度来看，交换（switching）就是按照某种方式动态地分配传输线路的资源。</strong>在使用电路交换通话之前，必须先拨号请求建立连接。当被叫用户听到交换机送来的振铃音并摘机后，从主叫端到被叫端就建立了一条连接，也就是一条专用的物理通路。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信时不会被其他用户占用。此后主叫和被叫双方就能互相通电话。通话完毕挂机后，交换机释放刚才使用的这条专用的物理通路（即把刚才占用的所有通信资源归还给电信网）。<strong>这种必须经过“建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）”三个步骤的交换方式称为电路交换.</strong>如果用户在拨号呼叫时电信网的资源已不足以支持这次的呼叫，则主叫用户会听到忙音，表示电信网不接受用户的呼叫，用户必须挂机，等待一段时间后再重新拨号。</p><p><img src="image-20200423152330450.png" srcset="/img/loading.gif" alt="电路交换的用户始终占用端到端的通信资源"></p><p><strong>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</strong></p></li><li><p>分组交换的主要特点</p><p>分组交换则采用存储转发技术。下图表示把一个报文划分为几个分组后再进行传送。</p><p><img src="image-20200423153736321.png" srcset="/img/loading.gif" alt="以分组为基本单位在网络中传送"></p><p>通常我们把要发送的整块数据称为一个报文（message）。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段，例如，每个数据段为1024bit。在每一个数据段前面，加上一些由必要的控制信息组成的首部（header）后，就构成了一个分组（packet）。分组又称为“包”，而分组的首部也可称为“包头”。分组是在互联网中传送的数据单元。分组中的“首部”是非常重要的，正是由于分组的首部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</p><p>主机和计算机的不同功能:</p><ul><li><p><strong>主机</strong>是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。</p></li><li><p><strong>路由器</strong>是用来转发分组的，即进行分组交换的。路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。</p><p>各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。</p></li></ul><p><strong>分组交换的特点:</strong></p><ol><li>传送数据之前不必先占用一条端到端的链路的通信资源,分组在哪段链路上传送才占用这段链路的通信资源</li><li>省去了建立连接和释放连接的开销，因而数据的传输效率更高</li><li>当网络中的某些结点或链路突然出现故障时，在各路由器中运行的路由选择协议（protocol）能够自动找到转发分组最合适的路径</li></ol><p><strong>为了提高分组交换网的可靠性，互联网的核心部分常采用网状拓扑结构</strong></p><p>综上,分组交换的优点有:</p><p><img src="image-20200424113110361.png" srcset="/img/loading.gif" alt="分组交换的优点"></p></li></ol><p>三种交换方式在数据传送阶段的主要特点：</p><ul><li>电路交换——整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li>报文交换——整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li><li>分组交换——单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</li></ul><p><img src="image-20200424123225063.png" srcset="/img/loading.gif" alt="三种交换的比较"></p><p>上图可知:</p><ul><li>大量传输数据的时候,一般传送时间远远大于建立连接时间,则电路交换的传输速率较快</li><li>报文交换和分组交换相对电路交换相比,在传送突发数据时可提高整个网络的信道利用率</li><li>分组交换比比报文交换的时延小,具有更好的灵活性</li></ul><h2 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h2><h3 id="1-5-1-计算机网络的定义"><a href="#1-5-1-计算机网络的定义" class="headerlink" title="1.5.1 计算机网络的定义"></a>1.5.1 计算机网络的定义</h3><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><p>根据这定义:</p><ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机。</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li></ul><h3 id="1-5-2-几种不同类别的计算机网络"><a href="#1-5-2-几种不同类别的计算机网络" class="headerlink" title="1.5.2 几种不同类别的计算机网络"></a>1.5.2 几种不同类别的计算机网络</h3><ol><li><p>按照网络的作用范围进行分类</p><p>|          | 广域网                            | 城域网                           | 局域网                                   | 个人区域网                                                   |<br>| ———— | ————————————————- | ———————————————— | ———————————————————— | —————————————————————————————— |<br>| 名称     | WAN（Wide Area Network）          | MAN（Metropolitan Area Network） | LAN（Local Area Network）                | PAN（Personal Area Network）                                 |<br>| 作用范围 | 几十到几千km                      | 5～50km                          | 1km左右                                  | 10m左右                                                      |<br>| 特点     | 互联网的核心部分,有较大的通信容量 | 将多个局域网进行互连             | 用微型计算机或工作站通过高速通信线路相连 | 把属于个人使用的电子设备（如便携式电脑等）用无线技术连接起来的网络 |</p></li><li><p>按照网络的使用者进行分类</p><ul><li>公用网（public network）</li><li>专用网（private network）</li></ul></li></ol><h2 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h2><h3 id="1-6-1-计算机网络的性能指标"><a href="#1-6-1-计算机网络的性能指标" class="headerlink" title="1.6.1 计算机网络的性能指标"></a>1.6.1 计算机网络的性能指标</h3><ul><li><p>速率: 速率的单位是bit/s（bps,比特每秒）</p></li><li><p>带宽:（bandwidth）:某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”,单位bit/s，是“比特每秒”。</p></li><li><p>吞吐量（throughput）表示在单位时间内通过某个网络（或信道、接口）的实际的数据量。吞吐量受网络的带宽或网络的额定速率的限制</p></li><li><p>时延（delay或latency）是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p><p>时延分以下四个:</p><ul><li><p>发送时延:发送时延（transmission delay）是主机或路由器发送数据帧所需要的时间:</p><script type="math/tex; mode=display">发送时延=\frac{数据帧长度(bit)}{发送速率(bit/s)}</script></li><li><p>传播时延:传播时延（propagation delay）是电磁波在信道中传播一定的距离需要花费的时间。</p><script type="math/tex; mode=display">传播时延=\frac{信道长度(m)}{电磁波在信道上传播的速率(m/s)}</script></li><li><p>处理时延:主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等</p></li><li>排队时延:分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。</li></ul><p>由上可知:</p><script type="math/tex; mode=display">总时延=发送时延+传播时延+处理时延+排队时延</script><p><img src="image-20200424223149141.png" srcset="/img/loading.gif" alt="几种地方产生的时延"></p></li><li><p>时延带宽积:</p><script type="math/tex; mode=display">时延带宽积=传播时延\times带宽</script><p><img src="image-20200424231857587.png" srcset="/img/loading.gif" alt="链路像一条空心管道"></p></li><li><p>往返时间RTT:RTT（Round-Trip Time）</p></li><li><p>利用率:利用率有信道利用率和网络利用率两种</p><ul><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</li><li>网络利用率则是全网络的信道利用率的加权平均值。</li></ul><p>信道利用率并非越高越好。这是因为，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。令$D_0$表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式来表示D，$D_0$和利用率U之间的关系:</p><script type="math/tex; mode=display">D =\frac{D_0}{1-U}</script><p>这里U是网络的利用率，数值在0到1之间,<strong>因此我们必须有这样的概念：信道或网络的利用率过高会产生</strong><br><strong>非常大的时延</strong></p><p><img src="image-20200425000955599.png" srcset="/img/loading.gif" alt="时延与利用率的关系"></p></li></ul><h3 id="1-6-2-计算机网络的非性能特征"><a href="#1-6-2-计算机网络的非性能特征" class="headerlink" title="1.6.2 计算机网络的非性能特征"></a>1.6.2 计算机网络的非性能特征</h3><p>费用,质量,标准化,可靠性,可扩展性和可升级性,易于管理和维护</p><h2 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h2><h3 id="1-7-2-协议与划分层次"><a href="#1-7-2-协议与划分层次" class="headerlink" title="1.7.2 协议与划分层次"></a>1.7.2 协议与划分层次</h3><p>网络协议也可简称为协议。更进一步讲，网络协议主要由以下三个要素组成：<br>（1）语法，即数据与控制信息的结构或格式；<br>（2）语义，即需要发出何种控制信息，完成何种动作以及做出何种响应；<br>（3）同步，即事件实现顺序的详细说明。</p><p>分层可以带来很多好处。如：</p><ul><li>各层之间是独立的。</li><li>灵活性好。</li><li>结构上可分割开。</li><li>易于实现和维护。</li><li>能促进标准化工作。</li></ul><p>通常各层所要完成的功能主要有以下一些（可以只包括一种，也可以包括多种）：</p><ul><li>差错控制　使相应层次对等方的通信更加可靠。</li><li>流量控制　发送端的发送速率必须使接收端来得及接收，不要太快。</li><li>分段和重装　发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li>复用和分用　发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li>连接建立和释放　交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li></ul><p><strong>计算机网络的各层及其协议的集合就是网络的体系结构（architecture）。</strong></p><h3 id="1-7-3-具有五层协议的体系结构"><a href="#1-7-3-具有五层协议的体系结构" class="headerlink" title="1.7.3 具有五层协议的体系结构"></a>1.7.3 具有五层协议的体系结构</h3><p><img src="image-20200425124909386.png" srcset="/img/loading.gif" alt="计算机网络体系结构"></p><ol><li><p>应用层（application layer）</p><p>应用层协议定义的是应用进程间通信和交互的规则</p><p>应用层交互的数据单元称为报文（message）</p><p>任务是通过应用进程间的交互来完成特定网络应用</p><p>域名系统DNS，HTTP协议，电子邮件的SMTP协议均是应用层的协议</p></li><li><p>运输层（transport layer）</p><p>运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务</p><p>运输层主要的协议是:</p><ul><li>传输控制协议TCP（Transmission Control Protocol）——提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>（segment）。</li><li>用户数据报协议UDP（User Datagram Protocol）——提供无连接的、尽最大努力（best-effort）的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户<strong>数据报</strong>。</li></ul></li><li><p>网络层（network layer）</p><p>网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。</p></li><li><p>数据链路层（data link layer）</p><p>数据链路层将网络层交下来的IP数据报组装成帧（framing），在两个相邻结点间的链路上传送帧（frame）。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</p><p>主要作用是:提取数据,上交网络层,差错检测</p></li><li><p>物理层（physical layer）</p><p>物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。</p><p><strong>传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。</strong></p></li></ol><p>下图是主机1的应用进程AP1向主机2的应用进程AP2传送数据的过程,$H<em>1到H_5$是加入的控制信息,物理层是数据流传送所以不需要控制信息.当到达路由器后,会从第一到第三层,根据首部$H</em>{2}$的的目的地址查找路由器中的转发表，找出转发分组的接口，然后往下传送到第2层，加上新的首部和尾部后，再到最下面的第1层</p><p><img src="image-20200425142700026.png" srcset="/img/loading.gif" alt="数据在各层之间的传递过程"></p><h3 id="1-7-4-实体、协议、服务和服务访问点"><a href="#1-7-4-实体、协议、服务和服务访问点" class="headerlink" title="1.7.4 实体、协议、服务和服务访问点"></a>1.7.4 实体、协议、服务和服务访问点</h3><p>实体:表示任何可发送或接收信息的硬件或软件进程</p><p>协议:控制两个对等实体（或多个实体）进行通信的规则的集合</p><p>协议和服务的区别:</p><ul><li>协议的实现保证了能够向上一层提供服务</li><li>使用本层服务的实体只能看见服务而无法看见下面的协议,下面的协议对上面的实体是透明的</li><li>协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的</li></ul><p>第n层向上面的第n＋1层所提供的服务实际上已包括了在它以下各层所提供的服务。第n层的实体对第n＋1层的实体就相当于一个服务提供者</p><h3 id="1-7-5-TCP-IP的体系结构"><a href="#1-7-5-TCP-IP的体系结构" class="headerlink" title="1.7.5 TCP/IP的体系结构"></a>1.7.5 TCP/IP的体系结构</h3><p><img src="image-20200425173859283.png" srcset="/img/loading.gif" alt="沙漏计时器形状的TCP/IP协议族示意"></p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><ol><li><p>计算机网络（可简称为网络）把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络</p></li><li><p>以小写字母i开始的internet（互连网）是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。</p><p>以大写字母I开始的Internet（互联网）是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用TCP/IP协议族作为通信规则，且其前身是美国的ARPANET。Internet的推荐译名是“因特网”，但很少被使用。</p></li><li><p>互联网现在采用存储转发的分组交换技术，以及三层ISP结构。互联网按工作方式可划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</p></li><li><p>计算机通信是计算机中的进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户–服务器方式和对等连接方式（P2P方式）。客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</p></li><li><p>按作用范围的不同，计算机网络分为广域网WAN、城域网MAN、局域网LAN和个人区域网PAN。</p></li><li><p>计算机网络最常用的性能指标是：速率、带宽、吞吐量、时延（发送时延、传播时延、处理时延、排队时延）、时延带宽积、往返时间和信道（或网络）利用率。</p></li><li><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</p></li><li><p>五层协议的体系结构由应用层、运输层、网络层（或网际层）、数据链路层和物理层组成。运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>阅读摘要</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manim学习--Mobject类(一)</title>
    <link href="/2020/03/30/manim-xue-xi-mobject-lei/"/>
    <url>/2020/03/30/manim-xue-xi-mobject-lei/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Mobject所派生的子类"><a href="#1-Mobject所派生的子类" class="headerlink" title="1. Mobject所派生的子类"></a>1. Mobject所派生的子类</h2><p><img src="Mobject-1586013786368.png" srcset="/img/loading.gif" alt="Mobject"></p><h2 id="2-Mobject的主要变量与属性"><a href="#2-Mobject的主要变量与属性" class="headerlink" title="2. Mobject的主要变量与属性"></a>2. Mobject的主要变量与属性</h2><h3 id="2-1-CONFIG"><a href="#2-1-CONFIG" class="headerlink" title="2.1 CONFIG"></a>2.1 CONFIG</h3><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"color"</span>: WHITE,        <span class="hljs-string">"name"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"dim"</span>: <span class="hljs-number">3</span>,        <span class="hljs-string">"target"</span>: <span class="hljs-literal">None</span>,    }</code></pre><h3 id="2-2-init-函数"><a href="#2-2-init-函数" class="headerlink" title="2.2 __init__()函数:"></a>2.2 <code>__init__()</code>函数:</h3><ul><li><p><code>submobjects = []</code>:每个Mobject都有自己的submobjects列表,列表里面的每个元素也是Mobject,这样有利于对嵌套的Mobject进行整体操作,如对一群图形一起平移等等动画的实现</p></li><li><p><code>updaters = []</code>:一系列的更新函数组成,如:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_text</span><span class="hljs-params">(obj)</span>:</span>           obj.next_to(dot,RIGHT,buff=SMALL_BUFF)</code></pre><p>就可以作为一个updater,有<code>add_updater()</code>方法进行添加:</p><pre><code class="hljs python"><span class="hljs-comment"># author:TB,由于3b1b的函数有改进,本代码进行了修改</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddUpdater</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        dot = Dot()        text = TextMobject(<span class="hljs-string">"Label"</span>).next_to(dot,RIGHT,buff=SMALL_BUFF)        self.add(dot,text)        <span class="hljs-comment"># Update function 更新函数</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_text</span><span class="hljs-params">(obj)</span>:</span>            obj.next_to(dot,RIGHT,buff=SMALL_BUFF)        <span class="hljs-comment"># Add update function to the objects</span>        <span class="hljs-comment"># 把更新函数加给对象</span>        text.add_updater(update_text)                <span class="hljs-comment"># 如果想简洁，lambda表达式如下：</span>        <span class="hljs-comment"># text.add_updater(lambda m: m.next_to(dot,RIGHT,buff=SMALL_BUFF))</span>        <span class="hljs-comment"># 此时下面的remove_updater(update_text)不能继续使用，需要改为clear_updaters</span>                self.play(dot.shift,UP*<span class="hljs-number">2</span>)        <span class="hljs-comment"># Remove update function</span>        text.remove_updater(update_text)        self.wait()</code></pre><p>效果如下:</p><p><img src="AddUpdater-1586013786369.gif" srcset="/img/loading.gif" alt="AddUpdater"></p><p>详细见下面3.3.2的介绍</p></li><li><p><code>updating_suspended = False</code>:是否暂停更新</p></li><li><p><code>points = np.zeros((0, self.dim))</code>:坐标,默认为原点,维度由属性<code>dim</code>决定</p></li></ul><h3 id="2-3-其他函数里面产生的变量"><a href="#2-3-其他函数里面产生的变量" class="headerlink" title="2.3 其他函数里面产生的变量"></a>2.3 其他函数里面产生的变量</h3><ul><li><code>saved_state</code>:自己的一份备份,可以用来恢复之前的状态</li><li><code>array_attr</code>:初始为<code>["points"]</code>列表</li><li><code>z_index_group</code>:暂时不知道有什么用</li></ul><h3 id="2-4-Mobject的一些抽象概念"><a href="#2-4-Mobject的一些抽象概念" class="headerlink" title="2.4 Mobject的一些抽象概念"></a>2.4 Mobject的一些抽象概念</h3><ul><li><p>family:如果将Mobject看作父节点,submobjects列表中的Mobject看作子节点,则对每个Mobjects都会产生一棵树,这个树里面的所有节点成为这个Mobject的family</p><p>family没有真正的实体,但是Mobject内有一个函数叫<code>get_family()</code>可以返回这个概念:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_family</span><span class="hljs-params">(self)</span>:</span>    <span class="hljs-comment"># 如果对map函数不理解,请自行查找Python map()函数</span>        <span class="hljs-comment"># 递归得到submobjects,代码非常简洁</span>        sub_families = list(map(Mobject.get_family, self.submobjects))        <span class="hljs-comment"># 使用chain的原因是可能每个submobject可能是不同的类型</span>        all_mobjects = [self] + list(it.chain(*sub_families))        <span class="hljs-comment"># 去重</span>        <span class="hljs-keyword">return</span> remove_list_redundancies(all_mobjects)</code></pre><p>Mobject的很多函数也用到了这个概念</p></li></ul><h3 id="2-5-Mobject的属性"><a href="#2-5-Mobject的属性" class="headerlink" title="2.5 Mobject的属性"></a>2.5 Mobject的属性</h3><ol><li><p>自身可迭代</p><p>假如有Mobject变量mob,则mob[0]是self本身,mob[1]以及更大的索引是subMobject</p></li><li><p>自身有长度</p><p>自身长度为submobject列表长度+1</p></li></ol><h2 id="3-Mobject的主要方法"><a href="#3-Mobject的主要方法" class="headerlink" title="3. Mobject的主要方法"></a>3. Mobject的主要方法</h2><h3 id="3-1-属性的处理"><a href="#3-1-属性的处理" class="headerlink" title="3.1 属性的处理"></a>3.1 属性的处理</h3><ol><li><p><code>reset_points()</code></p><p>self.points = np.zeros((0, self.dim))</p></li><li><p><code>add(*mobjects)</code></p><p>将自己的submobjects列表中加入mobjects</p><p><strong>注意:不能加入自己</strong></p></li><li><p><code>add_to_back(*mobjects)</code></p><p>将自己的submobjects列表末尾加入mobjects</p><p><strong>注意:如果加入的mobjects中有的在自己的列表中已经存在,则按照加入的mobjects顺序存放</strong></p></li><li><p><code>remove(*mobjects)</code></p><p>submobjects列表移除对应的mobjects</p><p><strong>注意:如果mobjects某些元素不在submobjects列表则不会有任何反应</strong></p></li><li></li></ol><h3 id="3-2-图像静态显示"><a href="#3-2-图像静态显示" class="headerlink" title="3.2 图像静态显示"></a>3.2 图像静态显示</h3><ol><li><p><code>get_image(camera=None)</code></p><p>根据传入的camera类对应的参数(如角度,距离等等)返回一个图像(以PIL.Image的格式)</p><p><strong>注意:应该用不到这个(如果不是自己开发代码)</strong></p></li><li><p><code>show(camera=None)</code></p><p>无动画根据传入的camera类对应的参数(如角度,距离等等)显示自己</p></li><li><p><code>save_image(name=None)</code></p><p>将自己图像保存到宏定义<code>VIDEO_DIR</code>位置,名字为<code>name</code>如果未传入名字,则默认名字为自己的str方法得到的数值</p></li><li><p><code>deepcopy()</code></p></li></ol><p>返回一个自己的副本,副本的改变与不会影响到自己</p><ol><li><code>copy()</code></li></ol><p>浅拷贝,与深拷贝对应</p><ol><li><code>generate_target(use_deepcopy=False)</code></li></ol><h3 id="3-3-更新-跟踪-函数"><a href="#3-3-更新-跟踪-函数" class="headerlink" title="3.3 更新(跟踪)函数"></a>3.3 更新(跟踪)函数</h3><ol><li><p>$ ^{^*}$<code>update(dt=0, recursive=True)</code></p><p><em>底层函数,一般制作的时候用不到,但是仍然列举出来以备不时之需</em></p><ul><li><p>参数含义</p><p><code>dt</code>:每帧运动速率是多少</p><p><code>recursive</code>:递归进行submobjects列表的Mobject的<code>update</code>函数</p></li><li><p>执行过程</p><p>如果updaters的某一项<code>update_function</code>列表里面有参数<code>dt</code>,则执行update_function(dt),否则执行update_function(),并根据recursive判断是否递归到submobjects列表中的每一项</p></li></ul></li><li><p><code>get_updaters()</code>:</p><p>得到updaters[]</p></li><li><p><code>get_family_updaters()</code>:</p><p>得到family的所有updaters</p></li><li><p><code>add_updater(update_function, index=None, call_updater=True)</code></p><ul><li><p>参数含义</p><p><code>update_function</code>:更新函数</p><p><code>index</code>:更新函数的索引</p><p><code>call_updater</code>:我也不知道这个有啥用(¦3[▓▓],3b1b的代码也没找到一个用过这个参数的</p><p><em>TODO:<code>call_updater</code>什么意思,欢迎留言</em></p></li><li><p>执行过程</p><p>将自己的<code>updaters</code>列表加入<code>update_function</code>,位置在<code>index</code>,插入方法同python列表的insert方法,并决定是否立即执行</p><p>例子:</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdateFunctionWithDt</span><span class="hljs-params">(Scene)</span>:</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>         sun = Dot(color=RED).scale(<span class="hljs-number">3</span>)          earthOrbit=Circle(color=WHITE).scale(<span class="hljs-number">2</span>)         earth=Dot(color=BLUE).scale(<span class="hljs-number">2</span>)         earth.move_to(earthOrbit.point_from_proportion(<span class="hljs-number">0</span>))         self.earthOffset=<span class="hljs-number">0</span>          moonOrbit= Circle(color=WHITE).move_to(earth)         moon =Dot(color=YELLOW)         moon.move_to(moonOrbit.point_from_proportion(<span class="hljs-number">0</span>))         self.moonOffset=<span class="hljs-number">0</span>          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_earth</span><span class="hljs-params">(mob,dt)</span>:</span>             rate=dt*<span class="hljs-number">0.1</span>             mob.move_to(earthOrbit.point_from_proportion((self.earthOffset + rate)%<span class="hljs-number">1</span>))             self.earthOffset += rate          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_moonOrbit</span><span class="hljs-params">(mob)</span>:</span>             mob.move_to(earth)          <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_moon</span><span class="hljs-params">(mob,dt)</span>:</span>             rate=dt*<span class="hljs-number">0.2</span>             mob.move_to(moonOrbit.point_from_proportion((self.moonOffset + rate)%<span class="hljs-number">1</span>))             self.moonOffset += rate          earth.add_updater(update_earth)         moonOrbit.add_updater(update_moonOrbit)         moon.add_updater(update_moon)         self.add(earthOrbit,moonOrbit,sun,earth,moon)         self.wait(<span class="hljs-number">5</span>)         self.wait()</code></pre><p>效果如下:</p><p><img src="UpdateFunctionWithDt-1586013786369.gif" srcset="/img/loading.gif" alt="UpdateFunctionWithDt"></p><p>dt的决定速度:</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhatIsDt</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        sun = Dot(color=RED).scale(<span class="hljs-number">3</span>)        earthOrbit=Circle(color=WHITE).scale(<span class="hljs-number">2</span>)        earths = [Dot(color=i).scale(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>[RED,BLUE]]        earths = VGroup(*earths)        earths.move_to(earthOrbit.point_from_proportion(<span class="hljs-number">0</span>))        self.earthOffsets = [<span class="hljs-number">0</span>]*<span class="hljs-number">2</span>        texts = VGroup(*[Text(<span class="hljs-string">"dt*0.%d"</span>%i,size=<span class="hljs-number">0.5</span>,font=<span class="hljs-string">"Lucida Console"</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]])        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_earth_factory</span><span class="hljs-params">(index)</span>:</span>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_earth</span><span class="hljs-params">(mob,dt)</span>:</span>                rate = dt*<span class="hljs-number">0.1</span>*(index+<span class="hljs-number">1</span>)                mob.move_to(earthOrbit.point_from_proportion((self.earthOffsets[index] + rate)%<span class="hljs-number">1</span>))                self.earthOffsets[index] += rate            <span class="hljs-keyword">return</span> update_earth                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_text_factory</span><span class="hljs-params">(index)</span>:</span>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_text</span><span class="hljs-params">(mob)</span>:</span>                mob.next_to(earths[index],LEFT,SMALL_BUFF)            <span class="hljs-keyword">return</span> update_text               <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]:            earths[i].add_updater(update_earth_factory(i))            texts[i].add_updater(update_text_factory(i))        self.add(earthOrbit,sun,earths,texts)        self.wait(<span class="hljs-number">5</span>)</code></pre><p><img src="WhatIsDt-1586013786370.gif" srcset="/img/loading.gif" alt="WhatIsDt"></p></li></ul></li><li><p><code>remove_updater(update_function)</code>:</p><p>很明显与<code>add_updater</code>相反</p></li><li><p><code>clear_updaters(recursive=True)</code>:</p><p>清除所有的<code>update_function</code>,如果<code>recursive</code>为<code>True</code>则submobjects列表的所有<code>update_function</code>清除</p><p><strong>存疑:<code>recursive</code>为<code>True</code>貌似如果subMobjects里面还套有subMobjects,则内层的不能被清除?</strong></p></li><li><p><code>match_updaters(mobject)</code>:</p><p>将mobject的updater全部复制给自己(自己的原来的updaters失效)</p></li><li><p><code>suspend_updating(recursive=True)</code>:</p><p>略</p></li><li><p><code>resume_updating(recursive=True)</code></p><p>略</p></li><li><p><code>get_time_based_updaters()</code>:</p><p>得到参数含有<code>dt</code>的updater</p></li><li><p><code>has_time_based_updater()</code>:</p><p>有参数含有<code>dt</code>的updater</p></li></ol><h3 id="3-4-变换函数"><a href="#3-4-变换函数" class="headerlink" title="3.4 变换函数"></a>3.4 变换函数</h3><ol><li><p><code>apply_to_family(func)</code>:</p><p>对每个家庭成员实行func函数</p></li><li><p><code>shift(*vectors)</code>:</p><p>平移,vector的维数为dim,如果输入多个vector则平移的终点为这几个vector的向量和</p><p>如<code>.shift(UP*2,LEFT)</code>和<code>shift(UP*2+LEFT)</code>是一个效果</p></li><li><p><code>scale(scale_factor, **kwargs)</code>:</p><ul><li><p>参数:</p><p><code>scale_factor</code>:缩放因子</p><p><code>**kwargs</code>:</p><p>默认行为是围绕mobject的中心进行缩放。参数about_edge可以是向量，指要围绕mobject的哪一侧进行缩放,否则，如果给about_point一个值，则相对于该点进行缩放。</p><ul><li><p><code>about_edge</code>:相对边</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddUpdater</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        circles = [Circle(arc_center = LEFT*i*<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)]        vg = VGroup(*circles)        line = Line(np.array([<span class="hljs-number">-10</span>,vg.get_top()[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>]),np.array([<span class="hljs-number">10</span>,vg.get_top()[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>]))        text = TextMobject(<span class="hljs-string">"about\_edge"</span>)        text.next_to(line,UP,buff=SMALL_BUFF)        self.add(line,vg,text)        self.play(vg.scale,<span class="hljs-number">2</span>,{<span class="hljs-string">"about_edge"</span>:UP})        self.wait()</code></pre><p><img src="about_edge-1586013786370.gif" srcset="/img/loading.gif" alt="about_edge"></p><p>如果<code>about_edge</code>为方向的线性组合,则会按照对应的边进行阻隔,以UP+RIGHT为例子:</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddUpdater</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        circles = [Circle(arc_center = LEFT*i*<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)]        vg = VGroup(*circles)        line = Line(np.array([<span class="hljs-number">-10</span>,vg.get_top()[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>]),np.array([<span class="hljs-number">10</span>,vg.get_top()[<span class="hljs-number">1</span>],<span class="hljs-number">0</span>]))        line1 = Line(np.array([vg.get_right()[<span class="hljs-number">0</span>],<span class="hljs-number">-10</span>,<span class="hljs-number">0</span>]),np.array([vg.get_right()[<span class="hljs-number">0</span>],<span class="hljs-number">10</span>,<span class="hljs-number">0</span>]))        text = TextMobject(<span class="hljs-string">"about\_edge1"</span>)        text.next_to(line,UP,buff=SMALL_BUFF)        text1 = TextMobject(<span class="hljs-string">"about\_edge2"</span>)        text1.next_to(line1,RIGHT,buff=SMALL_BUFF)        self.add(line,line1,vg,text,text1)        self.play(vg.scale,<span class="hljs-number">2</span>,{<span class="hljs-string">"about_edge"</span>:np.array(UP+RIGHT)})        self.wait()</code></pre><p><img src="UP_RIGHT-1586013786370.gif" srcset="/img/loading.gif" alt="UP_RIGHT"></p></li><li><p><code>about_point</code>:相对点</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddUpdater</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        circles = [Circle(arc_center = LEFT*i*<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)]        vg = VGroup(*circles)        dot = Dot(point=circles[<span class="hljs-number">0</span>].get_center())        text = TextMobject(<span class="hljs-string">"about\_point"</span>)        text.next_to(dot,DOWN,buff=SMALL_BUFF)        self.add(dot,vg,text)        self.play(vg.scale,<span class="hljs-number">2</span>,{<span class="hljs-string">"about_point"</span>:dot.get_center()})        self.wait()</code></pre><p><img src="about_point-1586013786370.gif" srcset="/img/loading.gif" alt="about_point"></p></li></ul></li><li><p>执行过程</p><p>放大或缩小指定的因子</p></li></ul></li><li><p><code>rotate(angle, axis=OUT, **kwargs)</code>:</p><p>学过初中物理就应该知道右手定则,在数学,物理中,旋转的方向就是右手定则中的(大拇指)方向</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myRotateScene</span><span class="hljs-params">(ThreeDScene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>     dot = Dot()        text = TextMobject(<span class="hljs-string">"about\_point"</span>,color=RED)        text.next_to(dot,DOWN,buff=SMALL_BUFF)        axes = ThreeDAxes()        self.add(dot,text,axes)        self.set_camera_orientation(theta=-PI/<span class="hljs-number">4</span>,phi=PI/<span class="hljs-number">4</span>)                   self.play(text.rotate,PI/<span class="hljs-number">2</span>,{<span class="hljs-string">"axis"</span>:OUT})        self.wait()</code></pre><p><img src="Rotate-1586013786370.gif" srcset="/img/loading.gif" alt="Rotate"></p><p>上图text的起始平面是X-Y平面,UP为y轴正方向,大家可以自行尝试更改axis方向(注意self.play函数不代表角度从0到PI/2的渐近变化所以只要看起始帧和终止帧)</p><p><code>**kwargs</code>还可以接受相对点<code>about_point</code>:</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myRotateScene</span><span class="hljs-params">(ThreeDScene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        dot = Dot()        text = TextMobject(<span class="hljs-string">"about\_point"</span>,color=RED)        text.next_to(dot,DOWN,buff=SMALL_BUFF)        axes = ThreeDAxes()        self.add(dot,text,axes)        self.set_camera_orientation(theta=-PI/<span class="hljs-number">4</span>,phi=PI/<span class="hljs-number">4</span>)                   self.play(text.rotate,PI,{<span class="hljs-string">"axis"</span>:OUT,<span class="hljs-string">"about_point"</span>:dot.get_center()})        self.wait()</code></pre><p>这个相对点旋转其实是线性代数里面的旋转矩阵造成的结果,如果角度是180度,效果是关于这个点对称</p><p><img src="rotateAboutPoint-1586013786370.gif" srcset="/img/loading.gif" alt="rotateAboutPoint"></p></li><li><p><code>flip(axis=UP, **kwargs)</code>:</p><p>翻转,其实就是<code>rotate</code>180度,其他参数同<code>rotate</code></p></li><li><p><code>stretch(factor, dim, **kwargs)</code>:</p><p>在对应的维度伸缩<code>factor</code>倍</p><p>这个函数与<code>scale</code>的用法一样,也会有<code>about_point</code>和<code>about_edge</code></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stretch</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        text = Text(<span class="hljs-string">"stretch"</span>)        self.play(text.stretch,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)        self.wait(<span class="hljs-number">2</span>)</code></pre></li><li><p><code>apply_function(function, **kwargs)</code>:</p><p>对所有family成员的点坐标都进行<code>function</code>处理,所以function必须是一个处理一个点的函数</p><p>例如对于二维图形:</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myScene</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self,point)</span>:</span>        <span class="hljs-keyword">return</span> point*<span class="hljs-number">2</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        circle = Circle()        circle2 = Circle()        self.add(circle,circle2)          circle.apply_function(self.func)        self.play(Write(circle))        self.wait()</code></pre><p>默认的<code>about_point</code>为<code>ORIGIN</code>,可以看出来实现了<code>apply_function</code>的会大一倍</p><p><img src="applyFunc-1586013786370.gif" srcset="/img/loading.gif" alt="applyFunc"></p></li><li><p><code>apply_function_to_position(function)</code>:</p><p>移动图像中心到function(self.get_center())</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myWag</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x2</span><span class="hljs-params">(self,x)</span>:</span>        <span class="hljs-keyword">return</span> x*<span class="hljs-number">2</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        circle = Circle()        circle.move_to(RIGHT)        self.add(circle)        self.play(circle.apply_function_to_position,{<span class="hljs-string">"function"</span>:self.x2})        self.wait()</code></pre></li><li><p><code>apply_function_to_submobject_positions(function)</code>:</p><p>略</p></li><li><p><code>apply_matrix(matrix, **kwargs)</code>:</p><p><code>matrix</code>为变换矩阵,这个就是对Mobject点对应的向量乘以<code>matrix</code>变换矩阵,学过线性代数或者计算机视觉或者看过3b1b的线性代数的人应该不陌生</p></li><li><p><code>apply_complex_function(function, **kwargs)</code>:</p><p>同理于<code>apply_function(function, **kwargs)</code>,只不过这里的<code>function</code>接受一个平面复数,即<code>complex(x, y)</code></p></li><li><p><code>wag(direction=RIGHT, axis=DOWN, wag_factor=1.0)</code>:</p><p>分析源码得到如下处理步骤:</p><ol><li><p>对所有含有坐标属性家庭成员进行步骤2到5的操作</p></li><li><p>向axis对应维度投影,如axis=UP/DOWN则向y轴投影,即保留y值不变,得到对应维度的向量列表alphas</p></li><li><p>将向量列表alphas归一化到[0,1],归一方法如下:</p><script type="math/tex; mode=display">\vec{alphas'}_i = \frac{\vec{alphas}_i-min(\vec{alphas})}{max(\vec{alphas})-min(\vec{alphas})}</script></li><li><p>执行幂运算</p><script type="math/tex; mode=display">\vec{alphas}_i^{"}=(\vec{alphas'})^{wag\_factor}</script></li><li><p>每个点在direction方向平移$\vec{alphas}_i^{“}$</p></li></ol><p>例子:</p><p>factor=1</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myWag</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        squares = [Square() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>):            squares[<span class="hljs-number">1</span>+i].move_to(RIGHT*<span class="hljs-number">3</span>*i)        self.add(*squares)         self.play(squares[<span class="hljs-number">0</span>].wag,{<span class="hljs-string">"direction"</span>:UP,<span class="hljs-string">"axis"</span>:RIGHT,<span class="hljs-string">"wag_factor"</span>:<span class="hljs-number">0.1</span>},                  squares[<span class="hljs-number">1</span>].wag,{<span class="hljs-string">"direction"</span>:UP,<span class="hljs-string">"axis"</span>:RIGHT,<span class="hljs-string">"wag_factor"</span>:<span class="hljs-number">1</span>},                  squares[<span class="hljs-number">2</span>].wag,{<span class="hljs-string">"direction"</span>:UP,<span class="hljs-string">"axis"</span>:RIGHT,<span class="hljs-string">"wag_factor"</span>:<span class="hljs-number">2</span>})        self.wait()</code></pre><p><img src="myWag1-1585643241928-1586013786370.gif" srcset="/img/loading.gif" alt="myWag1"></p><p>从左到右factor依次为0.1,1,2,都是向上wag的,具体怎么理解大家可以自己理解,比较难以表述</p></li><li><p><code>reverse_points()</code>:</p><p>调换点的顺序:</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myWag</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        circle = Circle().scale(<span class="hljs-number">2</span>)        texts = [TextMobject(<span class="hljs-string">"p"</span>+str(i)).scale(<span class="hljs-number">0.5</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(circle.points))]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_factory</span><span class="hljs-params">(index)</span>:</span>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_func</span><span class="hljs-params">(mob)</span>:</span>                mob.move_to(circle.points[index])            <span class="hljs-keyword">return</span> update_func        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(texts)):            texts[i].add_updater(update_factory(i))        self.add(circle,*texts)        self.wait(<span class="hljs-number">1</span>)        self.play(circle.reverse_points)        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="ReversePoint-1586013786371.gif" srcset="/img/loading.gif" alt="ReversePoint"></p><p>注意play函数不能很好表现reverse的现象,如果看顺序,上图顺序从逆时针变成了顺时针</p></li><li><p><code>repeat(count)</code>:</p><p>会出现重影的特效</p><p><img src="Repeat-1586013786371.gif" srcset="/img/loading.gif" alt="Repeat"></p></li><li><p><code>apply_points_function_about_point(func, about_point=None, about_edge=None)</code>:</p><p>相对点或边对自己的所有点左边应用函数</p></li></ol><h3 id="3-5-位置函数"><a href="#3-5-位置函数" class="headerlink" title="3.5 位置函数"></a>3.5 位置函数</h3><ol><li><p><code>center()</code>:</p><p>此处center为动词:到中心</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Repeat</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        square = Square()        dot=Dot()        self.add(square,dot)        self.play(square.shift,RIGHT)        self.play(square.shift,RIGHT)        self.play(square.shift,UP)        self.play(square.center)        self.wait()</code></pre><p><img src="Center-1586013786371.gif" srcset="/img/loading.gif" alt="Center"></p></li><li><p><code>align_on_border(direction, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER)</code>:</p><p>在边界对齐,buff为和边界的距离</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Align</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        square = Square()        self.play(square.align_on_border,LEFT+UP)        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="Align-1586013786371.gif" srcset="/img/loading.gif" alt="Align"></p></li><li><p><code>to_corner(corner=LEFT + DOWN, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER)</code>:</p><p>到某一个角</p><p><img src="to-1586013786371.png" srcset="/img/loading.gif" alt="to_corner author:Elteoremadebeethoven"></p></li><li><p><code>to_edge(edge=LEFT, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER)</code>:</p><p>到某一边</p></li><li><p><code>next_to(mobject_or_point,direction=RIGHT, buff=DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,aligned_edge=ORIGIN,submobject_to_align=None,index_of_submobject_to_align=None, coor_mask=np.array([1, 1, 1]),)</code>:</p><p>参数分析:</p><ul><li><code>mobject_or_point</code>:Mobject或者一个点坐标</li><li><code>direction</code>:方向</li><li><code>buff</code>:相聚的距离</li><li><code>aligned_edge</code>:对齐的边</li><li><code>submobject_to_align</code>:对齐的子Mobject,此参数要求Mobject是一个列表性质的Mobject</li><li><code>index_of_submobject_to_align</code>:如果<code>submobject_to_align</code>不为空,则需要指定对应的是哪一个Mobject</li></ul></li></ol><ul><li><code>coor_mask</code>:掩膜,术语来自数字信号处理/数字图像处理,不懂可以自行搜索,在这里即为1的地方才进行next_to,如果为0,则对应的坐标不进行next_to变换</li></ul><p>执行过程:</p><p>   如果<code>mobject_or_point</code>是点则next_to的对象就是点,否则为由参数决定的Mobject的中心</p><ol><li><p><code>shift_onto_screen(**kwargs)</code>:</p></li><li><p><code>is_off_screen()</code>:</p><p>是否超出屏幕范围</p></li><li><p><code>rescale_to_fit(length, dim, stretch=False, **kwargs)</code>:</p><p>将某一个方向的长度拉伸至length,可以按照scale方式拉长或者stretch方式拉长</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RescaleToFit</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        ellipse = Ellipse()        length = ellipse.length_over_dim(<span class="hljs-number">0</span>)        self.play(ellipse.rescale_to_fit,length,<span class="hljs-number">1</span>,{<span class="hljs-string">"stretch"</span>:<span class="hljs-literal">True</span>})        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="RescaleToFit-1586013786371.gif" srcset="/img/loading.gif" alt="RescaleToFit"></p><ul><li><code>stretch_to_fit_width(width, **kwargs)</code></li><li><code>stretch_to_fit_height(height, **kwargs)</code></li><li><code>stretch_to_fit_depth(depth, **kwargs)</code></li><li><code>set_width(width, stretch=False, **kwargs)</code></li><li><code>set_height(height, stretch=False, **kwargs)</code></li><li><code>set_depth(depth, stretch=False, **kwargs)</code></li></ul></li><li><p><code>set_coord(value, dim, direction=ORIGIN)</code>:</p><p>将dim对应的坐标设置为value,direction表示设置什么的坐标,如direction为RIGHT则表示设置图像的最右端点的dim维度的坐标为value</p><ul><li><code>set_x(x, direction=ORIGIN)</code></li><li><code>set_y(y, direction=ORIGIN)</code></li><li><code>set_z(z, direction=ORIGIN)</code></li></ul></li><li><p><code>space_out_submobjects(factor=1.5, **kwargs)</code>:</p><p>自己scale factor倍,子mobject缩小1/factor倍</p></li><li><p><code>move_to(point_or_mobject, aligned_edge=ORIGIN,coor_mask=np.array([1, 1, 1]))</code>:</p><p>与next_to相近,不过区别是:next_to表示的是边界的距离，而不是中心距离</p><p><img src="move_next_to-1586013786372.png" srcset="/img/loading.gif" alt="move_next_to author:Elteoremadebeethoven"></p></li><li><p><code>replace(mobject, dim_to_match=0, stretch=False)</code>:</p><p>将位置移动到mobject,并且大小做一些改变,具体看源码</p></li><li><p><code>surround(mobject,dim_to_match=0,stretch=False,buff=MED_SMALL_BUFF)</code>:</p><p>包围(默认情况下,等边长的正多边形规则物体效果很好,对于不等变长的形状最好启用stretch)</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Surround</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        circle = Circle()        square = Square().shift(UP*<span class="hljs-number">2</span>)        self.add(circle,square)        self.play(circle.surround,square)        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="Surround-1586013786372.gif" srcset="/img/loading.gif" alt="Surround"></p></li><li><p><code>put_start_and_end_on(start, end)</code>:</p><p>将起点终点重置为start,end</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PutStartAndEndOn</span><span class="hljs-params">(Scene)</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        arc = Arc(PI/<span class="hljs-number">3</span>)        texts = [TexMobject(i,color=RED) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-string">"startPoint"</span>,<span class="hljs-string">"endPoint"</span>]]        texts[<span class="hljs-number">0</span>].add_updater(<span class="hljs-keyword">lambda</span> x: x.move_to(arc.get_start()))        texts[<span class="hljs-number">1</span>].add_updater(<span class="hljs-keyword">lambda</span> x: x.move_to(arc.get_end()))        self.add(arc, *texts)        self.play(arc.put_start_and_end_on,ORIGIN,(UP+RIGHT)*<span class="hljs-number">2</span>)        self.wait()</code></pre><p><img src="PutStartAndEndOn-1586013786372.gif" srcset="/img/loading.gif" alt="PutStartAndEndOn"></p></li><li><p><code>add_background_rectangle(color=BLACK, opacity=0.75, **kwargs)</code>:</p><p>增加背景方块,此方块是可以随着Mobject变化而变化的</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BackgroundRectangle</span><span class="hljs-params">(Scene)</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        circle = Circle(color=RED)        circle.add_background_rectangle(color=BLUE,opacity=<span class="hljs-number">0.4</span>)        self.add(circle)        self.play(circle.stretch,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)        self.wait()</code></pre><p><img src="BackgroundRectangle-1586013786372.gif" srcset="/img/loading.gif" alt="BackgroundRectangle"></p></li><li><p><code>add_background_rectangle_to_submobjects(**kwargs)</code>:</p><p>略</p></li><li><p><code>add_background_rectangle_to_family_members_with_points(**kwargs)</code>:</p><p>略</p></li></ol><h3 id="3-6-颜色函数"><a href="#3-6-颜色函数" class="headerlink" title="3.6 颜色函数"></a>3.6 颜色函数</h3><ol><li><p><code>set_color(color=YELLOW_C, family=True)</code>:</p><p>设置颜色,family指家庭成员是否也跟着变色</p></li><li><p><code>set_color_by_gradient(*colors)</code>:</p><p>渐变色,可以是两个或多个颜色的列表</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">main</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        qed = TexMobject(<span class="hljs-string">'This is a Text'</span>).scale(<span class="hljs-number">1.25</span>)        qed.set_color_by_gradient(RED,YELLOW,GREEN,BLUE)        self.play(Write(qed))        self.wait(<span class="hljs-number">3</span>)</code></pre><p><img src="image-20200403201147347-1586013786372.png" srcset="/img/loading.gif" alt="gradientColor"></p></li><li><p><code>set_colors_by_radial_gradient(center=None, radius=1, inner_color=WHITE, outer_color=BLACK)</code>:</p><p>辐射状渐变颜色,半径为radius</p></li><li><p><code>set_submobject_colors_by_gradient(*colors)</code>:</p><p>给子Mobject设置渐变颜色</p></li><li><p><code>set_submobject_colors_by_radial_gradient(center=None, radius=1, inner_color=WHITE, outer_color=BLACK)</code>:</p><p>同理,略</p></li><li><p><code>fade_to(color, alpha, family=True)</code>:</p><p>褪色为某一个颜色,alpha为插值系数,alpha在[0,1]之间,越接近1,褪色越厉害</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FadeTo</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        text = TexMobject(<span class="hljs-string">"This is a Text"</span>)        self.add(text)        self.play(text.set_colors_by_radial_gradient,{<span class="hljs-string">"inner_color"</span>:WHITE,<span class="hljs-string">"outer_color"</span>:RED})        self.play(text.fade_to,BLUE,<span class="hljs-number">1</span>)        self.wait()</code></pre><p><img src="FadeTo-1586013786373.gif" srcset="/img/loading.gif" alt="FadeTo"></p></li><li><p><code>get_color()</code>:</p><p>返回颜色</p></li><li><p><code>fade(darkness=0.5, family=True)</code>:</p><p>褪色为黑色,darkness为灰度</p></li></ol><h3 id="3-7-恢复函数"><a href="#3-7-恢复函数" class="headerlink" title="3.7 恢复函数"></a>3.7 恢复函数</h3><ol><li><p><code>save_state(use_deepcopy=False)</code>:</p><p>保存状态,并确定是否使用深拷贝</p></li><li><p><code>restore()</code>:</p><p>恢复之前状态</p></li></ol><h3 id="3-8-其他的getter方法"><a href="#3-8-其他的getter方法" class="headerlink" title="3.8 其他的getter方法"></a>3.8 其他的getter方法</h3><ol><li><p><code>reduce_across_dimension(points_func, reduce_func, dim)</code>:</p></li><li><p><code>nonempty_submobjects()</code>:</p><p>返回Submobject的subSubMobject不为空的Submobject</p></li><li><p><code>get_merged_array(array_attr)</code>:</p><p>得到Mobject以及其子Mobject的array_attr属性的列表</p></li><li><p><code>get_all_points()</code>:</p><p>得到Mobject与其子Mobject属性所有的点</p></li><li><p><code>get_num_points()</code>:</p><p>得到自己的点的数量(不包含子Mobject)</p></li><li><p><code>get_extremum_along_dim(points=None, dim=0, key=0)</code>:</p><p>沿着dim方向(dim为0表示x方向,1表示y方向….),给出坐标的极值,key&lt;0表示得到最小值,key&gt;0表示得到最大值,key=0表示得到中值</p></li><li><p><code>get_critical_point(direction)</code>:</p><p>画一个框，框住mobject。 这样的盒子有9个“关键点”：4个角，4个边缘中心，中心。 这将返回其中之一。</p><p>direction什么方向就返回什么</p><p>对其进行封装有如下的函数:</p><ul><li><code>get_edge_center</code><ul><li><code>get_top</code></li><li><code>get_bottom</code></li><li><code>get_right</code></li><li><code>get_left</code></li><li><code>get_zenith</code></li><li><code>get_nadir</code></li></ul></li><li><code>get_corner</code></li><li><code>get_center</code></li></ul></li><li><p><code>get_boundary_point(direction)</code>:</p><p>得到某个方向的最远的点</p> <pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FadeTo</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        square = Square()        circle = Circle().shift(<span class="hljs-number">2</span> * RIGHT + <span class="hljs-number">1</span> * DOWN)        shapeGroup = VGroup(square,circle)        points = []        nums = <span class="hljs-number">10</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(nums):            points.append(shapeGroup.get_boundary_point(np.array((np.cos(<span class="hljs-number">2</span>*PI*i/nums),np.sin(<span class="hljs-number">2</span>*PI*i/nums),<span class="hljs-number">0</span>))))        polygon = Polygon(*points,color=BLUE)        dots = [Dot(point=i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> points]        self.add(shapeGroup,*dots)        self.play(Write(polygon))        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="image-20200404172800256-1586013786373.png" srcset="/img/loading.gif" alt="boundary_points"></p></li><li><p><code>length_over_dim(dim)</code>:</p><p>dim方向的长度</p><p>此方法封装的方法:</p><ul><li><code>get_width</code></li><li><code>get_height</code></li><li><code>get_depth</code></li></ul></li><li><p><code>get_coord(dim, direction=ORIGIN)</code>:</p><p>在dim方向得到direction对应的极值,直接使用意义不大</p><ul><li><code>get_x(direction=ORIGIN)</code></li><li><code>get_y(direction=ORIGIN)</code></li><li><code>get_z(direction=ORIGIN)</code></li></ul></li><li><p><code>get_start</code>,<code>get_end</code>,<code>get_start_and_end</code>:</p><p>得到点的起点终点,起点和终点</p></li><li><p><code>has_points</code>,<code>has_no_points</code>:</p><p>是否有点这属性</p></li></ol><h3 id="3-9-匹配函数"><a href="#3-9-匹配函数" class="headerlink" title="3.9 匹配函数"></a>3.9 匹配函数</h3><ol><li><p><code>match_color(mobject)</code>:</p><p>匹配mobject的颜色</p></li><li><p><code>match_dim_size(mobject, dim, **kwargs)</code>:</p><p>匹配dim方向的长度,<code>**kwargs</code>和<code>rescale_to_fit()</code>使用方法相同</p><ul><li><code>match_width</code></li><li><code>match_height</code></li><li><code>match_depth</code></li></ul></li><li><p><code>match_coord(mobject, dim, direction=ORIGIN)</code>:</p><p>按照get_coord()得到对应的Mobject坐标,然后设置</p><ul><li><code>match_x</code></li><li><code>match_y</code></li><li><code>match_z</code></li></ul></li></ol><h3 id="3-10-排列函数"><a href="#3-10-排列函数" class="headerlink" title="3.10 排列函数"></a>3.10 排列函数</h3><ol><li><p><code>arrange(direction=RIGHT, center=True, **kwargs)</code>:</p><p>submobject列表的全部变量进行排队,按照direction的方式排队,center决定了是否排完队跑到中心</p><p><code>**kwargs</code>参考next_to</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arrange</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        square = Square()        square.add(Dot(point=np.array([<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>])))        square.add(Square().move_to(np.array([<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])))        square.add(Circle().move_to(np.array([<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>])))        self.add(square)        self.play(square.arrange,{<span class="hljs-string">"center"</span>:<span class="hljs-literal">False</span>})        self.wait(<span class="hljs-number">2</span>)        self.play(square.arrange,{<span class="hljs-string">"direction"</span>:UP,<span class="hljs-string">"center"</span>:<span class="hljs-literal">False</span>})        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="Arrange-1586013786373.gif" srcset="/img/loading.gif" alt="Arrange"></p></li><li><p><code>arrange_in_grid(n_rows=None, n_cols=None, **kwargs)</code>:</p><p>对submobject列表重拍列</p><p>如果默认无参数,重拍列至方阵,否则n_rows和n_cols最多选一个,排列为对应的行或列,如果都填,则排列为n_rows行</p><p><code>**kwargs</code>参考next_to函数</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrangeInGrid</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        square = Square()        square.add(Circle().move_to(np.array([<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>])))        square.add(Circle().move_to(np.array([<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])))        square.add(Circle().move_to(np.array([<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>])))        square.add(Circle().move_to(np.array([<span class="hljs-number">5</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">0</span>])))        self.add(square)        self.play(square.arrange_in_grid)        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="ArrangeInGrid-1586013786373.gif" srcset="/img/loading.gif" alt="ArrangeInGrid"></p></li><li><p><code>sort(point_to_num_func=lambda p: p[0], submob_func=None)</code>:</p><p>对点进行排序,这个一般意义不大,可以自己编写排序方法</p></li><li><p><code>shuffle(recursive=False)</code>:</p><p>打乱submobject的列表排序,以及是否递归进行</p></li></ol><h3 id="3-11-对齐函数"><a href="#3-11-对齐函数" class="headerlink" title="3.11 对齐函数"></a>3.11 对齐函数</h3><ol><li><p><code>align_to(mobject_or_point, direction=ORIGIN, alignment_vect=UP)</code>:</p><p>对齐,direction表示对齐的边是哪边</p><p>mob1.align_to（mob2，UP）垂直移动mob1，以便其顶部边缘与mob2的顶部边缘对齐。 mob1.align_to（mob2，alignment_vect = RIGHT）水平移动mob1，使其中心位于mob2中心的正上方/正下方</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AlighTo</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        square = Square()        circle = Circle().shift(<span class="hljs-number">2</span> * RIGHT + <span class="hljs-number">1</span> * DOWN).scale(<span class="hljs-number">2</span>)        self.add(square,circle)        self.play(circle.align_to,square,RIGHT)        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="AlighTo-1586013786373.gif" srcset="/img/loading.gif" alt="AlighTo"></p></li><li><p><code>add_n_more_submobjects(n)</code>:</p><p>加入n个submoject</p></li></ol><h3 id="3-12-抽象方法"><a href="#3-12-抽象方法" class="headerlink" title="3.12 抽象方法"></a>3.12 抽象方法</h3><ol><li><p><code>align_data(mobject)</code>:</p></li><li><p><code>align_points(mobject)</code>:</p></li><li><p><code>align_submobjects(mobject)</code>:</p><p>对齐submobjects</p></li><li><p><code>null_point_align(mobject)</code>:</p></li><li><p><code>get_point_mobject(center=None)</code></p></li><li><p><code>align_points_with_larger(larger_mobject)</code></p></li><li><p><code>interpolate_color(mobject1, mobject2, alpha)</code>:</p><p>颜色插值</p></li><li><p><code>interpolate(mobject1,mobject2,alpha, path_func=straight_path)</code>:</p><p>Mobject插值</p></li><li><p><code>become_partial(mobject, a, b)</code>:</p><p>以仅成为mobject一部分的方式设置点。 输入0 &lt;= a &lt;b &lt;= 1确定要成为mobject的哪一部分。</p></li><li><p><code>become(mobject, copy_submobjects=True)</code>:</p><p>变成另一个的样式</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Become</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        square = Square()        square.submobjects.append(Circle().move_to(np.array([<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">0</span>])))        square.submobjects.append(Circle().move_to(np.array([<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])))        square.submobjects.append(Circle().move_to(np.array([<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>])))        square.submobjects.append(Circle().move_to(np.array([<span class="hljs-number">5</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">0</span>])))        text = Text(<span class="hljs-string">"text"</span>)        self.add(square)        self.play(square.become,text)        self.play(text.shift,UP)        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="Become-1586013786373.gif" srcset="/img/loading.gif" alt="Become"></p></li></ol><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>Mobject的用法还是很多的,空闲时间写了很多天才写完,希望自己能用熟练</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>manim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>manim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manim学习--Container类</title>
    <link href="/2020/03/30/manim-xue-xi-container-lei/"/>
    <url>/2020/03/30/manim-xue-xi-container-lei/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Container的派生类"><a href="#1-Container的派生类" class="headerlink" title="1. Container的派生类"></a>1. Container的派生类</h2><p><img src="Container.png" srcset="/img/loading.gif" alt="Container"></p><h2 id="2-container类的作用"><a href="#2-container类的作用" class="headerlink" title="2. container类的作用"></a>2. container类的作用</h2><p>代码注释有段话: 当前，这仅适用于Scene和Mobject.尽管如此，我们还是在这里抽象其功能，尽管纯粹是名义上的.目前，所有实现都必须由派生类处理。</p><p>上面的注释说明了3B1B正在规范代码,使代码的阅读者更好的读懂代码与自己创建代码分支</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>container类仅仅是一个抽象类,只有add和remove抽象方法,没有很大的实际用途,除非自己开发代码,不然不会用到这个类.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>manim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>manim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manim的主要绘图类</title>
    <link href="/2020/03/27/manim-de-zhu-yao-hui-tu-lei/"/>
    <url>/2020/03/27/manim-de-zhu-yao-hui-tu-lei/</url>
    
    <content type="html"><![CDATA[<p>manim的整体结构解析</p><h2 id="1-CONFIG是什么"><a href="#1-CONFIG是什么" class="headerlink" title="1. CONFIG是什么"></a>1. CONFIG是什么</h2><p>几乎任何的类都会有一个神奇的字典,叫<code>CONFIG</code>,这个字典的所有键值对都会被赋予给类的属性,原因是因为所有的绘图类都是继承自<strong>Container</strong>类(<em>位置:\manimlib\container\container.py</em>),这个类在初始化的时候执行代码如下:</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, **kwargs)</span>:</span>        digest_config(self, kwargs)</code></pre><p>而<em>digest_config</em>在<em>\manimlib\utils\config_ops.py</em>:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">digest_config</span><span class="hljs-params">(obj, kwargs, caller_locals={})</span>:</span>    <span class="hljs-string">"""</span><span class="hljs-string">    Sets init args and CONFIG values as local variables</span><span class="hljs-string"></span><span class="hljs-string">    The purpose of this function is to ensure that all</span><span class="hljs-string">    configuration of any object is inheritable, able to</span><span class="hljs-string">    be easily passed into instantiation, and is attached</span><span class="hljs-string">    as an attribute of the object.</span><span class="hljs-string">    </span><span class="hljs-string">    将初始化参数和CONFIG值设置为局部变量</span><span class="hljs-string">    </span><span class="hljs-string">&nbsp;&nbsp;&nbsp;&nbsp;此功能的目的是确保所有任何对象的配置都是可继承的，能够易于传</span><span class="hljs-string">&nbsp;&nbsp;&nbsp;&nbsp;递到实例化并附加作为对象的属性。</span><span class="hljs-string">    """</span>    <span class="hljs-comment"># Assemble list of CONFIGs from all super classes</span>    <span class="hljs-comment"># 将所有父类的CONFIG全部集中在static_configs</span>    classes_in_hierarchy = [obj.__class__]    static_configs = []    <span class="hljs-keyword">while</span> len(classes_in_hierarchy) &gt; <span class="hljs-number">0</span>:        Class = classes_in_hierarchy.pop()        classes_in_hierarchy += Class.__bases__        <span class="hljs-keyword">if</span> hasattr(Class, <span class="hljs-string">"CONFIG"</span>):            static_configs.append(Class.CONFIG)    <span class="hljs-comment"># Order matters a lot here, first dicts have higher priority</span>    <span class="hljs-comment"># 顺序很重要,字典的靠前的键值对有更高的优先级(即如果有相同的,覆盖后面的键值对)</span>    <span class="hljs-comment"># 优先级的处理是由merge_dicts_recursively函数处理的,具体自己读源代码</span>    caller_locals = filtered_locals(caller_locals)    all_dicts = [kwargs, caller_locals, obj.__dict__]    all_dicts += static_configs    obj.__dict__ = merge_dicts_recursively(*reversed(all_dicts))</code></pre><p>上面的英文解释已经很清楚了,一句话概括这个函数:将CONFIG这个字典中的内容变成类的属性.<br>值得注意的是:<strong>这个字典的一些键的值可以继续为CONFIG字典</strong></p><h2 id="2-主要类图"><a href="#2-主要类图" class="headerlink" title="2. 主要类图"></a>2. 主要类图</h2><p>Container类图:</p><p><img src="Container.png" srcset="/img/loading.gif" alt="Container类图"></p><p>Mobject类图:</p><p><img src="Mobject.png" srcset="/img/loading.gif" alt="Mobject类图"></p><p>其中的VMobject类图:</p><p><img src="VMobject.png" srcset="/img/loading.gif" alt="VMobject类图"></p><p>Scene类图:</p><p><img src="Scene.png" srcset="/img/loading.gif" alt="Scene类图"></p><p>Camera类图:</p><p><img src="Camera.png" srcset="/img/loading.gif" alt="Camera类图"></p><p>Animation类图:</p><p><img src="Animation.png" srcset="/img/loading.gif" alt="Animation类图"></p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>时隔几个月,我又重新更新并看了一下manim的repo,这次我仅仅是粗略看了一下manim的结构,发现变化还是很明显的,相比几个月前的难以阅读,到现在几乎是很好阅读了.</p><p>我在此也对整个文件结构的所有类图内容扫描了一遍,发现整个代码里面几乎能想到的形式都有对应的类实现,有的类的继承实现甚至非常多余,因为就改了一两个参数,这几乎可以自己写,不过这manim本身目的就不是给公开使用,而是Grant Sanderson用来做视频的.</p><p>如果有时间我会对几个最基本的类进行解释,如果把最基本的类用法解释清楚接下来就可以很好的制作3b1b风格视频了.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>manim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>manim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机四级网络技术</title>
    <link href="/2020/03/26/ji-suan-ji-si-ji-wang-luo-ji-zhu/"/>
    <url>/2020/03/26/ji-suan-ji-si-ji-wang-luo-ji-zhu/</url>
    
    <content type="html"><![CDATA[<p>本文是对计算机四级知识点的整理摘要，覆盖大概90%的历年考试知识点，剩下的不多的计算题大家自行琢磨理解</p><h1 id="第一章-网络技术基础"><a href="#第一章-网络技术基础" class="headerlink" title="第一章 网络技术基础"></a>第一章 网络技术基础</h1><h3 id="1-1-2-计算机网络形成与ARPANET"><a href="#1-1-2-计算机网络形成与ARPANET" class="headerlink" title="1.1.2 计算机网络形成与ARPANET"></a>1.1.2 计算机网络形成与ARPANET</h3><p>美国国防高级研究计划局提出ARPANET研究计划</p><p>采取分组交换的思想，将ARPANET分为两个部分：<strong>通信子网与资源子网</strong></p><p>开始时，实验网络包含四个节点</p><p>在计算机网络发展的不同阶段，人们对计算机网络有不同的定义，这些定义主要分为三类：广义、资源共享与用户透明性。其中资源共享的定义符合当前计算机网络的基本特征，主要表现为三点：</p><p>（1）建立计算机网络的主要目的是<strong>实现计算机资源的共享</strong>；</p><p>（2）互联的计算机是分布在不同地理位置的多台独立的“自治计算机”，<strong>互联的计算机之间没有明确的主从关系</strong>。</p><p>（3）联网计算机之间的通信<strong>必须遵循共同的网络协议</strong>。</p><h3 id="1-2-2-计算机网络的分类"><a href="#1-2-2-计算机网络的分类" class="headerlink" title="1.2.2 计算机网络的分类"></a>1.2.2 计算机网络的分类</h3><div class="table-container"><table><thead><tr><th>0~10m</th><th>0~10m</th><th>10m~10km</th><th>50km~100km</th><th>10km~1000km</th></tr></thead><tbody><tr><td>个人区域网（WPAN）最有名的为蓝牙</td><td>个人局域网(PAN)</td><td>局域网(LAN)</td><td>城域网(MAN)</td><td>广域网(WAN)</td></tr><tr><td></td><td></td><td>10Mbps~100Gbps</td><td>45~150Mbps</td><td></td></tr><tr><td></td><td></td><td></td><td>FDDI,介质访问子层令牌环</td><td></td></tr><tr><td>IEEE 802.15</td><td></td><td></td><td>IEEE 802.6</td></tr></tbody></table></div><p>书中各种协议：</p><p><strong>IEEE 802又称为LMSC，致力于研究局域网和城域网的物理层和MAC层中定义的服务和协议，对应OSI网络参考模型的最低两层（数据链路层和物理层），它针对不同的传输介质定义不同的介质标准。</strong></p><p><strong>IEEE 802在介质访问控制（MAC）子层和物理层可以采用不同的协议，但是在逻辑链路控制（LLC）子层必须采用相同的协议，LLC子层与低层采用的传输介质，介质访问控制方法无关</strong></p><p><strong>IEEE 802.11</strong> 是无线局域网(WLAN)的介质访问控制协议以及物理层技术规范</p><p>IEEE 802.11标准采用的是层次结构模型，主要工作在OSI参考模型的最低两层：物理层和数据链路层。最初定义的三个物理层传输标准包括两个扩散频谱技术和一个红外传播规范。IEEE 802.11标准规定的MAC层是在一个共享媒体上支持多个用户共享资源，发送数据前需要进行<strong>冲突检测</strong>，访问控制支持<strong>无争用服务和争用服务两种</strong>方式。</p><div class="table-container"><table><thead><tr><th style="text-align:left">标准名称</th><th style="text-align:left">标准描述</th></tr></thead><tbody><tr><td style="text-align:left">802.11a</td><td style="text-align:left">5G Hz波段，速率54Mbps</td></tr><tr><td style="text-align:left">802.11b</td><td style="text-align:left">2.4G Hz波段，速率11Mbps</td></tr><tr><td style="text-align:left">802.11g</td><td style="text-align:left">2.4G Hz波段，速率54Mbps</td></tr><tr><td style="text-align:left">802.11n</td><td style="text-align:left">5G Hz波段，速率100Mbps</td></tr><tr><td style="text-align:left">802.11ac</td><td style="text-align:left">5G Hz波段，速率1Gbps</td></tr><tr><td style="text-align:left">802.11ad</td><td style="text-align:left">60G Hz波段，速率7Gbps</td></tr><tr><td style="text-align:left">802.11i</td><td style="text-align:left">增强无线通信安全的规范</td></tr><tr><td style="text-align:left">802.11e</td><td style="text-align:left">服务质量QoS</td></tr></tbody></table></div><p><strong>IEEE 802.1</strong>局域网体系结构，网络互联，以及网络管理与性能测试</p><p><strong>IEEE 802.11</strong> 是无线局域网(WLAN)的访问控制子层以及物理层技术规范</p><p><strong>IEEE 802.15</strong> 采用蓝牙技术（近距离）的无线个人网络技术规范</p><p><strong>IEEE802.16</strong> 定义<strong>宽带无线局域网</strong>介质访问 MAC 子层与物理层标准</p><p><strong>IEEE 802.2</strong>逻辑链路控制LLC子层功能与服务</p><p><strong>IEEE802.3</strong> 定义MAC层载波侦听多路访问 （CSMA/CD ） 介质访问控制子层与物理层标准</p><p><strong>IEEE802.4</strong> 定义了总线拓扑的令牌总线介质访问控制方法与相应的物理规范</p><p>无线局域网标准802.11的MAC和802.3协议的MAC不同，传统的Ethernet网帧的结构中有前导码和帧前定界符，而802.11标准中用帧控制单元代替。传统的Ethernet网的数据段长度是46B~1500B，而802.11帧中的数据段长度是0~2312B。传统的Ethernet网中帧的类型字段表示当前帧使用协议的类型，而802.11帧中类型字段用来表示当前帧是数据帧、管理帧或控制帧。这两种帧均工作在数据链路层，<strong>采用的地址是MAC地址。</strong></p><p>高速局域网技术：</p><div class="table-container"><table><thead><tr><th>标准</th><th>类型</th><th>速率</th></tr></thead><tbody><tr><td>IEEE802.3u</td><td>Fast Ethernet</td><td>100Mbps</td></tr><tr><td>IEEE802.3z</td><td>Gigabit Ethernet</td><td>1000Mbps</td></tr><tr><td>IEEE802.3ae</td><td>10 Gigabit Ethernet</td><td>10Gbps</td></tr><tr><td>IEEE802.3ba</td><td>40&amp;100 Gigabit Ethernet</td></tr></tbody></table></div><h3 id="1-2-3-计算机网络的拓扑结构"><a href="#1-2-3-计算机网络的拓扑结构" class="headerlink" title="1.2.3 计算机网络的拓扑结构"></a>1.2.3 计算机网络的拓扑结构</h3><ol><li><p>星型结构</p><p>结构简单易于实现便于管理</p><p>网络中心节点是全网性能与可靠性的瓶颈，中心节点的故障可能造成全网瘫痪</p></li><li><p>环形拓扑</p><p>结构简单，<strong>传输延时确定</strong></p><p>环中每个节点与连接点之间通信线路都会成为网络可靠性瓶颈。</p></li><li><p>总线型拓扑</p><p>当一个节点利用总线发送数据时，其他节点只能接收数据</p><p>当有两个或者多个节点同时发送数据时，都会出现冲突，造成传输失败</p><p>缺点：必须解决多节点访问总线的介质访问控制问题</p></li><li><p>树形拓扑</p><p>节点按层次连接，信息交换在上下节点之间进行，相邻以及同层节点之间通信通常不进行数据交换</p><p><strong>树型通常用来汇聚信息</strong></p></li><li><p>网状拓扑</p><p>连接任意<strong>没有规律</strong>，又称为无规则型拓扑</p><p><strong>可靠性高</strong>，<strong>广域网一般采用网状拓扑</strong></p><p><strong>结构复杂</strong>，必须采用路由选择算法，流量控制与拥塞控制</p></li></ol><h3 id="1-2-4-描述计算机网络传输特性的参数"><a href="#1-2-4-描述计算机网络传输特性的参数" class="headerlink" title="1.2.4 描述计算机网络传输特性的参数"></a>1.2.4 描述计算机网络传输特性的参数</h3><ol><li><p>数据传输速率的定义</p><ul><li><p>速率为：$S=\frac{1}{T}(bps)$其中T为发送1比特所需要的时间</p></li><li><p>对于二进制数据信号的最大数据传输速率$R<em>{max}$与通信信道带宽B(B=f,单位Hz)的关系可以写为：$R</em>{max}=2\times f(bps)$</p></li></ul></li><li><p>误码率的定义</p><p>误码率指二进制码元在数据传输系统中被传错的概率数值上近似等于：$P<em>{e}=\frac{N</em>{e}}{N}$,其中N为传输的二进制码元总数，$N_{e}$为被传错的码元数</p><p>注意：</p><ol><li>误码率是<strong>正常工作状态</strong>下的传输可靠性参数</li><li>对于实际的数据传输系统，不能笼统说误码率越低越好，因为<strong>误码率越低造价越高</strong></li><li>如果传输的不是二进制码元，<strong>折合成二进制码元计算</strong></li><li>由于差错有随机性，实际测量<strong>需要传输二进制码元数越大，才会越接近真实值</strong></li></ol></li></ol><h3 id="1-3-3-数据报交换与虚电路交换"><a href="#1-3-3-数据报交换与虚电路交换" class="headerlink" title="1.3.3 数据报交换与虚电路交换"></a>1.3.3 数据报交换与虚电路交换</h3><ol><li><p><strong>数据报方式</strong></p><p><strong>分组传输方式中，分组传输不需要在源主机与目的主机之间预先建立“线路连接”</strong></p><p>源主机发送的每个分组都可以独立选择一条传输路径，<strong>每个分组在通信子网中可能通过不同的路径到达目的主机</strong></p><p>数据报方式有以下几个特点：</p><ul><li>同一个报文不同分组可以通过<strong>不同路径</strong>通过通信子网</li><li>同一个报文的不同分组到达目的主机是可能会出现<strong>乱序，重复与丢失的现象</strong></li><li>数据传输方式的<strong>传输延时较大</strong>，<strong>适用于突发性通信，不适用于长报文，会话式通信</strong></li></ul></li><li><p><strong>虚电路方式</strong></p><p>发送分组前，发送方和接收方需要建立一条逻辑连接的虚电路</p><p>虚电路方式具有以下几个特点：</p><ul><li>在每次传输分组前，<strong>在源主机和目的主机之间建立一条虚电路</strong></li><li>所有分组都通过虚电路顺序传输，分组<strong>不必携带目的地址，源地址</strong>等信息，分组到达目的主机是<strong>不会出现乱序重复与丢失</strong></li><li>分组通过虚电路每个路由器时，路由器<strong>只需要进行差错检查，而不需要进行路由选择</strong></li><li>路由器可以<strong>与多个主机之间通信建立多条虚电路</strong></li></ul></li></ol><h2 id="1-4-网络体系结构与网络协议"><a href="#1-4-网络体系结构与网络协议" class="headerlink" title="1.4 网络体系结构与网络协议"></a>1.4 网络体系结构与网络协议</h2><h3 id="1-4-1-网络体系结构的概念"><a href="#1-4-1-网络体系结构的概念" class="headerlink" title="1.4.1 网络体系结构的概念"></a>1.4.1 网络体系结构的概念</h3><p>网络协议是由三个要素组成：</p><ol><li><p><strong>语法</strong>。语法是用户数据与控制信息的<strong>结构与格式</strong>，以及数据出现的<strong>顺序</strong>。</p></li><li><p><strong>语义</strong>。语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及<strong>完成的动作与做出什么样的响应</strong>。</p></li><li><p><strong>时序</strong>。时序是对事件<strong>发生顺序</strong>的详细说明。（也可称为“同步”）</p></li></ol><p>人们形象地把这三个要素描述为：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。</p><h3 id="1-4-2-ISO-OSI-参考模型"><a href="#1-4-2-ISO-OSI-参考模型" class="headerlink" title="1.4.2 ISO/OSI 参考模型"></a>1.4.2 ISO/OSI 参考模型</h3><p>TCP协议运行在传输层，IP在网络层，http在应用层</p><p><strong>同一个节点下层为上层提供服务，相邻层通过接口通信</strong></p><p>不同节点同等层之间通过通信协议通信</p><p>各层实现技术互不影响  </p><div class="table-container"><table><thead><tr><th>ISO/OSI 参考模型</th><th>功能</th><th>该层的设备与协议</th></tr></thead><tbody><tr><td><strong>物理层</strong></td><td><strong>物理连接，比特流传输，单位为比特流</strong></td><td>IEEE 802，中继器，网线，集线器</td></tr><tr><td><strong>数据链路层</strong></td><td><strong>建立数据链路连接，差错控制，流量控制</strong></td><td>网卡，二层交换机、网桥</td></tr><tr><td><strong>网络层</strong></td><td><strong>路由选择，流量控制，拥塞控制，网络互联</strong></td><td>路由器，RIP,OSPF，IP，ICMP，IGMP，包过滤路由器</td></tr><tr><td><strong>传输层</strong></td><td><strong>端到端连接与数据传输，单位为报文</strong></td><td>TCP,UDP，NAT</td></tr><tr><td><strong>会话层</strong></td><td><strong>会话主机之间的建立，管理和终止，数据交换</strong></td><td></td></tr><tr><td><strong>表示层</strong></td><td><strong>数据格式变换，加密解密，压缩恢复</strong></td><td></td></tr><tr><td><strong>应用层</strong></td><td><strong>通信过程控制</strong></td><td>Telnet,FTP,SNMP,HTTP，SIP，CMIP</td></tr></tbody></table></div><p><strong>调制解调器</strong>是一种硬件，它能把计算机的数字信号翻译成模拟信号。</p><p><strong>集线器</strong>的主要功能是对接收到的信号进行再生、整形、放大，以扩大网络的传输距离，同时把所有结点集中在以它为中心的结点上。</p><p><strong>中继器</strong>是网络物理层上面的连接设备，适用于完全相同的两类网络的互连，主要功能是通过对数据信号的重新发送或者转发，来扩大网络传输的距离。</p><p><strong>路由器</strong>是使用在网络层的互连设备，可以实现异构网络互联，是网络与网络之间连接的桥梁。</p><p>TCP（传输控制协议）协议是一种<strong>面向连接</strong>的、可靠的、<strong>基于IP的传输层协议</strong>。TCP使用三次握手协议建立连接，而终止一个连接要经过四次握手。RTT（Round Trip Time）表示从发送端到接收端的一去一回需要的时间，TCP在数据传输过程中会<strong>对RTT进行采样，采用自适应的RTT计算方法</strong>。TCP协议利用窗口机制进行流量控制，端口采用<strong>16位的二进制数</strong>表示。</p><h3 id="1-4-3-TCP-IP-参考模型"><a href="#1-4-3-TCP-IP-参考模型" class="headerlink" title="1.4.3 TCP/IP 参考模型"></a>1.4.3 TCP/IP 参考模型</h3><p>由IETF制定</p><p>独立于特定的网络硬件</p><div class="table-container"><table><thead><tr><th>TCP/IP 参考模型</th><th>功能</th><th>安全协议</th></tr></thead><tbody><tr><td><strong>主机-网络层</strong></td><td><strong>发送，接收IP分组</strong></td><td>PPTP,L2TP,L2F</td></tr><tr><td><strong>互联网络层/互联层</strong></td><td><strong>处理传输层的数据发送请求，处理接收分组，路由选择，流量控制，拥塞控制</strong></td><td>IPSec</td></tr><tr><td><strong>传输层</strong></td><td><strong>建立维护端到端连接，实现网络环境分布式进程通信</strong></td><td>SSH，SSL，SOCKS,TLS</td></tr><tr><td><strong>应用层</strong></td><td><strong>包括各种标准协议</strong></td><td>SET,PGP,S-HTTP,S/MIME</td></tr></tbody></table></div><h3 id="1-4-4-OSI参考模型与TCP-IP参考模型的比较"><a href="#1-4-4-OSI参考模型与TCP-IP参考模型的比较" class="headerlink" title="1.4.4 OSI参考模型与TCP/IP参考模型的比较"></a>1.4.4 OSI参考模型与TCP/IP参考模型的比较</h3><table><tbody><tr><td>            <p><strong>TCP/IP&nbsp;</strong></p>            </td>            <td>            <p><strong>OSI参考模型</strong></p>            </td>        </tr><tr><td rowspan="3">            <p>应用层</p>            </td>            <td>            <p>应用层</p>            </td>        </tr><tr><td>            <p>表示层</p>            </td>        </tr><tr><td>            <p>会话层</p>            </td>        </tr><tr><td>            <p>传输层</p>            </td>            <td>            <p>传输层</p>            </td>        </tr><tr><td>            <p>互联/网络互联层</p>            </td>            <td>            <p>网络层</p>            </td>        </tr><tr><td rowspan="2">            <p>主机-网络层</p>            </td>            <td>            <p>数据链路层</p>            </td>        </tr><tr><td>            <p>物理层</p>            </td>        </tr></tbody></table><h1 id="第二章-局域网基础"><a href="#第二章-局域网基础" class="headerlink" title="第二章 局域网基础"></a>第二章 局域网基础</h1><p>局域网从介质访问控制方式的角度可以分为<strong>共享介质局域网</strong>与<strong>交换局域网</strong>。</p><p><strong>共享介质局域网</strong>中所有的结点共享一条公共的传输介质，通过广播的方式发送数据帧，并采用CSMA/CD(带有冲突检测的载波侦听多路访问)方法解决冲突问题，连接在总线上的所有结点都能“收听”到数据。由于所有结点都可以利用总线发送数据，并且在网络中没有控制中心，隐藏冲突的发生将不可避免。</p><p><em>CSMA/CA(Carrier Sense Multiple Access with Collision Avoid<strong>,载波侦听多路访问／冲突避免</strong>)是无线局域网标准IEEE 802.11使用的一种介质访问控制方法，工作在MAC层。该方法要求每个结点在发送帧之前先侦听信道，如果空闲则可以发送帧，如果没有收到发回帧的确认ACK则表明该帧发送出现冲突，即发送失败，则在规定的帧间隔时间内不能再发送帧，只有超过了帧间隔时间才可以发送帧。常见的帧间间隔IFS有三种，短帧间间隔（SIFS）,点帧间间隔（PIFS），和分布帧间间隔（DIFS）,短帧间间隔用于分隔属于一次对话的各帧，MAC层支持无征用服务和征用服务两种访问方式，没有类似以太网的冲突检测机制，不能完全避免冲突的发生</em></p><h3 id="2-1-2-介质访问控制方法的比较"><a href="#2-1-2-介质访问控制方法的比较" class="headerlink" title="2.1.2 介质访问控制方法的比较"></a>2.1.2 介质访问控制方法的比较</h3><p>局域网按照介质访问控制方法分类：</p><ol><li><p><strong>采用带有冲突检测的载波侦听多路访问(Carrier Sense Multiple Access/Collision Detection,CSMA/CD)访问控制方法的总线形Ethernet，简称以太网</strong></p><p><strong>总线形，广播方式，两个及以上发送数据会发生冲突，随机型介质访问</strong></p><p>总线型局域网的主要特点：</p><p>（1）所有结点都通过网卡连接到作为公共介质的总线上。</p><p>（2）<strong>总线通常采用双绞线或同轴电缆作为传输介质。</strong></p><p>（3）所有的结点都可以发送或接收数据，<strong>但在一段时间内只允许一个结点通过总线发送数据（即但双工形式）</strong>。当一个结点通过总线以“广播”方式发送数据时，其他结点只能以“收听”方式接收数据。</p><p>（4）由于总线作为公共传输介质被多个结点共享，因此会出现冲突现象。</p></li><li><p>采用令牌控制的令牌总线形(Token Bus)局域网，简称“Token Bus”或“令牌总线网”</p><p><strong>总线形，取得令牌才能使用共享总线发送数据，令牌持有时间(Token Holding Time,THT)为10ms，控制访问数量实时性可以得到保证</strong></p></li><li><p>采用令牌控制的令牌环形(Token Ring)局域网，简称“Token Ring”或”令牌环网“</p><p><strong>环形，沿一个方向传输，发送数据间隔固定，提供有限服务，适用于重负载的应用领域</strong></p></li></ol><p>传输介质主要为同轴电缆，双绞线，光纤</p><p>采用共享介质发送接收数据帧</p><p>介质访问控制采用分布式控制方法，没有集中控制的主机</p><h2 id="2-2-共享介质局域网技术"><a href="#2-2-共享介质局域网技术" class="headerlink" title="2.2 共享介质局域网技术"></a>2.2 共享介质局域网技术</h2><h3 id="2-2-1-Ethernet工作原理"><a href="#2-2-1-Ethernet工作原理" class="headerlink" title="2.2.1 Ethernet工作原理"></a>2.2.1 Ethernet工作原理</h3><p>CSMA/CD：先听后发(先侦听是否空闲)，边听边发，冲突停止，<strong>延迟</strong>重发</p><h3 id="2-2-2-Ethernet帧结构"><a href="#2-2-2-Ethernet帧结构" class="headerlink" title="2.2.2 Ethernet帧结构"></a>2.2.2 Ethernet帧结构</h3><ol><li>Ethernet V2.0和IEEE802.3的Ethernet帧结构区别</li></ol><p><img src="计算机网络.assets/1232796-20171017084041287-1347335048.png" srcset="/img/loading.gif" alt="img"></p><p>​    <strong>具体异同见书本</strong></p><p>​    主要字段：<strong>前导码字段，目的地址和源地址字段，类型字段，数据字段，帧校验字段</strong></p><ol><li><p>Ethernet帧结构分析</p><ol><li><p>前导码字段</p><p><strong>8B</strong>的10101010….101010比特序列组成，前导码的作用是实现收发双方的比特同步与帧同步。在接收后不需要保留，也不计入帧头的长度中</p></li><li><p>目的地址和源地址字段</p><p>目的地址和源地址分别表示帧的接收主机与发送主机的硬件地址，地址长度为6B，<strong>源地址必须是48b的MAC地址</strong>，目的地址可以是单播地址，多播地址或广播地址</p></li><li><p>类型字段</p><p>表示<strong>网络层</strong>使用的协议类型</p></li><li><p>数据字段</p><p>数据字段是网络层发送的数据部分，<strong>长度在46~1500B之间</strong>，<strong>因此Ethernet帧的最小长度为46~1500B+18B=64~1518B</strong></p></li><li><p>校验字段</p><p>采用CRC校验，<strong>32位，4B</strong></p></li></ol></li></ol><h3 id="2-2-3-Ethernet网卡与物理地址"><a href="#2-2-3-Ethernet网卡与物理地址" class="headerlink" title="2.2.3 Ethernet网卡与物理地址"></a>2.2.3 Ethernet网卡与物理地址</h3><ol><li><p>Ethernet 网卡与物理地址</p><p><strong>网卡包含发送与接收信号的收发器，曼彻斯特编码与解码器，Ethernet数据链路控制，组帧与拆帧软件，与主机的接口</strong></p></li><li><p>Etherne物理地址</p><p>48位的地称为EUI-48，允许分配的Ethernet物理地址应为$2^{47}$个，<strong>IEEE为每个网卡厂商分配Ethernet物理地址的前三位，后三位字节由厂商自行分配</strong>。当网卡厂商获得前三位后它可以生产的网卡数量为$2^{24}$块，表示方法为两个十六进制之间用一个连字符隔开，如02-01-00-2A-10-C3</p><p>48位全1的地址成为广播地址</p></li></ol><h3 id="2-2-4-Ethernet-组网方法"><a href="#2-2-4-Ethernet-组网方法" class="headerlink" title="2.2.4 Ethernet 组网方法"></a>2.2.4 Ethernet 组网方法</h3><ol><li><p>Ethernet物理层标准</p><p>| 标准               | 速率   | 基带传输 |            | 最大长度 |<br>| ————————— | ——— | ———— | ————— | ———— |<br>| IEEE802.3 10BASE-5 | 10Mbps | 是       | 粗同轴线缆 | 500m     |<br>| IEEE802.3 10BASE-2 | 10Mbps | 是       | 细同轴线缆 | 200m     |<br>| IEEE802.3 10BASE-T | 10Mbps | 是       | 双绞线     | ？       |</p><p>字段总结：</p><p>10:10Mbps </p><p>5:500m 2:200m</p><p>T:<em>双绞线（twisted pair，TP）</em></p></li></ol><h2 id="2-3-交换式局域网与虚拟局域网"><a href="#2-3-交换式局域网与虚拟局域网" class="headerlink" title="2.3 交换式局域网与虚拟局域网"></a>2.3 交换式局域网与虚拟局域网</h2><h3 id="2-3-1-交换式局域网技术"><a href="#2-3-1-交换式局域网技术" class="headerlink" title="2.3.1 交换式局域网技术"></a>2.3.1 交换式局域网技术</h3><p>交换式以太网的<strong>核心设备是以太网交换机</strong>，它从根本上改变了“共享介质”的工作方式，<strong>可以在多个端口之间建立多个并发连接</strong>，实现多结点之间数据的并发传输，从而可以增加网络带宽，改善局域网的性能与服务质量，避免数据传输冲突的发生。<strong>以太网交换机利用“端口/MAC地址映射表”进行数据帧交换</strong>。</p><h2 id="2-4-高速局域网技术发展"><a href="#2-4-高速局域网技术发展" class="headerlink" title="2.4 高速局域网技术发展"></a>2.4 高速局域网技术发展</h2><h3 id="2-4-1-Fast-Ethernet"><a href="#2-4-1-Fast-Ethernet" class="headerlink" title="2.4.1 Fast Ethernet"></a>2.4.1 Fast Ethernet</h3><p>保留传统的Ethernet帧格式</p><p>介质专用接口（Media Indepandent Interface,MII）将ＭＡＣ子层与物理层分开</p><div class="table-container"><table><thead><tr><th>标准</th><th>材料</th><th>双功</th></tr></thead><tbody><tr><td>100BASE-TX</td><td>两对5类非屏蔽双绞线（UTP）或两对1类屏蔽双绞线（STP）一对用于发送一对用于接收</td><td>全双工</td></tr><tr><td><strong>100BASE-T4</strong></td><td><strong>四对3类非屏蔽双绞线UTP，三对用于数据传输，1对用于冲突检测</strong></td><td><strong>半双工</strong></td></tr><tr><td>100BASE-FX</td><td>2芯单模或多模光纤</td><td>全双工</td></tr></tbody></table></div><p><em>光纤fiber</em></p><h3 id="2-4-2-Gigabit-Ethernet"><a href="#2-4-2-Gigabit-Ethernet" class="headerlink" title="2.4.2 Gigabit Ethernet"></a>2.4.2 Gigabit Ethernet</h3><p>保留传统的Ethernet帧格式</p><p>千兆介质专用接口（Gigabit Media Indepandent Interface,GMII）将MAC，子层与物理层分开</p><div class="table-container"><table><thead><tr><th>标准</th><th>材料</th><th>最大长度</th></tr></thead><tbody><tr><td>1000BASE-CX</td><td>两对屏蔽双绞线</td><td>25m</td></tr><tr><td>1000BASE-T</td><td>4对5类非屏蔽双绞线</td><td>100m</td></tr><tr><td>1000BASE-SX</td><td>多模光纤</td><td>550m</td></tr><tr><td>1000BASE-LX</td><td>单模光纤</td><td>5km</td></tr><tr><td>1000BASE-LH</td><td>单模光纤</td><td>10km</td></tr><tr><td>1000BASE-ZX</td><td>单模光纤</td><td>70km</td></tr></tbody></table></div><h3 id="2-4-3-10-Gigabit-Ethernet"><a href="#2-4-3-10-Gigabit-Ethernet" class="headerlink" title="2.4.3 10 Gigabit Ethernet"></a>2.4.3 10 Gigabit Ethernet</h3><p>保留传统的Ethernet帧格式</p><p>介质专用接口（10 Gigabit Media Indepandent Interface,10GMII）将MAC子层与物理层分开</p><p>不再采用传统的CSMA/CD协议，使10GbE的覆盖范围不受传统的Ethernet网的冲突窗口限制，传输距离仅仅由光纤通信系统的性能</p><div class="table-container"><table><thead><tr><th>标准</th><th>材料</th><th>最大长度</th></tr></thead><tbody><tr><td>10GBASE-SR</td><td>多模光纤</td><td>300m</td></tr><tr><td>10GBASE-LRM</td><td>多模光纤</td><td>220m</td></tr><tr><td>10GBASE-LX4</td><td>单模光纤</td><td>10km</td></tr><tr><td>10GBASE-LR</td><td>单模光纤</td><td>25km</td></tr><tr><td>10GBASE-ER</td><td>单模光纤</td><td>40km</td></tr><tr><td>10GBASE-ZR</td><td>单模光纤</td><td>80km</td></tr></tbody></table></div><p><strong>10 Gigabit Ethernet都是全双工，只支持光纤</strong></p><h3 id="2-5-6-IEEE-802-11帧结构"><a href="#2-5-6-IEEE-802-11帧结构" class="headerlink" title="2.5.6 IEEE 802.11帧结构"></a>2.5.6 IEEE 802.11帧结构</h3><ol><li><p>管理帧</p><p>定义了14种帧，如<strong>信标帧，探测帧，关联帧，认证帧</strong></p></li><li><p>控制帧</p><p>定义了9种帧，如<strong>RTS，CTS，ACK帧</strong></p></li><li><p>数据帧</p></li></ol><h2 id="2-5-无线局域网技术"><a href="#2-5-无线局域网技术" class="headerlink" title="2.5 无线局域网技术"></a>2.5 无线局域网技术</h2><h3 id="2-5-1-无线局域网的发展"><a href="#2-5-1-无线局域网的发展" class="headerlink" title="2.5.1 无线局域网的发展"></a>2.5.1 无线局域网的发展</h3><p>IEEE802.11 由IEEE为无线局域网制定的标准，是无线局域网<strong>介质访问控制</strong>方法</p><p>采用了<strong>层次结构模型</strong></p><p>物理层定义了以<strong>微波，激光与红外线</strong>等<strong>无线电波</strong>作为传输介质</p><p>MAC层主要功能是对无线环境进行访问控制，可以在多个接入点上提供漫游支持，同时提供数据验证与保密服务</p><p>MAC层支持无争用与争用服务两种访问方式</p><p>应用领域：<strong>传统局域网的扩充</strong>，建筑物之间互联，移动主机漫游访问，无线自组网</p><p>支持基于漫游访问(Nomadic Access)和无线访问接入点(Wireless Access Point,AP)访问模式，也可以通过对等P2P方式实现漫游</p><p>虚拟局域网（Virtual LAN，VLAN）是建立在局域网的基础上，以软件形式在局域网交换机上实现逻辑工作组的划分与管理，工作组中的结点不受物理位置的限制。</p><p>虚拟局域网的组网方法包括：用<strong>交换机端口</strong>定义虚拟局域网、用<strong>MAC地址</strong>定义虚拟局域网、用<strong>网络层地址</strong>定义虚拟局域网、基于<strong>广播组</strong>的虚拟局域网。<br>虚拟局域网的优点有：<strong>方便网络用户管理，减少网络管理开销、提供更好的安全性、改善网络服务质量</strong>。</p><h3 id="2-5-2-扩频无线局域网"><a href="#2-5-2-扩频无线局域网" class="headerlink" title="2.5.2 扩频无线局域网"></a>2.5.2 扩频无线局域网</h3><ol><li><p>扩频通信的概念</p><p>无线局域网主要采用两种扩频技术：<strong>跳频扩频与直接序列扩频</strong></p><p>IEEE 802.11规定：</p><p>跳频通信使用<strong>2.4GHZ的工业、科学与医药专用的ISM频段</strong>。</p><p>直接序列扩频的<strong>所有接收点使用相同的频段，发送端与接收端使用相同的伪随机码，使用2.4GHz的ISM频段，数据传输速率为1Mbps或2Mbps,发送前需要调制</strong>。</p></li></ol><h3 id="2-5-4-无线局域网拓扑结构"><a href="#2-5-4-无线局域网拓扑结构" class="headerlink" title="2.5.4 无线局域网拓扑结构"></a>2.5.4 无线局域网拓扑结构</h3><p>端站使用无线网卡，将计算机或嵌入设备接入WLAN，接入点AP按照无线接口标准使用无线链路与端站进行通信，接入控制器AC在WLAN与外部网络之间充当网关的作用，AAA服务器又称为RADIUS用户认证服务器，负责完成用户认证授权和计费功能，IEEE802.11认证有三种认证方式：基于IEEE802.1x的认证，基于PPPoE的认证和基于Web的认证</p><ol><li><p>独立基本服务集</p><p>Ad hoc 具有以下几个主要特点：<strong>自组织与自修复，无中心，多跳路由，动态拓扑,对等式，无线网络，无基站</strong></p></li></ol><h3 id="2-5-4-IEEE-802-11-帧结构"><a href="#2-5-4-IEEE-802-11-帧结构" class="headerlink" title="2.5.4 IEEE 802.11 帧结构"></a>2.5.4 IEEE 802.11 帧结构</h3><p>IEEE 802.11帧采用<strong>2字节（16b）</strong>作为帧控制字段，帧中目的地址和源地址使用MAC地址，数据字段最大长度是2312字节。帧校验字段长度为4字节，采用CRC校验，校验范围为<strong>MAC帧头与数据域</strong>。类型字段的类型标识数据帧、管理帧或控制帧。</p><p>IEEE802.11协议定义了三种帧结构：管理帧，控制帧，数据帧</p><ol><li><p>管理帧</p><p>定义了14种管理帧，例如信标帧，探测帧，关联帧，认证帧，用于无线主机与AP之间的连接</p></li><li><p>控制帧</p><p>定义了9种控制帧，对预约信道，对单播数据帧的确认，RTS，CTS,ACK都属于控制帧</p></li><li><p>数据帧</p><p>数据帧由三个部分组成：帧头，数据字段，帧尾，<strong>其中帧头长30B,数据字段长0~2312B,帧尾由2B的帧校验字段组成</strong></p></li></ol><p>无线局域网标准802.11的MAC和802.3协议的MAC不同，传统的Ethernet网帧的结构中有前导码和帧前定界符，而802.11标准中用帧控制单元代替。传统的Ethernet网的数据段长度是<strong>46B~1500B</strong>，而802.11帧中的数据段长度是<strong>0~2312B</strong>。传统的Ethernet网中帧的类型字段表示当前帧使用协议的类型，而802.11帧中类型字段用来表示当前帧是数据帧、管理帧或控制帧。<strong>这两种帧均工作在数据链路层，采用的地址是MAC地址</strong>。</p><h1 id="第三章-Internet基础"><a href="#第三章-Internet基础" class="headerlink" title="第三章 Internet基础"></a>第三章 Internet基础</h1><p>Internet的使用者不必关心Internet的内部结构；路由器是网络与网络之间连接的<strong>桥梁</strong>；主机是Internet中不可缺少的成员，它是<strong>信息资源和服务的载体</strong>。</p><h3 id="3-1-2-Internet的接入方式"><a href="#3-1-2-Internet的接入方式" class="headerlink" title="3.1.2 Internet的接入方式"></a>3.1.2 Internet的接入方式</h3><ol><li><p>通过电话线接入</p></li><li><p>利用ADSL接入</p><p>利用<strong>非对称数字用户线</strong></p><p><strong>使用比较复杂的调制解调技术</strong>，在<strong>普通电话线</strong>上进行高速数据传输</p><p>分上行和下行两个通道，下行通道数据传输远大于上行，<strong>上行16~640kbps，下行速率可达1.5~9Mbps</strong></p></li><li><p>使用HFC接入</p><p><strong>共享式传输</strong></p><p><strong>信号首先通过光纤传输到光纤节点然后通过同轴电缆传输到有线电视网用户</strong></p><p>混合光纤/同轴电缆线（Hybrid Fiber Coaxial，HFC），同ADSL为非对称连接，<strong>上行速率达到10Mbps,下行10~40Mbps</strong></p></li><li><p>通过数据通信线路接入</p></li></ol><h3 id="3-2-2-IP服务"><a href="#3-2-2-IP服务" class="headerlink" title="3.2.2 IP服务"></a>3.2.2 IP服务</h3><p>IP协议的互联层可以为其高层用户提供如下服务：</p><ol><li><strong>不可靠</strong>数据投递服务</li><li><strong>面向无连接</strong>的传输服务</li><li><strong>尽最大努力</strong>投递服务</li></ol><p>IP协议精确定义了<strong>IP数据报格式</strong>，并且<strong>对数据报寻址和路由、数据报分配和重组、差错控制和处理</strong>等做出了具体的规定。</p><h3 id="3-2-3-IP互联网的特点"><a href="#3-2-3-IP互联网的特点" class="headerlink" title="3.2.3 IP互联网的特点"></a>3.2.3 IP互联网的特点</h3><ul><li><strong>隐藏了底层物理网络的细节</strong>，向上为用户提供通用一致的网络服务</li><li>IP互联网<strong>不指定网络互联的拓扑结构</strong>，也<strong>不要求网络之间的全互联</strong></li><li>IP互联网<strong>能在物理网络之间转发数据</strong>，信息可以跨网传输</li><li>IP互联网中所有计算机使用<strong>统一的，全局的地址描述法</strong></li><li>IP互联网<strong>平等地对待</strong>互联网中的每一个网络，不管这个网络规模是大是小，速度是快是慢</li></ul><h2 id="3-4-IP数据报"><a href="#3-4-IP数据报" class="headerlink" title="3.4 IP数据报"></a>3.4 IP数据报</h2><p>IP数据报是IP协议单元使用的数据单元，它的格式可以<strong>分为报头区和数据区两大部分</strong>，其中数据区包括高层需要传输的数据，而报头区是为了正确传输高层数据而增加的控制信息。报头区主要包括：<strong>版本与协议类型域、长度域、服务类型域、生存周期域、头部校验和域、地址域、选项+填充域</strong>。其中<strong>报头长度域以32位的双字为单位</strong>；<strong>生存周期（Time to Live，TTL）域用于防止数据报在Internet中无休止地传递</strong>；<strong>头部校验和域用来保证IP数据报报头的完整性</strong>；<strong>选项域主要用于控制和测试两大目的</strong>。</p><h3 id="3-4-2-IP封装分片与重组"><a href="#3-4-2-IP封装分片与重组" class="headerlink" title="3.4.2 IP封装分片与重组"></a>3.4.2 IP封装分片与重组</h3><ol><li><p>MTU与分片</p><p>每种网络都规定了一个帧最多能携带的数据量，这一限制成为<strong>最大传输单元（Maximum Transmission Unit,MTU）</strong>因此一个IP数据报只有小于等于一个网络的MTU才能在这个网络进行传播</p><p>当一个数据报尺寸大于将发往的网络的MTU时，路由器会将IP数据报分成若干较小的部分，称为<strong>分片</strong>，然后再将每片独立地进行发送</p></li><li><p>重组</p><p>IP协议规定，<strong>只有最终的目的主机才可以对分片进行重组</strong></p><p>当转发一个IP数据报的时候，路由器不需要知道它是不是一个分片，其次路由器可以为每个分片独立选择路由，每个分片达到目的地所经过的路径可以不同</p></li><li><p>分片控制</p><p>在IP数据报中，<strong>标识，标志和片偏移</strong>三个字段与控制分片与重组有关</p><p>标识是主机赋予IP数据报的标识符，分片时该域必须不加修改地复制到新分片头的报头中</p><p>标志告诉主机该数据报是否已经分片，是否是最后一个分片</p><p>片偏移是本片数据在初始IP数据报数据区中的位置，<strong>位置偏移量以８个字节为单位</strong>，重组的分片顺序由片偏移提供</p></li></ol><p>分片后<strong>标识和目的地址一定和原数据报中字段相同</strong></p><h3 id="3-4-3-IP数据报选项"><a href="#3-4-3-IP数据报选项" class="headerlink" title="3.4.3 IP数据报选项"></a>3.4.3 IP数据报选项</h3><p>IP选项主要用于控制和测试</p><ol><li><p>源路由</p><p>指IP数据报穿越互联网所经过的路径是由源主机决定的，它区别于由主机或者路由器的IP层软件自行选路后得出的路径</p><p>源路由选项可以分为两类：一类是严格源路由选项，一类是松散路由选项</p><ul><li>严格源路由选项：规定经过的 每一个路由器，相邻的路由器之间不能有中间路由器</li><li>松散路由选项：给出必须经过的要点，不给出完备的路径</li></ul></li><li><p>记录路由</p><p>记录IP数据报从源主机到目的主机之间所经过的路径上的各个路由器的IP地址，记录路由功能可以由IP数据报的记录路由选项完成，利用它可以判断经过的路径</p></li><li><p>时间戳</p><p>记录下IP数据报经过每一个路由器当地时间，用于分析网络吞吐率，拥塞情况，负载情况</p></li></ol><h2 id="3-5-差错报文控制"><a href="#3-5-差错报文控制" class="headerlink" title="3.5 差错报文控制"></a>3.5 差错报文控制</h2><p>IP层使用的控制协议是互联网控制报文协议(Internet Control Message Protocol,ICMP),ICMP不仅用来传输控制报文，而且还用于传输差错报文</p><h3 id="3-5-1-ICMP-差错控制"><a href="#3-5-1-ICMP-差错控制" class="headerlink" title="3.5.1 ICMP 差错控制"></a>3.5.1 ICMP 差错控制</h3><p>ICMP差错报告采用路由器到源主机的模式，所有差错信息都需要想源主机报告。</p><p>特点：</p><ul><li>差错报告<strong>不享受特别优先权和可靠性</strong>，作为一般数据传输，完全可能丢失损坏或者抛弃。</li><li>ICMP差错报告数据中除了<strong>包含故障IP数据报报头</strong>外，还包含<strong>故障IP数据报数据区的前64bit数据</strong>。</li><li>ICMP差错报告是伴随着抛弃出错IP数据报而产生的。</li></ul><p>ICMP差错报告报文共有如下5种。<br>（1）<strong>终点不可达</strong>：分为网络不可达、主机不可达、协议不可达、端口不可达、需要分片但DF比特已置为1、源路由失败等六种情况。<br>（2）<strong>源站抑制</strong>：当路由器或主机由于拥塞而丢弃数据报时，就向<strong>源站</strong>发送源站抑制报文，使源站知道应当将数据报的<strong>发送速率放慢</strong>。<br>（3）<strong>时间超时</strong>：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向<strong>源站</strong>发送时间超时报文。当目的站在预先规定的时间内不能收到一个数据报的全部数据报片时，就<strong>将已收到的数据报片都丢弃</strong>，并向源站发送时间超时报文。<br>（4）<strong>参数问题</strong>：当路由器或目的主机收到的数据报的首部中的字段的值不正确时，就<strong>丢弃该数据报</strong>，并向<strong>源站</strong>发送参数问题报文。<br>（5）<strong>重定向报文</strong>：改变路由（<strong>重定向</strong>）路由器将改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器。ICMP重定向报文机制是为了<strong>保证主机拥有一个动态的、既小且优的路由表</strong>。</p><h2 id="3-6-路由器与路由选择"><a href="#3-6-路由器与路由选择" class="headerlink" title="3.6 路由器与路由选择"></a>3.6 路由器与路由选择</h2><h3 id="3-6-1-表驱动IP选路"><a href="#3-6-1-表驱动IP选路" class="headerlink" title="3.6.1 表驱动IP选路"></a>3.6.1 表驱动IP选路</h3><ol><li>路由表中的特殊路由<ol><li>默认路由：是一种特殊的静态路由，指的是当路由表中与包的目的地址之间没有匹配的表项时路由器能够做出的选择，默认路由会大大简化路由器的配置，减轻管理员的工作负担，提高网络性能。</li><li>特定主机路由：对单个主机指定一条特别的路径就是所谓的特定主机路由，可用于安全性，网络连通性调试及路由表正确性判断等目的</li></ol></li></ol><h3 id="3-6-3-RIP协议与向量-距离算法"><a href="#3-6-3-RIP协议与向量-距离算法" class="headerlink" title="3.6.3 RIP协议与向量-距离算法"></a>3.6.3 RIP协议与向量-距离算法</h3><ol><li><p>RIP协议</p><p>使用Bellman-Ford算法</p><p>RIP协议规定路由器<strong>每30秒</strong>交换一次路由信息</p><p>RIP协议严格准守向量-距离算法</p><p>规定路径超时时间为180秒，相当于6个RIP刷新周期</p></li><li><p>收敛慢的问题及对策</p><ul><li><strong>限制最大距离对策</strong></li><li><strong>水平分割对策</strong></li><li><strong>保持对策</strong></li><li><strong>带触发刷新的毒性逆转对策</strong></li></ul></li></ol><h3 id="3-6-4-OSPF协议与链路-状态算法"><a href="#3-6-4-OSPF协议与链路-状态算法" class="headerlink" title="3.6.4 OSPF协议与链路-状态算法"></a>3.6.4 OSPF协议与链路-状态算法</h3><p>使用最短路径优先算法,<strong>收敛速度比RIP快，计算复杂度比RIP高</strong></p><h3 id="3-6-5-部署和选择路由协议"><a href="#3-6-5-部署和选择路由协议" class="headerlink" title="3.6.5 部署和选择路由协议"></a>3.6.5 部署和选择路由协议</h3><ol><li><p>静态路由</p><p><strong>适用于在小型，单路径，静态的IP互联网环境下使用</strong></p><p>小公司，家庭办公室等小型机构建设的互联网可采用静态路由</p></li><li><p>RIP路由选择协议</p><p><strong>适合小型到中型，多路径，动态IP互联网环境</strong></p><p>中型企业，具有多个网络的大型分支办公室等</p></li><li><p>OSPF路有选择协议</p><p><strong>适合较大型到特大型，多路径，动态的IP互联网环境</strong></p><p>企业，校园，部队，机关等</p></li></ol><h3 id="3-7-1-IP组播的概念和特点"><a href="#3-7-1-IP组播的概念和特点" class="headerlink" title="3.7.1 IP组播的概念和特点"></a>3.7.1 IP组播的概念和特点</h3><ol><li>组播使用组地址。每个组播组拥有唯一的组播地址（<strong>D类地址</strong>）发送方不必知道有哪些成员，他自己不必是组成员，对组成员中主机的数目和位置没有限制</li><li>动态组成员。一个主机（接收方或发送方）可以参加某个特定的组，也可以任意时间退出该组。</li><li>底层硬件支持的组播。以太网本身具有组播的能力，以太网利用硬件进行组播。</li></ol><h3 id="3-7-2-组播技术基础"><a href="#3-7-2-组播技术基础" class="headerlink" title="3.7.2 组播技术基础"></a>3.7.2 组播技术基础</h3><ol><li><p>IP组播地址</p><p>D类地址为组播地址</p></li><li><p>组播的相关协议</p><p><strong>组管理协议：</strong>Internet组管理协议（Internet Group Management Protocol，<strong>IGMP</strong>）和Cisco专用的组管理协议（<strong>CGMP</strong>）。组播路由协议又分为<strong>域内组播路由协议</strong>以及<strong>域间组播路由协议</strong>两类。</p><ul><li>域内组播协议：组播路由算法构造组播分发树，路由器中建立组播路由状态，根据这些状态进行组播数据包转发</li><li>域间组播路由协议：在各自治系统（Autonomous System，AS）间发布具有组播能力的路由信息以及组播源信息，使组播信息能在域间进行转发</li></ul><p><strong>组播路由协议</strong>： 域内组播路由协议包括MOSPF，CBT，PIM-SM、PIM-DM、DVMRP等协议，域内的组播协议又分为密集，与稀疏模式的协议。</p><ul><li><p>DVMRP，PIM-DM，MOSPF属于密集模式</p></li><li><p>CBT，PIM-SM属于稀疏模式。</p></li></ul><p>在域内，主要使用PIM-SM，PIM-DM，DVMRP协议。</p></li></ol><p>组播路由协议是IP组播协议中最核心的功能，组播路由不同于单播路由，他是由源地址，组地址，入接口和出接口列表4部分组成</p><h3 id="3-8-1-IPv4协议的局限性"><a href="#3-8-1-IPv4协议的局限性" class="headerlink" title="3.8.1 IPv4协议的局限性"></a>3.8.1 IPv4协议的局限性</h3><ol><li>地址空间的局限性</li><li>IP协议的性能问题</li><li>IP协议的安全问题</li><li>自动配置问题</li><li>服务质量（QoS）保证问题</li></ol><h3 id="3-8-2-IPv6地址"><a href="#3-8-2-IPv6地址" class="headerlink" title="3.8.2 IPv6地址"></a>3.8.2 IPv6地址</h3><ol><li><p>IPv6地址类型</p><ol><li><p>特殊地址</p><p><strong>全零地址：表示地址不存在</strong></p><p><strong>回送地址：::1</strong></p><p>IPv4兼容的IPv6地址</p><p>映射到IPv4的IPv6地址</p></li></ol></li></ol><h2 id="3-10-NAT的基本工作原理"><a href="#3-10-NAT的基本工作原理" class="headerlink" title="3.10 NAT的基本工作原理"></a>3.10 NAT的基本工作原理</h2><h3 id="3-10-2-NAT的主要技术类型"><a href="#3-10-2-NAT的主要技术类型" class="headerlink" title="3.10.2 NAT的主要技术类型"></a>3.10.2 NAT的主要技术类型</h3><p>主要类型有三种：<strong>静态路由NAT，动态NAT,网络地址端口转换NAPT</strong></p><ol><li><p>静态路由NAT</p><p>网络管理员需要在NAT设备中设置NAT地址映射表，该表确定了一个内部IP地址与一个全局IP地址的对应关系，NAT地址映射表中的内部地址与全局地址一一对应</p></li><li><p>动态NAT</p><p>全局IP地址构成NAT池，当主机通信结束，NAT设备将回收全局IP地址，并删除地址映射表中对应的映射项，以便其他内部主机访问外部网络时使用</p></li><li><p>网络地址端口转换NAPT</p><p>最常使用的NAT类型，利用TCP/UDP的端口号区分NAT地址映射表中的转换条目，可以使内部网络中的多个主机共享一个全局IP地址同时访问外部网络。</p></li></ol><h1 id="第四章-Internet-基本服务"><a href="#第四章-Internet-基本服务" class="headerlink" title="第四章 Internet 基本服务"></a>第四章 Internet 基本服务</h1><h3 id="4-1-1-客户机-服务器模型"><a href="#4-1-1-客户机-服务器模型" class="headerlink" title="4.1.1 客户机/服务器模型"></a>4.1.1 客户机/服务器模型</h3><p>服务器的分类：<strong>重复服务器，并发服务器</strong></p><h2 id="4-2-域名系统"><a href="#4-2-域名系统" class="headerlink" title="4.2 域名系统"></a>4.2 域名系统</h2><p>地址解析系统由一组既独立又协作的域名服务器组成，<strong>域名服务器是解析系统的核心</strong>。域名解析的DNS在实现上也采用<strong>层次化模式</strong>，并与分级结构的域名空间相对应。域名解析方式有<strong>递归解析和迭代解析</strong>两种类型。域名解析每次从根服务器进行解析很可能会造成根域名服务器因负荷太重而超载。为了提高解析效率，<strong>域名解析可以从本地域名服务器开始解析或者采用域名服务器的高速缓冲技术来提高解析效率</strong></p><h3 id="4-2-2-域名解析"><a href="#4-2-2-域名解析" class="headerlink" title="4.2.2 域名解析"></a>4.2.2 域名解析</h3><ol><li><p>TCP/IP域名服务器与解析过程</p><p>域名解析采用自顶向下的算法，从根服务器到叶服务器</p><p>但是如果没每个均是从根到叶会使到达根服务器的信息流量随互联网规模增大而增大，所以每个解析均从根服务器开始并不是一个很好的解决方案</p><p>域名解析方法有两种：第一种叫递归解析，第二种叫反复解析</p><p><strong>递归解析：域名服务器系统一次性完成全部名字-地址转换</strong></p><p><strong>反复解析：每次请求一个服务器，不行再请求别的服务器</strong></p></li><li><p>提高域名解析效率</p><ol><li><strong>解析从本地域名服务器开始</strong></li><li><strong>域名服务器的高速缓冲技术</strong></li><li><strong>主机上的高速缓冲技术</strong></li></ol></li></ol><ul><li>如果解析器收到一条“非授权的”服务器响应，<strong>那么解析器可以认为该响应提供的信息可能不准确</strong></li><li>解析器收到一个“非权威性”的映射时，<strong>解析器可以认为响应服务器不是该域名的授权管理者</strong></li></ul><h3 id="4-2-3-对象类型与资源记录"><a href="#4-2-3-对象类型与资源记录" class="headerlink" title="4.2.3 对象类型与资源记录"></a>4.2.3 对象类型与资源记录</h3><div class="table-container"><table><thead><tr><th>类型</th><th>意义</th><th>内容</th></tr></thead><tbody><tr><td>SOA（Start Of Authority）</td><td>授权开始</td><td>标识一个资源记录集合的开始</td></tr><tr><td>A(address)</td><td>主机地址</td><td>32位二进制IP地址</td></tr><tr><td>MX(mail exchanger)</td><td>邮件交换机</td><td>邮件服务器名及优先级</td></tr><tr><td>NS(name server)</td><td>域名服务器</td><td>域的授权名字服务器名</td></tr><tr><td>CNAME(canonical name)</td><td>别名</td><td>别名的规范名字</td></tr><tr><td>PTR(pointer)</td><td>指针</td><td>对应于IP地址的主机名</td></tr><tr><td>HINFO(host info)</td><td>主机描述</td><td>ASCII字符串，CPU和OS描述</td></tr><tr><td>TXT</td><td>文本</td><td>ASCII字符串，不解释</td></tr></tbody></table></div><h2 id="4-3-远程登录服务"><a href="#4-3-远程登录服务" class="headerlink" title="4.3 远程登录服务"></a>4.3 远程登录服务</h2><p><strong>Telnet协议是TCP/IP协议</strong>一部分，精确定义本地客户机与远程服务器之间的交互过程</p><p>远程登录允许<strong>任意类型</strong>的计算机之间进行通信</p><p>使用Telnet主要目的是使本地主机成为远程主机的仿真终端</p><h3 id="4-3-1-远程登录协议"><a href="#4-3-1-远程登录协议" class="headerlink" title="4.3.1 远程登录协议"></a>4.3.1 远程登录协议</h3><p>远程登录协议Telnet是TCP/IP协议族中的重要协议，为了解决系统的差异性，Telnet协议引入<strong>网络虚拟终端（Network Virtual Terminal，NVT）提供一种标准的键盘定义</strong>，用来屏蔽不同的计算机系统对键盘输入的差异性</p><h2 id="4-4-FTP服务"><a href="#4-4-FTP服务" class="headerlink" title="4.4 FTP服务"></a>4.4 FTP服务</h2><p>FTP（File Transfer Protocol）文件传输协议，主要用于internet上的文件双向传输，采用客户机/服务器模式</p><h3 id="4-4-1-FTP客户机-服务器模型"><a href="#4-4-1-FTP客户机-服务器模型" class="headerlink" title="4.4.1 FTP客户机/服务器模型"></a>4.4.1 FTP客户机/服务器模型</h3><p>FTP客户机与服务器要建立双向链接，一个是控制连接（端口号21）一个是数据连接（端口号20）</p><ul><li><p>控制连接用于维持会话，负责在客户机与服务器之间传送FTP命令和响应</p><p>控制连接以通常的客户机/服务器方式建立，服务器以被动方式在TCP的21端口打开等待客户机连接，客户机则以主动方式在一个TCP随机端口打开</p></li><li><p>数据连接用于访问数据。<strong>建立方式有主动模式和被动模式</strong></p></li></ul><h3 id="4-4-2-FTP命令和响应"><a href="#4-4-2-FTP命令和响应" class="headerlink" title="4.4.2 FTP命令和响应"></a>4.4.2 FTP命令和响应</h3><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>USER</td><td>认证用户名</td></tr><tr><td>PASS</td><td>认证密码</td></tr><tr><td>PORT n1,n2,n3,n4,n5,n6</td><td>客户机IP地址（n1,n2,n3,n4）和端口号（n5*256+n6）</td></tr><tr><td>PASV</td><td>进入被动模式</td></tr><tr><td>LIST filelist</td><td>如果指定了文件或目录，返回其信息；否则返回当前工作目录的信息</td></tr><tr><td>TYPE type(ascii/binary)</td><td>设定传输模式（ASCII/BINARY) 文本使用ASCII，图像使用二进制</td></tr><tr><td>REST marker</td><td>传输文件的起始点</td></tr><tr><td>RERT filename</td><td>检索一个文件</td></tr><tr><td>STOR filename</td><td>存储一个文件</td></tr><tr><td>QUIT</td><td>从服务器注销</td></tr></tbody></table></div><h3 id="4-4-3-文件格式"><a href="#4-4-3-文件格式" class="headerlink" title="4.4.3 文件格式"></a>4.4.3 文件格式</h3><p>FTP协议支持两种<strong>文件传输方式</strong>：<strong>文本文件传输和二进制文件传输</strong></p><p>FTP<strong>数据连接建立模式</strong>有两种：<strong>主动模式与被动模式</strong></p><h2 id="4-5-电子邮件系统"><a href="#4-5-电子邮件系统" class="headerlink" title="4.5 电子邮件系统"></a>4.5 电子邮件系统</h2><h3 id="4-5-1-电子邮件系统的基本知识"><a href="#4-5-1-电子邮件系统的基本知识" class="headerlink" title="4.5.1 电子邮件系统的基本知识"></a>4.5.1 电子邮件系统的基本知识</h3><ol><li><p>电子邮件系统</p><p>电子邮件系统采用客户机/服务器工作模式。</p></li><li><p>TCP/IP互联网上电子邮件传输过程</p><p>在TCP/IP互联网中，邮件之间采用<strong>简单邮件传输协议（Simple Mail Transfer Protocol,STMP）</strong>相互传输邮件。</p><p>电子邮件应用程序<strong>使用STMP向邮件服务器发送邮件</strong>，使用<strong>POP3（Post Office Protocol）协议或者IMAP（Interactive Mail Access Protocol）协议从邮件服务器邮箱中读取邮件</strong></p></li><li><p>电子邮件地址</p><p>TCP/IP互联网上电子邮件地址一般为：</p><p>local-part@domain-name</p><p>domain-name是邮件服务器域名，而local-part则表示邮件服务器上的用户名邮箱</p></li></ol><h3 id="4-5-2-电子邮件传递协议"><a href="#4-5-2-电子邮件传递协议" class="headerlink" title="4.5.2 电子邮件传递协议"></a>4.5.2 电子邮件传递协议</h3><ol><li><p>简单的邮件传输协议SMTP</p><p>SMTP邮件传输采用客户机/服务器模式，邮件接收程序作为SMTP服务器在TCP的25端口守候</p><p>SMTP邮件传递过程可以分为三个阶段：<strong>连接建立阶段，邮件传送阶段，连接关闭阶段</strong>。</p><p>SMTP的最大特点就是简单和直观，它<strong>不规定邮件的接收程序如何存储邮件，也不规定邮件发送程序多长时间发送一次邮件</strong>，它<strong>只规定发送程序和接收程序之间的命令</strong>，SMTP邮件传输采用<strong>客户机/服务器</strong>模式，在TCP/IP互联网中，邮件服务器之间使用简单邮件传输协议SMTP相互传递电子邮件，也就是说SMTP协议使用传输层的TCP服务，<strong>SMTP响应字符串以3位十进制数字开始</strong></p><p>SMTP常用命令：</p></li></ol><div class="table-container"><table><thead><tr><th>HELO&lt;主机域名&gt;</th><th>开始会话</th></tr></thead><tbody><tr><td>MAIL FROM&lt;发送者的电子邮件地址&gt;</td><td>开始一个邮递处理，指出邮件发送者</td></tr><tr><td>RCPT TO&lt;接收者的电子邮件地址&gt;</td><td>标识单个的邮件接收人；可有多个 RCPT TO；常在 MAIL 命令后面</td></tr><tr><td>DATA</td><td>DATA命令后的数据作为邮件内容处理，直到出现 CR LF CR LF 结束</td></tr><tr><td>NOOP</td><td>无操作，服务器应响应 OK</td></tr><tr><td>RSET</td><td>中止当前邮件处理</td></tr><tr><td>QUIT</td><td>结束会话</td></tr></tbody></table></div><ol><li><p>邮局协议POP3</p><p>POP3本身也采用客户机/服务器模式，当用户需要下载邮件时候，POP客户机首先向POP服务器的TCP守候端口110发送建立连接请求</p><p>POP3邮件传递过程可以分为三个阶段：<strong>认证阶段、事务处理阶段、更新阶段</strong></p><p>| USER             | username 认证用户名                       |<br>| ———————— | ————————————————————- |<br>| PASS             | password 认证密码认证，认证通过则状态转换 |<br>| STAT             | 查询报文总数与长度                        |<br>| LIST[&lt;邮件编号&gt;] | 处理 server 返回指定邮件的大小等          |<br>| RETR&lt;邮件编号&gt;   | 请求服务器发送指定编号的邮件              |<br>| DELE&lt;邮件编号&gt;   | 对指定编号的邮件做删除处理                |<br>| RSET             | 复位操作，清除所有删除标记                |<br>| NOOP             | 无操作                                    |<br>| QUIT             | 删除那些标记成删除的邮件，关闭连接        |</p></li></ol><h3 id="4-5-3-电子邮件的报文格式"><a href="#4-5-3-电子邮件的报文格式" class="headerlink" title="4.5.3 电子邮件的报文格式"></a>4.5.3 电子邮件的报文格式</h3><p>RFC822和多用途Internet邮件扩展协议(Multipurpose Internet Mail Extensions,MIME)对邮件报文格式作出了具体的规定</p><ol><li><p>RFC822</p><p>对邮件的最大限制是邮件体为７位ASCII文本，而且SMTP中又规定传输邮件时将８位字节高位清０</p></li><li><p>多用途Internet邮件扩展协议MIME</p><p><strong>使用Base64编码主要目的是将二进制码转换为ASCII码</strong></p></li></ol><h3 id="4-6-2-系统的传输协议"><a href="#4-6-2-系统的传输协议" class="headerlink" title="4.6.2 系统的传输协议"></a>4.6.2 系统的传输协议</h3><p><strong>超文本传输协议HTTP是Web客户机与Web服务器之间的传输协议，TCP上，是一种面向对象的协议。HTTP精确定义了请求报文和响应报文的格式</strong></p><p>HTTP协议是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。HTTP协议是基于TCP的协议。HTTP协议的请求消息为<strong>一个请求行、请求头、空行和具体的请求内容</strong>。客户端向服务器发送一个请求，服务器以一个状态行作为响应，响应的内容包括：消息协议的版本、成功或者错误编码、服务器信息、实体元信息以及必要的实体内容。结果代码（状态码），<strong>用三个数字表示</strong>。</p><ul><li>请求报文包含一个请求行和若干报头行</li><li>应答报文包含一个状态行和若干报头行，并可能在空行后面有报文体</li></ul><p>Web站点中储存的通常是结构化文档，Web浏览器应能解析HTML文档，Web站点应实现HTTP协议</p><h1 id="第五章-新型网络应用"><a href="#第五章-新型网络应用" class="headerlink" title="第五章 新型网络应用"></a>第五章 新型网络应用</h1><h2 id="5-1-即时通信系统"><a href="#5-1-即时通信系统" class="headerlink" title="5.1 即时通信系统"></a>5.1 即时通信系统</h2><p><strong>以色列Mirabils公司推出了世界上第一款即时通信软件ICQ</strong>（I Seek You网络寻呼机）宣告了“<strong>即时通信（Instant Messsaging，IM）</strong>”这一概念的诞生</p><p>即时通信系统是一种基于Internet的通信服务，可以提供<strong>近实时的信息交换</strong>和<strong>用户状态跟踪</strong></p><h3 id="5-1-1-即时通信系统模型"><a href="#5-1-1-即时通信系统模型" class="headerlink" title="5.1.1 即时通信系统模型"></a>5.1.1 即时通信系统模型</h3><p>IETF批准的<strong>RFC2778</strong>给出了一个抽象的呈现与<strong>即时消息系统模型</strong>，<strong>描述了即时通信系统的功能</strong>，<strong>勾勒了即时通信系统的模型框架</strong></p><p>在RFC2778中，即时消息系统被定义为“允许用户相互订阅并获取彼此状态变更信息，以使用用户间互相收发短信息”</p><h3 id="5-1-2-即时通信系统主要通信模式"><a href="#5-1-2-即时通信系统主要通信模式" class="headerlink" title="5.1.2 即时通信系统主要通信模式"></a>5.1.2 即时通信系统主要通信模式</h3><p><strong>一种是用户/服务器模式，另外一种是用户/用户模式</strong></p><ol><li><p>用户/服务器模式</p><p><strong>文本消息</strong>一般采用此模式，TCP协议</p><p>即时消息服务器一般采用固定服务端口被动地与用户通信</p></li><li><p>用户/用户模式</p><p><strong>文件传输</strong>一般采用此模式</p></li></ol><h3 id="5-1-3-即时通信系统的通信协议"><a href="#5-1-3-即时通信系统的通信协议" class="headerlink" title="5.1.3 即时通信系统的通信协议"></a>5.1.3 即时通信系统的通信协议</h3><p><strong>MSN使用的是MSNP协议，ICQ,AOL使用的是OSCAR协议，QQ采用自己的私有协议(UDP为主,辅以TCP)</strong></p><p>即时通信开放的协议主要代表有两个：<strong>基于SIP协议框架的SIMPLE</strong>（SIP for Instant Messaging and Presence Leverage Extension）协议簇，一个是<strong>基于JABBER协议框架的XMPP</strong>（eXtensible Messaging and Presence Protocol）协议簇</p><p>一个即时通信系统包括两个服务：<strong>呈现服务，即时消息服务</strong></p><ol><li><p>SIP协议</p><p>SIP（Session Initiation Protocol）<strong>会话初始化协议</strong></p><p>所谓一个会话指的是用户之间的一次数据交换过程</p><p>SIP<strong>主要是为了IP网络设计的，可以运行于TCP，UDP,SCTP等各种传输层协议之上</strong></p><p><strong>SIP是一种在IP网络上实现实时通信的应用层的控制（信令）协议</strong></p><p>SIP消息可以分为两类，<strong>请求消息和响应消息</strong></p><p>SIP消息由<strong>一个起始行，消息头，一个标志消息头结束的空行，消息体组成</strong></p><p><strong>起始行分为请求行和状态行</strong></p><p>SIP协议虽然主要是为IP网络设计的，但它并<strong>不关心和依赖特定承载网络</strong>。SIP注册服务器用于接收和处理用户端的注册请求，完成用户地址的注册。在通话初始，需要发送方发送INVITE信息，而<strong>接收方不需要发送INVITE</strong>信息。在信息的传送过程中，可能会<strong>经历多个代理服务器</strong>才会完成信息发送。</p><p>| 请求方法 | 功能                                                         |<br>| ———— | —————————————————————————————— |<br>| INVITE   | 邀请用户或者服务器参加一个会话                               |<br>| ACK      | UA向服务器证实它已经对INVITE请求的最终响应。ACK只和INVITE一起使用 |<br>| OPTIONS  | 请求关于服务器能力的信息。如果服务器认为它能与用户联系，则可用一个能力集响应OPTIONS请求 |<br>| BYE      | 用户终止一次会话，既可由主叫UA发送，也可由被叫UA发送         |<br>| CANCEL   | 取消一个挂起的呼叫                                           |<br>| REGISTER | 向定位服务器注册UA的相关信息                                 |</p><p>BYE:是一种请求消息，请求消息包含请求行，消息头，空行，和消息体。</p></li><li><p>SIMPLE协议</p><p><strong>由IETF制定</strong>，SIMPLE协议通过<strong>对SIP协议进行扩展</strong>，使其支持<strong>即时消息服务</strong></p></li><li><p>XMPP</p><p>XMPP是一种基于XML的即时通信协议，IEFT在4个RFC文档中对该协议进行了定义，其中RFC3920，RFC3922，RFC3923分别对XMPP协议的核心构架，即时通讯方法，XMPP与CPIM的映射，安全性保证等内容进行了定义,使用XMPP的有<strong>Google Talk,Jive Messager</strong></p><p><strong>XMPP实体地址</strong>叫做<strong>JID（Jabber标识）</strong>，它由域标识符、结点标识符、资源标识符三部分组成。形如：node@domain/resource</p><p><strong>系统构架沿用了E-mail系统的构架</strong></p><ul><li><p>XMPP系统构架</p><p>主要由3种实体组成：XMPP客户，XMPP服务器，XMPP网关</p></li><li><p>XMPP系统特点</p><p><strong>用户/服务器中转模式</strong></p><p><strong>分布式网络</strong></p><p><strong>简单客户机端</strong></p></li></ul></li></ol><p>QQ用户登录过程如下：<br>（1）客户端每次登陆时会访问记录上次登陆服务器的地址的记录文件，如果成功则不会重发DNS请求。<br>（2）在QQ通信中，用户必须先登录后才可以进行互相发送信息等。<br>（3）<strong>每次登陆</strong>时QQ客户机会向<strong>服务器获取一个会话密钥</strong>。</p><p>（4）实现成功登录前可能连接多个登录服务器</p><h2 id="5-2-P2P文件共享"><a href="#5-2-P2P文件共享" class="headerlink" title="5.2 P2P文件共享"></a>5.2 P2P文件共享</h2><p>文件共享技术有多种实现方式：<strong>FTP文件共享，NFS网络文件系统共享，Windows共享文件夹，以及P2P文件共享</strong></p><p>P2P网络的主要结构类型分为<strong>集中式，分布式非结构化，分布式结构化和混合式</strong></p><h3 id="5-2-1-P2P文件共享历史"><a href="#5-2-1-P2P文件共享历史" class="headerlink" title="5.2.1 P2P文件共享历史"></a>5.2.1 P2P文件共享历史</h3><p>P2P文件共享起源于<strong>1999年的音乐分享网站Napster</strong>，<strong>集中式对等网络结构</strong></p><ul><li>在<strong>中心服务器端</strong>存放希望共享的文件描述信息</li><li>文件依然存放在用户的本地主机</li></ul><p>2000年3月，另一种P2P文件共享应用<strong>GnutElla</strong>问世，最初<strong>采用分布式非结构化对等网络结构</strong></p><ul><li><p>分布式非结构化P2P网络采用<strong>随机图的组织方式形成一个松散网络</strong>，支持复杂查询</p></li><li><p>优点是配置简单，不需要服务器支持，在规模小时候具有很高的查询效率</p></li><li><p>缺点是<strong>采用TTL，洪泛，随机漫步或者有选择转发算法</strong>，基于广播进行查找，网络拓扑直径不可控，可扩展性较差</p></li></ul><p>2000年9月，<strong>eDonkey2000</strong>出现，继承了GnutElla的共享文件系统优点，并<strong>为文件增加了哈希（hash）信息</strong></p><p>2001年夏，<strong>由MIT开发</strong>的开源BT（BitTorrent 比特洪流）出现，引发互联网文件共享的革命：最初需要中心服务器存放用户信息，该服务器成为Tracker服务器，BT系统要求文件发布者制作一个成为种子的文件（.torrent文件）下载者通过发布者提供的<strong>种子文件链接到Tracker的服务器</strong>，获取其他下载者的IP地址和端口号，下载者得到信息后，可以与其他下载者互连，互连的下载者可以通过种子文件确认已经拥有的文件块，并相互交换各自的没有的文件块，当下载完毕后，<strong>用户自动转换为“做种”模式</strong>，负责上传其他用户所需要的文件块，在整个过程中，<strong>Tracker仅负责提供下载该文件的用户列表</strong>，用户数越多下载速度越快，在后续版本中加入了DHT的支持，以实现无Tracker服务器文件传输</p><p>使用了<strong>分布式结构化拓扑的P2P网络</strong>：<strong>Pastry,Tapestry,Chord,CAN</strong></p><p>分布式结构化拓扑的P2P网络基于<strong>DHT</strong>(分布式散列表)的分布式发现和路由算法。避免了中心服务器，不需要基于广播进行查找，<strong>支持精确关键词匹配查询</strong></p><p>混合式P2P网络：</p><p>索引结点保存可以利用的搜索结点信息、搜集状态信息以及尽力维护网络的结构，一个结点既可以是搜索结点也可以是索引结点。索引结点不会直接连接到有版权的资料，只是搜索所需资料相关的地址，至于用户到底连接下载了什么内容与它无关。</p><h3 id="5-2-2-P2P文件共享的理论基础"><a href="#5-2-2-P2P文件共享的理论基础" class="headerlink" title="5.2.2 P2P文件共享的理论基础"></a>5.2.2 P2P文件共享的理论基础</h3><p><strong>小世界假设，六度分隔理论</strong></p><p>2001年秋，哥伦比亚大学<strong>瓦特斯</strong>通过电子邮件领导验证</p><h3 id="5-2-3-P2P文件共享示例"><a href="#5-2-3-P2P文件共享示例" class="headerlink" title="5.2.3 P2P文件共享示例"></a>5.2.3 P2P文件共享示例</h3><p>Maze:支持<strong>在线资源搜索和文件目录视图</strong>，可以<strong>多点下载</strong>和<strong>断点续传</strong>，采用Maze<strong>积点</strong>和Maze<strong>星级</strong>技术。支持<strong>即时通信BBS</strong>；支持<strong>跨防火墙</strong>的文件共享与下载；支持<strong>在线资源搜索</strong>和<strong>文件目录视图</strong>；支持积点的资源交换体系；采用社交网络的网络链接关系。Maze属于混合型P2P系统，整个系统除了多个Peer外，还包括集中式的<strong>用户管理服务器</strong>、<strong>目录收集服务器</strong>、<strong>检索服务器</strong>、<strong>心跳服务器</strong>和<strong>种子服务器</strong>。为了实现结点的发现与通信策略，采用<strong>分布式认证机制</strong>。混合P2P结构，采用URL表示文件位置，用XML方式检索接口</p><h2 id="5-3-IPTV"><a href="#5-3-IPTV" class="headerlink" title="5.3 IPTV"></a>5.3 IPTV</h2><h3 id="5-3-1-IPTV系统"><a href="#5-3-1-IPTV系统" class="headerlink" title="5.3.1 IPTV系统"></a>5.3.1 IPTV系统</h3><ol><li><p>视频点播</p><p>视频点播(Video On Demond,VOD)也被称为交互式电视点播系统。</p><p>VOD的服务类型分三种，一种是就近式点播电视(Near Video On Demand,NVOD),一种是真实点播电视(True Video On demand,TVOD),还有一种是交互式点播电视(Interactive Video On Demand,IVOD)</p><ul><li>NVOD:每个视频流间隔一定时间就发送同样的内容，用户选择距最近的某个时间起点进行收看。</li><li>TVOD:支持即点即放，当用户提出请求时，视频服务器立即传送用户所需的视频内容。每个视频流只为一个用户服务</li><li>IVOD:不仅支持即点即放，而且还可以让用户对视频流进行交互式控制，实现播放倒回快进等功能</li></ul></li></ol><h3 id="5-3-2-IPTV关键技术"><a href="#5-3-2-IPTV关键技术" class="headerlink" title="5.3.2 IPTV关键技术"></a>5.3.2 IPTV关键技术</h3><ol><li><p>媒体内容分发技术</p><p>媒体内容分发网络(Media Content Delivery Network,MCDN)技术是IPTV大规模应用的重要保障</p><ul><li>内容发布：将<strong>内容发布或投递</strong>到距离用户<strong>最近的</strong>远程服务点</li><li>内容路由：整体性的网络<strong>负载均衡技术</strong>，利用<strong>应用层</strong>的技术，保证<strong>用户得到最近内容源</strong>的响应</li><li>内容交换：利用<strong>应用层</strong>交换，流分裂，重定向及宽带媒体分发策略等技术，智能地<strong>平衡负载流量</strong></li><li>性能管理：获取网络部件的状态信息，另外测量内容发布的端到端性能，<strong>保证网络处于最佳运行状态</strong></li><li>IP承载网：利用IP网络技术，为IPTV应用<strong>提供可靠的IP网络平台</strong></li></ul></li><li><p>数字版权管理技术</p><ul><li>数据加密</li><li>版权保护</li><li>数字水印</li></ul></li><li><p>IPTV运营支撑管理系统</p></li></ol><h2 id="5-4-VoIP"><a href="#5-4-VoIP" class="headerlink" title="5.4 VoIP"></a>5.4 VoIP</h2><p>VoIP（Voice over IP）俗称IP电话（Internet Protocol Phone）。IP电话系统有4个基本组件：终端设备、网关、多点控制单元和网守。终端设备（Terminal）是一个IP电话客户终端，可以是软件。网关是通过IP网络提供语音通信的关键设备，是IP网络和PSTN（Public Switched Telephone Network，公用电话交换网简称电话网）网络之间的接口设备，从网络的角度看，它就是一个H.323设备。多点控制单元MCU（Multipoint Control Unit）的功能在于利用IP网络实现多点通信。网守（Gatekeeper）主要负责用户的注册和管理等。</p><h3 id="5-4-2-VoIP系统组成"><a href="#5-4-2-VoIP系统组成" class="headerlink" title="5.4.2 VoIP系统组成"></a>5.4.2 VoIP系统组成</h3><ol><li><p>IP电话网关，是IP网络和电话网络之间的桥梁</p><p>基本功能：<strong>号码查询，建立通信连接（信号调制），路由寻址</strong></p></li><li><p>网守</p><p>网守是一个中央控制实体，在VoIP系统中起管理作用。</p><p>网守是VoIP系统中的<strong>消息控制中心</strong>，可以进行<strong>呼叫控制，地址解析，呼叫授权，身份验证，集中账务和计费管理</strong>，<strong>存留呼叫详细记录</strong>等操作。</p><p>网守还可以像实时网管一样<strong>监控网络，平衡负载，管理带宽以及提供与现有系统的接口</strong>。</p></li></ol><h3 id="5-4-4-VoIP实例"><a href="#5-4-4-VoIP实例" class="headerlink" title="5.4.4 VoIP实例"></a>5.4.4 VoIP实例</h3><p>Skype是著名Kazaa软件创始人Niklas推出的一款Internet即时语音通信软件</p><ol><li>基本概念<ul><li>SkypeClient:SC,SKype系统客户机</li><li>SuperNode:SN，动态生成，作用像Internet中的核心路由器，每个SC根据其内存，带宽以及上线时间为因素，都有可能被选为SN</li><li>其他见书本</li></ul></li><li>超级结点（SN）的作用就像是因特网中的核心路由器，负责客户端的连接。好友列表（Buddy List）经过了数字化签名和加密处理，不是明文存储。<strong>Skype采用了256 bit的AES加密算法，以及混合式网络拓扑</strong>。</li></ol><h2 id="5-5-网络搜索技术"><a href="#5-5-网络搜索技术" class="headerlink" title="5.5 网络搜索技术"></a>5.5 网络搜索技术</h2><h3 id="5-5-2-搜索引擎的主要内容"><a href="#5-5-2-搜索引擎的主要内容" class="headerlink" title="5.5.2 搜索引擎的主要内容"></a>5.5.2 搜索引擎的主要内容</h3><p><strong>搜索器，索引器，检索器，用户接口</strong></p><h1 id="第六章-网络管理与网络安全"><a href="#第六章-网络管理与网络安全" class="headerlink" title="第六章 网络管理与网络安全"></a>第六章 网络管理与网络安全</h1><h2 id="6-1-网络管理技术"><a href="#6-1-网络管理技术" class="headerlink" title="6.1 网络管理技术"></a>6.1 网络管理技术</h2><h3 id="6-1-1-网络管理的概念"><a href="#6-1-1-网络管理的概念" class="headerlink" title="6.1.1 网络管理的概念"></a>6.1.1 网络管理的概念</h3><p>通常涉及：网络提供，网络维护，网络管理</p><p>ISO定义网管模型包括４个部分：<strong>组织模型，信息模型，通信模型与功能模型</strong></p><p>组织模型:描述网管系统的组成部分和结构</p><p>信息模型：网管系统的对象命名和结构</p><p>通信模型：网管系统使用的网管协议</p><p>功能模型：网管系统的主要功能</p><p><strong>网络管理模式通常为集中式网络管理或管理者－网管代理模型</strong></p><h3 id="6-1-2-网络管理功能域"><a href="#6-1-2-网络管理功能域" class="headerlink" title="6.1.2 网络管理功能域"></a>6.1.2 网络管理功能域</h3><p>网络管理功能域定义的是主要的网管功能，并将这些功能划分为５个部分：<strong>配置管理，故障管理，性能管理，安全管理与记账管理</strong></p><p>配置管理：中长期，网络增容，设备更新，新技术应用，新业务开通，新用户加入，业务撤销，用户迁移</p><p>故障管理：<strong>发现与排除故障，保证网络资源无障碍无错误运营</strong>，包括障碍管理，故障恢复，预防故障，故障管理包括检测隔离纠正故障</p><p>性能管理：测试性能指标，包括吞吐率，利用率，响应时间，传输延时等，性能管理可以分为两个部分：<strong>性能监控和网络控制</strong>，性能监控收集网络状态信息，网络控制值为改善性能采用的措施</p><p>安全管理：<strong>控制与维护对网络资源的访问权限，安全服务设施的建立控制与删除</strong>，信息分发，事件通知，网络操作记录维护</p><p>计费管理：控制监控网络操作的费用与代价，还进行网络资源利用率的统计和网络的成本效益的核算</p><h3 id="6-1-3-网络管理系统"><a href="#6-1-3-网络管理系统" class="headerlink" title="6.1.3 网络管理系统"></a>6.1.3 网络管理系统</h3><p>网络管理系统(Network Management System,NMS)通常称为网管系统，是用来实现网管功能的软件或硬件系统。</p><p><strong>管理对象</strong>是经过抽象的网络元素，对应于网络中具体可以操作的数据，例如网络设备的工作参数，网络性能的统计参数等。<strong>管理对象相关信息储存在MIB中，每个网管系统都需要MIB的支持</strong></p><p>网络管理涉及到网络中的各种资源，可分为两大类：硬件资源和软件资源。<br>硬件资源是指物理介质、计算机设备和网络互联资源。物理介质通常是物理层设备、如网卡、双绞线等；计算机设备包括打印机和存储设备及其他计算机外围设备；常用的网络互联设备有中继器、网桥、路由器、网关等。软件资源主要包括操作系统、应用软件和通信软件。</p><p><strong>管理协议</strong>负责在网络工作站与网络设备的管理进程之间通信，传输信息包括发送的操作命令与返回的操作结果。</p><p>网管系统通常分为两类：网元管理系统(Element Management System,EMS)只负责管理单独的网络元素（网络设备）。另一种是通用的网络管理系统(Network Management System,NMS)负责管理整个网络而不是单个设备，通常用于掌握整个网络的工作状态，作为作为底层的网络平台服务于EMS.</p><h3 id="6-1-4-网络管理协议"><a href="#6-1-4-网络管理协议" class="headerlink" title="6.1.4 网络管理协议"></a>6.1.4 网络管理协议</h3><ol><li><p>SNMP协议</p><p><strong>Internet工程任务组(Internet Engineering Task Force,IETF)是很多互联网标准的制定者，制定了简单网络管理协议(Simple Network Management Protocol,SNMP)</strong>是一种面向Internet的网管协议，针对的管理对象是各种网络设备</p><p>1987年IETF制作了简单网关协议(Simple Gateway Monitoring Protocol,SGMP)，<strong>SNMP协议在SGMP的基础上建立起来的。</strong></p><p>第一个版本设计简单，易于实现，<strong>第二个版本增加了操作类型与支持多层传输层协议，第三个版本提供了安全与改进的框架结构。</strong></p><p>由于开始的SNMP没有考虑安全问题，SNMPv2开始在提供安全性<strong>(安全性不是重点内容)</strong>和更有效的传递管理信息方面加以改进，具体包括提供验证、加密和时间同步机制。SNMPv3的重点是安全、可管理的体系结构和远程配置。</p><p>SNMP是一种<strong>应用层的协议</strong>，采用客户机/主机的形式</p><p>SNMP在传输层采用支持无线连接服务的<strong>UDP</strong>协议。网络设备的管理信息可以分为很多类型，并<strong>保存在MIB的管理对象中</strong>。SNMP协议采用<strong>轮询监控方式</strong>，管理器定时想代理请求获得管理信息，并根据返回信息判断是否发生异常。</p><p>MIB（管理信息库）是一个数据库，它代表了某个设备或服务的一套可管理对象。由SNMP管理的<strong>每台主机必须有一个MIB</strong>，它描述了该主机上的可管理对象。所有的MIB必须用精确的组织结构定义。SNMP管理器在与其他代理连接时，通过MIB中的信息，来识别该代理上的信息是如何组织的。</p><p>SNMP从被管理设备中收集数据有两种方法：<strong>一种是轮询（polling）方法，另一种是基于中断（interrupt-based）的方法</strong></p><p>管理器和代理是一对多关系</p><p>RMON提供补充功能</p></li><li><p>CMIP协议</p><p><strong>ISO制定</strong>的通用管理信息服务(Common Management Information Service,CMIS)与通用管理信息协议(Common Management Information Protocol,CMIP)</p><p>CMIP是一种<strong>应用层的协议</strong></p><p>CMIP<strong>建立在OSI模型基础上</strong></p><p>在<strong>传输层采用支持有连接服务的协议</strong>，例如OSI模型定义的TP3协议，CMIP系统<strong>传输信息之前需要预先建立连接。</strong></p><p>采用委托监控机制</p></li></ol><h2 id="6-2-网络安全的概念"><a href="#6-2-网络安全的概念" class="headerlink" title="6.2 网络安全的概念"></a>6.2 网络安全的概念</h2><h3 id="6-2-2-网络安全服务与法律法规"><a href="#6-2-2-网络安全服务与法律法规" class="headerlink" title="6.2.2 网络安全服务与法律法规"></a>6.2.2 网络安全服务与法律法规</h3><ol><li><p>网络安全服务应该提供以下基本保障：</p><ol><li>可用性：尽管可能存在突发事件（自然灾害，突然断电，事故等）情况下，网络仍然可以正常运转，用户可以使用各种网络服务</li><li>机密性：保证网络中的数据不馁非法截获或非授权访问，保护敏感数据和涉及个人隐私信息的安全</li><li>完整性：保证数据完整，没有被修改，插入或删除</li><li>不可否认性：确认通信参与者的身份真实性，防止对已发送或接受的信息否认的现象出现</li><li>可控性：控制与限定网络用户对主机系统，网络服务与网络信息资源的访问和使用，防止非授权用户读取写入删除数据</li></ol></li><li><p>网络安全的法律法规：</p><p><strong>美国政府定制</strong>的可信用计算机系统评估准则(TC-SEC-NCSC)将计算机系统安全等级分为４类７个等级，即D,C1,C2,B1,B2,B3与A1,<strong>Ｄ级系统安全级别最低，A1级系统的安全要求最高</strong></p><p>D:非安全保护类，C:自主保护类型，B:强制型安全保护类，A1:相对B在安全审计，安全测试，配置管理等方面提出更高要求</p><p>D1是最小的保护级别。主要特征是保护措施很少，没有安全功能。</p><p>C1是有选择的安全保护。主要特征是有选择的存取控制，用户与数据分离，数据保护以用户组为单位。<br>C2是受控的访问控制。主要特征是存取控制以用户为单位，广泛的审计。<br>B1是标记安全保护。除了C2级的安全要求外，增加安全策略模型，数据标号（安全和属性），托管访问控制等。<br>B2是结构化安全保护。设计系统时必须有一个合理的总体设计方案，面向安全的体系结构，遵循最小授权原则，具有较好的抗渗透能力，访问控制应对所有的主体和客体进行保护，对系统进行隐蔽通道分析。<br>B3是安全域机制保护。安全内核，高抗渗透能力。<br>A1可验证安全设计。形式化的最高级描述和验证，形式化的隐秘通道分析，非形式化的代码一致性证明。</p><p>在我国，以《计算机信息系统安全保护等级划分准侧》为标准。</p><p>ITSEC欧洲信息安全评估标准</p></li></ol><h3 id="6-2-4-网络攻击的主要类型"><a href="#6-2-4-网络攻击的主要类型" class="headerlink" title="6.2.4 网络攻击的主要类型"></a>6.2.4 网络攻击的主要类型</h3><p><strong>主动攻击：拒绝服务攻击（DoS），分布式拒绝服务(DDoS)，信息篡改，资源使用，欺骗（如源路由攻击），伪装（如邮件炸弹），重放等攻击方法</strong></p><p><strong>服务攻击(与主动攻击不是并列关系)：针对某特定网络服务攻击，如针对Email，FTP，HTTP等服务攻击，如对Telnet的23号端口，对HTTP的80端口，邮件炸弹等</strong></p><ol><li><p>DoS与DDoS</p><ol><li><p>DoS的分类与特征</p><p>拒绝服务攻击(Denial of Service,DoS)利用合理的理由通过发送一定数量，一定序列的报文，使网络服务器中充斥大量要求回复的信息，消耗网络带宽或系统资源，导致服务器不能正常工作，甚至瘫痪。</p></li><li><p>DDoS攻击的特征</p><p>典型的DDoS攻击采用三层结构：攻击控制层，攻击服务层，攻击执行层。</p><p>真正的攻击者处于攻击控制层的位置，为了防止被跟踪和追查，攻击者首先通过漏洞扫描方式选择安全性较差的计算机作为被控制对象（即攻击服务器）,向攻击服务器传播恶意攻击程序，通过攻击服务器去发展下一级的攻击执行器，攻击执行器也称为“傀儡机”。在向攻击服务器发出攻击命令后，攻击控制台立即车里，不参加之后的攻击行动。</p><p>特点：</p><ol><li>被攻击的主机上可能有大量等待应答的TCP连接</li><li>网络中充斥着大量无用网络数据包，并且数据包的源地址是伪造的</li><li>大量无用数据包造成网络拥塞，使得网络工作不正常，甚至瘫痪</li><li>被攻击的主机可能在攻击发起之后短短几秒后就处于瘫痪状态</li><li>攻击服务器和傀儡机都是在不知情下参与的，真正攻击者早已消失</li></ol></li><li><p>僵尸网络特征</p><p>控制者出于恶意目的，传播僵尸病毒，控制大量主机，通过一对多的命令与控制信道主城网络，实施DDoS攻击，僵尸网络是一种典型的植入威胁攻击</p></li></ol></li></ol><h2 id="6-3-加密与认证技术"><a href="#6-3-加密与认证技术" class="headerlink" title="6.3 加密与认证技术"></a>6.3 加密与认证技术</h2><p><strong>唯密文攻击</strong>指的是在仅知已加密文字的情况下进行穷举攻击。</p><p><strong>已知明文攻击</strong>指攻击者掌握了某段明文和对应密文，推断加密方式，从而破解后段密文的攻击方式。</p><p><strong>选择明文攻击</strong>是指攻击者不仅已知加密算法和密文，而且还能够通过某种方式让发送者在发送的信息中插入一段由他选择的信息。</p><p><strong>选择密文攻击</strong>的密码分析者事先任意搜集一定数量的密文，让这些密文透过被攻击的加密算法解密，透过未知的密钥获得解密后的明文。</p><h3 id="6-3-2-对称密码体系"><a href="#6-3-2-对称密码体系" class="headerlink" title="6.3.2 对称密码体系"></a>6.3.2 对称密码体系</h3><ol><li><p>典型的对称加密算法</p><p>数据加密标准(Data Encrytion Stardard,DES)是最典型的<strong>对称加密算法</strong>，<strong>由IBM公司提出，经ISO认定的国际标准</strong>。DES每次处理一个<strong>64位的明文分组</strong>，并且每次生成一个64位的密文分组。</p><p>DES有<strong>56位密钥长度</strong>。<strong>基于置换和代换技术</strong>，基于<strong>整数有限域离散对数难题</strong>，和RSA安全性差不多。DES算法加密过程中每轮操作都有置换和代换，<strong>每轮置换函数相同</strong></p><p>高级加密算法(Advanced Encrytion Stardard,AES)是后来出现的一种<strong>对称加密算法</strong>，<strong>由NIST制定</strong>，AES将数据分为固定大小的分组，以分组为单位进行加密或解密。<strong>AES算法安全性能不低于3DES，同时具有良好的执行性能，运行速度比3DES速度快。密钥长度为128、192和256位，分组长度为128位。</strong></p><p>其他对称加密算法包括:IDEA,Blowfish,RC2,RC4,RC5,CAST等</p><p>Blowfish算法是有Bruce Schneider设计的算法，是一个可变密钥长度的分组算法，分组长度为64位，Blowfish算法所有的运算都是32位字的加法和异或，仅有的另一个运算时每轮的四个查表。</p><p>背包加密算法是一种公钥加密算法，该算法中背包的物品总重量是公开的，所有可能的物品也是公开的，但是背包中的物品却是保密的，它是一个NP难度问题。目前大多数一次背包体制均被破译了，一次背包已不安全了</p></li></ol><h3 id="6-3-3-非对称密码体系"><a href="#6-3-3-非对称密码体系" class="headerlink" title="6.3.3 非对称密码体系"></a>6.3.3 非对称密码体系</h3><ol><li><p>典型的非对称加密算法</p><p>RSA是一种典型的公钥加密算法，它在网络安全领域得到广泛应用，RSA算法的安全性建立在大素数分解极其困难的基础之上。是由Ron Rivest,Adi Shamir,Leonard Adleman设计的一种算法。</p><p>其他非对称加密算法主要包括DSS,ElGamal与Diffie-Hellman等</p><p>ElGamal:基于公钥秘钥体制和椭圆曲线加密体系，属于非对称加密，加密过程中，生成的密文长度是明文的两倍，基于离散对数，常用于数字签名。</p><p>数据加密标准DES属于堆成加密算法，DSA与ElGamal属于公钥加密</p></li></ol><h3 id="6-3-4-公钥基础设施"><a href="#6-3-4-公钥基础设施" class="headerlink" title="6.3.4 公钥基础设施"></a>6.3.4 公钥基础设施</h3><ol><li><strong>公钥基础设施(Public Key Infrastructure,PKI)是利用公钥加密和数字签名技术建立的安全服务基础设施，以保证网络环境中的数据的秘密性完整性和不可抵赖性。</strong></li></ol><h3 id="6-3-5-数字签名技术"><a href="#6-3-5-数字签名技术" class="headerlink" title="6.3.5 数字签名技术"></a>6.3.5 数字签名技术</h3><p>数字签名是笔迹签名的模拟，<strong>公钥密码体制和私钥密码体制都可以用于数字签名</strong>，验证时需要使用相同的散列函数，并且<strong>通过比较消息摘要是否匹配</strong>来验证签名的正确性。</p><ol><li><p>数字签名的工作原理</p><ol><li><p>目前广泛使用的数字签名算法是消息摘要(Message Digest,MD5)</p><p>MD5没有对数据进行加密或者修改，<strong>可对任意长度的数据生成128位散列值，没有对数据加密或者修改，只是生成一个用于判断完整性与真实性的散列值</strong></p></li></ol></li></ol><h2 id="6-4-网络安全协议"><a href="#6-4-网络安全协议" class="headerlink" title="6.4 网络安全协议"></a>6.4 网络安全协议</h2><h3 id="6-4-1-网络安全协议的概念"><a href="#6-4-1-网络安全协议的概念" class="headerlink" title="6.4.1 网络安全协议的概念"></a>6.4.1 网络安全协议的概念</h3><p><strong>在主机－网络层（数据链路层对应它的一部分）中，主要的安全协议包括PPTP,L2TP与L2F等</strong></p><p><strong>在互联层（或网络层）中，最主要的安全机制是IPSec的两个组成协议，即认证头部(AH)与封装安全有效载荷（ESP）</strong></p><p><strong>在传输层中，主要的安全协议包括SSL,SSH,TLS与SOCKS等。</strong></p><p>https是以安全为目标的HTTP通道，简单讲是HTTP安全版，即HTTP+SSL，HTTPS安全基础是SSL。如果用户想在Web上使用SSL协议URL必须使用https开头</p><p>SSL最初由Netscape公司定制，SSL以及其继任者TLS，是为了为网络通信提供安全以及数据完整性的一种安全协议，TLS与SSL在传输层对网络进行加密，用于保障网络数据传输安全，利用数据加密技术，，确保数据在网络传输过程中不被截取与窃听，所有主要浏览器和Web服务器支持SSL，可以通过安装SSL证书激活SSL协议。</p><p><strong>在应用层中针对不同的网络服务或应用的安全机制比较多，例如PGP,SET,用于增强Web安全的S-HTTP,用于保障邮件安全的S/MIME,用于电子商务安全交易的SET等</strong></p><h3 id="6-4-2-网络安全与IPSec"><a href="#6-4-2-网络安全与IPSec" class="headerlink" title="6.4.2 网络安全与IPSec"></a>6.4.2 网络安全与IPSec</h3><ol><li><p>IPSec安全体系结构</p><p>IPSec主要包含３个组成部分，<strong>认证头(Authentication Header,AH)，封装安全负载(Encapsulating Security Payload,ESP)与密钥管理协议</strong></p><p>IPSec工作模式分两种，<strong>隧道模式和传输模式</strong></p></li><li><p>AH协议的工作原理</p><p>可工作在隧道模式与传输模式</p></li><li><p>ESP协议工作原理</p><p>可工作在隧道模式与传输模式</p></li></ol><p>浏览器安全性：</p><ol><li><strong>将Web站点放入可信站点区可以保证信息传输的机密性</strong></li><li><strong>在浏览器中添加证书可以验证Web站点的真实性</strong></li><li><strong>索要Web站点的证书可以表明浏览器的身份</strong></li><li><strong>使用SSL技术可以防止病毒的传播</strong></li></ol><h3 id="6-4-4-应用层安全与PGP-SET"><a href="#6-4-4-应用层安全与PGP-SET" class="headerlink" title="6.4.4 应用层安全与PGP,SET"></a>6.4.4 应用层安全与PGP,SET</h3><ol><li><p>PGP</p><p>PGP（Pretty Good Privacy，相当好的私密性）是一个安全电子邮件加密软件，它主要由5种服务组成：<strong>鉴别、机密性、压缩、电子邮件的兼容性和分段</strong>，<strong>支持多语种安装平台</strong>。数字签名使用DSS/SHA或RSA/SHA算法，<strong>报文加密采用CAST或IDEA，或使用Diffie-Hellman的3DES或RSA算法。</strong><br>PGP也提供了公共密钥认证机制，但是这个机制完全不同于通用的认证中心（CA）。PGP公共密钥通过委托网站进行认证，它也可以通过互联网上的PGP公共密钥服务器发布。</p></li></ol><p>包括<strong>电子邮件的加密，身份验证，数字签名</strong>等安全功能。</p><p>   在PGP协议中需要两个不同的加密过程：<strong>明文加密与对称密钥的加密</strong></p><p>   PGP2数字签名能够保证邮件的完整性，身份认证与不可抵赖性，数据加密可以保证邮件内容的机密性</p><h2 id="6-5-防火墙技术"><a href="#6-5-防火墙技术" class="headerlink" title="6.5 防火墙技术"></a>6.5 防火墙技术</h2><h3 id="6-5-1-防火墙概念"><a href="#6-5-1-防火墙概念" class="headerlink" title="6.5.1 防火墙概念"></a>6.5.1 防火墙概念</h3><p>防火墙的基本部件是：包过滤路由器，应用级网关</p><p>通常应用于内部网络与外部网络之间</p><p>可通过软硬件实现</p><h3 id="6-5-2-包过滤路由器"><a href="#6-5-2-包过滤路由器" class="headerlink" title="6.5.2 包过滤路由器"></a>6.5.2 包过滤路由器</h3><p>包过滤路由器作用于网络层上</p><p>检查每个分组的源地址，目的地址，决定该分组是否应该转发。</p><p>包过滤路由器会检查TCP报头的端口号和字节，通常基于部分或全部报头内容，例如对TCP报头信息，可以是源地址，目的地址，协议类型，IP选项，源端口号，目的端口号，TCP,ACK等标识</p><h3 id="6-5-3-应用级网关"><a href="#6-5-3-应用级网关" class="headerlink" title="6.5.3 应用级网关"></a>6.5.3 应用级网关</h3><p>应用代理是应用级网关的另一种形式</p><h1 id="题目心得："><a href="#题目心得：" class="headerlink" title="题目心得："></a>题目心得：</h1><ol><li><p>51题左右：</p><p>关键词：“ping不通”</p><p>首先判断是否在一个子网，如果不在一个子网则是因为不在一个子网。如果在一个子网，如果题目说不是一个VLAN则选不在一个VLAN，ping不通与操作系统无关</p></li><li><p>有限广播地址：255.255.255.255</p><p>直接广播地址：网络号+一个全“1”的主机号</p></li><li><p>混合P2P网络包含节点种类：用户节点，搜索节点，索引结点</p></li><li><p><strong>ISO制定了：CMIP，CMIS，OSI参考模型</strong></p><p><strong>IETF：TCP/IP 参考模型，RFC2778，SIMPLE协议，SNMP协议,IPSec，SIP</strong></p></li><li><p><strong>为了保护自己的计算机免受非安全软件的危害，浏览器通常采用的方法是将Internet世界划分为不同的区域（如Internet区域、本地Internet区域、可信站点区域、受限站点区域）</strong></p></li><li><p><strong>为了避免他人假冒自己，用户可以在浏览器安装自己的数字证书</strong></p><p><strong>将Web站点放入可信站点区可以保证信息传输的机密性</strong></p><p><strong>在浏览器中添加证书可以验证Web站点的真实性</strong></p><p><strong>索要Web站点的证书可以表明浏览器的身份，验证站点的真实性</strong></p><p><strong>使用SSL技术可以防止病毒的传播，避免第三方偷看</strong></p><p><strong>使用Base64编码主要目的是将二进制码转换为ASCII码</strong></p></li><li><p>Web服务采用客户机/服务器工作模式</p><p>Web服务以超文本方式组织网络多媒体信息</p><p>Web<strong>服务器需要实现HTTP协议</strong></p><p>用户访问Web服务器可以使用图形界面</p><p>Web浏览器的解释单元<strong>负责解析从服务器发送回来的数据</strong></p><p>浏览器组成为：<strong>控制单元，客户单元，解释单元</strong></p></li><li><p>广域网的研究重点是核心交换技术</p></li><li><p>共享介质以太网核心是<strong>集线器</strong>，支持全双工</p></li><li><p>局域网交换机核心核心技术包括端口/MAC地址映射</p></li><li><p>54题附近：</p><p>从使用者来看，Internet是一个资源网</p><p>从设计者来看，Internet是计算机互联网络的实例/IP互联网</p><p>Internet利用路由器实现异构网络互联</p><p>Internet主要组成部分包括四个部分：通信线路，路由器，主机和信息资源。</p></li><li><p>个人区域网（WPAN,Wireless Personal）</p><p>个人局域网(PAN,Personal)  </p><p>局域网(LAN,local)  </p><p>城域网(MAN,metropolitian)  </p><p><strong>广域网(WAN,wide)</strong> </p><p><strong>无线自组网（WAN,Wireless ad hoc network）</strong></p><p>无线局域网(WLAN,Wireless Local)</p><p>无线网状网(WMN,wireless mesh network)</p></li><li><p>VLAN技术：</p><p>虚拟局域网是<strong>建立在交换式技术的基础上</strong>，以软件方式实现逻辑工作组的划分与管理，工作组中的结点不受物理位置的限制。常见的组网方式包括：<strong>用交换机端口定义虚拟局域网、用MAC地址定义虚拟局域网、用网络层(IP)地址定义虚拟局域网、基于广播组的虚拟局域网。</strong></p></li><li><p>信息存储安全措施至少要包括三类：（1）社会的法律政策、企业的规章制度及网络安全教育；（2）技术方面的措施，如防火墙技术、防病毒、信息加密、身份确认以及授权即设置访问权限等；（3）审计与管理措施，包括技术与社会措施。主要有实时监控、提供安全策略改变的能力以及对安全系统实施漏洞检查等。</p></li><li><p>欧洲原子核研究委员会（CERN）的 Tim Berners-Lee 开发了一个协议，用来解决复杂进化系统中的信息丢失问题，并提出一个基于分布式超文本系统的解决方法，Web 因此诞生。Web服务采用客户机/服务器工作模式，Web服务以超文本方式组织网络多媒体信息，<strong>Web服务器需要实现HTTP协议</strong>，存储了用户共享的信息，用户访问Web服务器可以使用图形界面，Web浏览器的解释单元负责解析从服务器发送回来的数据。</p></li><li><p>UNIX操作系统，是一个多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统。Unix从第三版内核开始使用C语言。Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。</p></li><li><p><strong>ASN.1</strong>抽象语法标记（Abstract Syntax Notation One） ASN.1是一种 ISO/ITU-T 标准，描述了一种对数据进行表示、编码、传输和解码的数据格式，ISO 协议套中的应用层协议使用了 ASN.1 来描述它们所传输的 PDU，这些协议包括：用于传输电子邮件的 X.400、用于目录服务的 X.500、用于 VoIP 的 H.323 和 SNMP（简单网络管理协议）。ASN.1 取得成功的一个主要原因是它与几个标准化编码规则相关，如基本编码规则（BER） -X.209 、规范编码规则（CER）、识别名编码规则（DER）、压缩编码规则（PER）和 XML编码规则（XER）。<br><strong>Unicode</strong>（统一码、万国码、单一码）是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。<br><strong>Base64</strong>是网络上最常见的用于传输8Bit字节代码的编码方式之一，可用于在HTTP环境下传递较长的标识信息。Base64 也会经常用作一个简单的“加密”来保护某些数据，而真正的加密通常都比较繁琐。Mozilla Thunderbird和Evolution用Base64来保密电子邮件密码<br><strong>Quoted-printable</strong>是使用可打印的ASCII字符 (如字母、数字与”=”)表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据。这被定义为MIME content transfer encoding，用于e-mail。</p><p>邮件编码常用后两者</p></li><li><p>HTML是一种标记语言、用于描述文档结构，是Web世界的共同语言，浏览器应能解释符合HTML标准的页面且多个符合HTML标准的页面可相互链接。</p></li><li><p>LAMP（Linux- Apache-MySQL-PHP）网站架构是目前国际流行的Web框架，该框架包括：Linux操作系统，Apache网络服务器，MySQL数据库，Perl、PHP或者Python编程语言，所有组成产品均是开源软件，是国际上成熟的架构框架。该架构起源于Linux平台，由于是开源软件，建设成本很低。</p></li><li><p>Ethernet交换机转发帧可以采用直接交换方式、存储转发交换方式或者改进的直接交换方式。通常采用端口号/MAC地址映射表，支持虚拟局域网服务。</p></li><li><p>POP3邮件传递过程可以分为三个阶段：认证阶段、事务处理阶段、更新阶段</p><p>SMTP邮件传递过程可以分为三个阶段：连接建立阶段，邮件传送阶段，连接关闭阶段</p></li><li><p>NetBIOS是由IBM开发，工作于网络层驱动接口和传输层驱动接口之间，支持254个并发通信话路，名字服务可以采用UDP协议。</p></li><li><p>跳频扩频通信（Frequence Hopping Spread Spectum），英文缩写为FHSS，直接序列扩频（Direct Sequence Spread Spectrum），英文缩写为DSSS，点协调功能（Point Coordition Function），英文缩写为PCF，分布式协调功能（Distributed Coordition Function），英文缩写为DCF，虚拟监听（Virtual Carrier Sense），英文缩写为VCS</p></li><li><p>消息认证就是使意定的接收者能够检验收到的消息是否真实的方法，又称为<strong>完整性校验</strong>。信息的完整性认证方法的基本途径有两条：<strong>采用消息认证码（MAC）、采用篡改检测码（MDC）</strong>。消息认证方法很多，如认证信息的来源时可以采用通信双方事先约定各自发送消息所使用的通行字的方法，<strong>不需要使用公钥</strong>。密钥分发中心（KDC）是一个独立的可信网络实体，它可以为用户提供不同的对称密钥，<strong>当不采用公钥算法进行消息认证时，并不需要使用KDC，</strong></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>计算机四级</tag>
      
      <tag>知识点整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manimTutorial</title>
    <link href="/2020/03/26/manimtutorial/"/>
    <url>/2020/03/26/manimtutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="manim基础教程"><a href="#manim基础教程" class="headerlink" title="manim基础教程"></a>manim基础教程</h1><p>注意：  </p><ol><li>本文参考YouTube主Theorem of Beethoven的视频与代码然后自己继续研究得到的，有些图片是ta视频截图得到的，可以说是他的教程文字化后的汉化版，根据GitHub主页，他来自墨西哥国立自治大学，感谢外国大佬的力量，除了自己写的部分的代码，有些代码来自TA的视频与GitHub，其人<a href="https://github.com/Elteoremadebeethoven" target="_blank" rel="noopener">GitHub主页</a>，大家有条件可以支持一下他的YouTube  </li><li>本人将于2019年9月2日开学，到时候可能忙于学业，不能做到跟进视频更新教程，其实目前教程已经大概涵盖70%的东西，到后面主要是自己读源代码自己分析，python基础很重要，有时间我还是会尽量更新的  </li><li>此教程虽在开源社区，但是请勿未经我允许转载，希望大家能共同维护个人劳动成果与开源精神</li><li>如果文档有错误或漏洞，或者有问题，欢迎在issue中提出，大家一起讨论，共同创建良好的学习环境</li></ol><h2 id="1-文件的执行"><a href="#1-文件的执行" class="headerlink" title="1. 文件的执行"></a>1. 文件的执行</h2><p><strong>命令行执行：<code>python -m manim \path\to\yourfile.py [className] [-params]</code></strong></p><pre><code class="hljs text">usage: manim.py [-h] [-p] [-w] [-s] [-l] [-m] [--high_quality] [-g] [-i] [-f]                [-t] [-q] [-a] [-o FILE_NAME] [-n START_AT_ANIMATION_NUMBER]                [-r RESOLUTION] [-c COLOR] [--sound] [--leave_progress_bars]                [--media_dir MEDIA_DIR]                [--video_dir VIDEO_DIR | --video_output_dir VIDEO_OUTPUT_DIR]                [--tex_dir TEX_DIR] [--livestream] [--to-twitch]                [--with-key TWITCH_KEY]                [file] [scene_names [scene_names ...]]positional arguments:  file                  path to file holding the python code for the scene  scene_names           Name of the Scene class you want to seeoptional arguments:  -h, --help            show this help message and exit  -p, --preview         Automatically open the saved file once its done  -w, --write_to_movie  Render the scene as a movie file  -s, --save_last_frame  Save the last frame  -l, --low_quality     Render at a low quality (for faster rendering)  -m, --medium_quality  Render at a medium quality  --high_quality        Render at a high quality   -g, --save_pngs       Save each frame as a png    -i, --save_as_gif     Save the video as gif  -f, --show_file_in_finder Show the output file in finder    -t, --transparent     Render to a movie file with an alpha channel    -q, --quiet  -a, --write_all       Write all the scenes from a file  -o FILE_NAME, --file_name FILE_NAME  Specify the name of the output file, ifit should be                        different from the scene class name  -n START_AT_ANIMATION_NUMBER, --start_at_animation_number     START_AT_ANIMATION_NUMBER                        Start rendering not from the first animation,   butfrom another, specified by its index. If you passin two comma separated values, e.g. "3,6", it will end the rendering at the second value  -r RESOLUTION, --resolution RESOLUTION Resolution, passed as "height,width"  -c COLOR, --color COLOR  Background color  --sound               Play a success/failure sound  --leave_progress_bars Leave progress bars displayed in terminal  --media_dir MEDIA_DIR directory to write media   --video_dir VIDEO_DIR directory to write file tree for video  --video_output_dir VIDEO_OUTPUT_DIR  directory to write video  --tex_dir TEX_DIR     directory to write tex  --livestream          Run in streaming mode  --to-twitch           Stream to twitch  --with-key TWITCH_KEY Stream key for twitch</code></pre><h3 id="1-1-保存为视频并立即播放"><a href="#1-1-保存为视频并立即播放" class="headerlink" title="1.1 保存为视频并立即播放"></a>1.1 <strong>保存为视频并立即播放</strong></h3><p>参数 <code>-p</code> 表示预览，不加分辨率选项默认使用最高画质(1440P60)</p><p>如果有多个绘图类会出现列表让你选择</p><p>也可以直接指定类名(示例为Example类)生成对应的类名的视频</p><ul><li><p>fps = 15,宽854，高480 (480P15)：</p><pre><code class="hljs bash">python -m manim \path\to\yourfile.py Example -pl</code></pre></li><li><p>fps = 30,宽1280，高720 (720P30)：</p><pre><code class="hljs bash">python -m manim \path\to\yourfile.py Example -pm</code></pre></li><li><p>fps = 60,宽1920，高1080 (1080P60):</p><pre><code class="hljs bash">python -m manim \path\to\yourfile.py Example -p --high_quality</code></pre></li><li><p>fps = 60,宽2560，高1440 (1440P60)：</p><pre><code class="hljs bash">python -m manim \path\to\yourfile.py Example -pw</code></pre></li></ul><h3 id="1-2-保留帧"><a href="#1-2-保留帧" class="headerlink" title="1.2 保留帧"></a>1.2 <strong>保留帧</strong></h3><p><code>-s</code>保留最后一帧</p><p>当有多个类的时候会出现选择项让你选择保留哪几个绘图类的最后一帧</p><ul><li><p>保留最后一帧并立即查看：</p><pre><code class="hljs bash">python -m manim \path\to\yourfile.py Example -ps</code></pre></li><li><p>保留全部绘图类为视频：</p><pre><code class="hljs bash">python -m manim \path\to\yourfile.py Example -alpython -m manim \path\to\yourfile.py Example -ampython -m manim \path\to\yourfile.py Example -aw</code></pre></li><li><p>保留全部绘图类最后一帧：</p><pre><code class="hljs bash">python -m manim \path\to\yourfile.py Example -as</code></pre></li></ul><h3 id="1-3-视频尺寸"><a href="#1-3-视频尺寸" class="headerlink" title="1.3 视频尺寸"></a>1.3 <strong>视频尺寸</strong></h3><p><code>-r HEIGHT WIDTH</code></p><ul><li><p>高度500 宽度600</p><pre><code class="hljs bash">python -m manim \path\to\yourfile.py Example -pr 500 600</code></pre></li><li><p>默认为16/9因此默认可以仅设置高度不需要设置宽度</p><p>高度为500的视频：</p><pre><code class="hljs bash">python -m manim \path\to\yourfile.py Example -pr 500</code></pre></li></ul><h3 id="1-4-视频通道"><a href="#1-4-视频通道" class="headerlink" title="1.4 视频通道"></a>1.4 <strong>视频通道</strong></h3><p><code>-t, --transparent</code> 生成的视频带有alpha通道（即透明背景），扩展名为<code>.mov</code></p><h3 id="1-5-保留进度显示条"><a href="#1-5-保留进度显示条" class="headerlink" title="1.5 保留进度显示条"></a>1.5 <strong>保留进度显示条</strong></h3><p><code>--leave_progress_bars</code>:</p><pre><code class="hljs clean">$ python -m manim \path\to\yourfile.py Example -pl --leave_progress_barsMedia will be written to ./media\. You can change this behavior <span class="hljs-keyword">with</span> the --media_dir flag.Animation <span class="hljs-number">0</span>: WriteTextMobject, etc.: <span class="hljs-number">100</span>%|############################################| <span class="hljs-number">15</span>/<span class="hljs-number">15</span> [<span class="hljs-number">00</span>:<span class="hljs-number">00</span>&lt;<span class="hljs-number">00</span>:<span class="hljs-number">00</span>, <span class="hljs-number">32.48</span>it/s] File ready at \path\to\video.mp4Played <span class="hljs-number">2</span> animations</code></pre><h3 id="1-6-从某一个动画状态（animation）开始存为视频"><a href="#1-6-从某一个动画状态（animation）开始存为视频" class="headerlink" title="1.6 从某一个动画状态（animation）开始存为视频"></a>1.6 从某一个动画状态（animation）开始存为视频</h3><p><code>-n START_AT_ANIMATION_NUMBER, --start_at_animation_number START_AT_ANIMATION_NUMBER</code></p><p>不是从第一个动画开始渲染，而是从索引指定的另一个动画开始渲染。 如果您传入两个逗号分隔值，例如 “3,6”，它将以第二个值渲染</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowGraph</span><span class="hljs-params">(Scene)</span>:</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>         print(<span class="hljs-string">"dot = Dot()"</span>)        dot = Dot()        self.wait(<span class="hljs-number">2</span>)        print(<span class="hljs-string">"dot.to_edge(UL)"</span>)        dot.to_edge(UL)        self.play(FadeIn(dot))        self.wait(<span class="hljs-number">2</span>)        print(<span class="hljs-string">"text = TextMobject(\"text\")"</span>)        text = TextMobject(<span class="hljs-string">"text"</span>)        self.wait(<span class="hljs-number">2</span>)        print(<span class="hljs-string">"text.to_corner(UP)"</span>)        text.to_corner(UP)        self.play(Write(text))        self.wait(<span class="hljs-number">2</span>)</code></pre><p>不加起始渲染运行如下：</p><pre><code class="hljs text">$ python -m manim .\1_text_format.py ShowGraph -pl --leave_progress_bars      Media will be written to ./media\. You can change this behavior with the --media_dir flag.dot = Dot()dot.to_edge(UL)Animation 1: FadeInDot: 100%|############################################################| 15/15 [00:00&lt;00:00, 64.27it/s] text = TextMobject("text")text.to_corner(UP)Animation 4: WriteTextMobject: 100%|#####################################################| 15/15 [00:00&lt;00:00, 39.79it/s] File ready at ...\manim\media\videos\1_text_format\480p15\ShowGraph.mp4Played 6 animations</code></pre><p>增加起始渲染：</p><p>从刚才的没有渲染的输出可以看出Animation1是<code>dot.to_edge(UL)</code>后的<code>FadeIn(dot)</code>动画，所以如果<code>-n 2</code>则从Animation2开始，所以开始dot就已经显示在屏幕上面了</p><pre><code class="hljs text">$ python -m manim .\1_text_format.py ShowGraph -pl -n 2 --leave_progress_barsMedia will be written to ./media\. You can change this behavior with the --media_dir flag.dot = Dot()dot.to_edge(UL)Animation 1: FadeInDot: 100%|############################################################| 15/15 [00:00&lt;00:00, 84.02it/s] text = TextMobject("text")text.to_corner(UP)Animation 4: WriteTextMobject: 100%|#####################################################| 15/15 [00:00&lt;00:00, 58.52it/s] File ready at ...\manim\media\videos\1_text_format\480p15\ShowGraph.mp4Played 6 animations</code></pre><p><img src="1565761708445.png" srcset="/img/loading.gif" alt="1565761708445"></p><p>其他的参数不一一介绍，自行查看英文说明</p><h3 id="1-7-默认显示进度条"><a href="#1-7-默认显示进度条" class="headerlink" title="1.7 默认显示进度条"></a>1.7 默认显示进度条</h3><p>默认设置在<code>manimlib/config.py</code>，<code>manimlib/extract_secne.py</code>与<code>manimlib/scene.py</code>里进行定义，可以修改该文件进行修改默认配置,注意因为修改源码所以要小心</p><p>例如：在上面的三个文件里：</p><p>将里面所有的<code>--leave_progress_bars</code>和<code>leave_progress_bars</code>修改为<code>--remove_progress_bars</code>与<code>remove__progress_bars</code>,同时将</p><p><img src="1567668580431.png" srcset="/img/loading.gif" alt="1567668580431"></p><p>此处的action改成不显示</p><p>这样如果加上<code>--remove_progress_bars</code>就不会显示进度条了，而默认是显示进度条的</p><h3 id="1-8-改变视频存放位置"><a href="#1-8-改变视频存放位置" class="headerlink" title="1.8 改变视频存放位置"></a>1.8 改变视频存放位置</h3><p>改变<code>manimlib/constants.py</code>中的：</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.isdir(MEDIA_DIR):    MEDIA_DIR = <span class="hljs-string">"./media"</span></code></pre><p> 改<code>./media</code>为你想要存放的位置</p><h3 id="1-9-存为gif"><a href="#1-9-存为gif" class="headerlink" title="1.9 存为gif"></a>1.9 存为gif</h3><p>使用 <code>-i</code> 选项来导出gif文件，但是目前这个功能被删除掉了，可以按照<a href="https://manim.ml/problems/v2.3.html#q16-gif" target="_blank" rel="noopener">这里</a>更改回去</p><h2 id="2-显示操作"><a href="#2-显示操作" class="headerlink" title="2. 显示操作"></a>2. 显示操作</h2><h3 id="2-1-基本步骤（以TextMobject为例）"><a href="#2-1-基本步骤（以TextMobject为例）" class="headerlink" title="2.1 基本步骤（以TextMobject为例）"></a>2.1 基本步骤（以<code>TextMobject</code>为例）</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> manimlib.imports <span class="hljs-keyword">import</span> *<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteText</span><span class="hljs-params">(Scene)</span>:</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>         text = TextMobject(<span class="hljs-string">"A Text"</span>)        text.to_edge(UP)        text.move_to(<span class="hljs-number">1</span> * UP + <span class="hljs-number">0.1</span> * RIGHT)        self.play(SomeWriteMethod(text), run_time=seconds)        self.wait(seconds)        self.remove(text)</code></pre><h3 id="2-5-位置相关的函数"><a href="#2-5-位置相关的函数" class="headerlink" title="2.5 位置相关的函数"></a>2.5 位置相关的函数</h3><h4 id="2-5-1-to-edge-和to-corner"><a href="#2-5-1-to-edge-和to-corner" class="headerlink" title="2.5.1 to_edge()和to_corner()"></a><strong>2.5.1</strong> <code>to_edge()</code>和<code>to_corner()</code></h4><p><strong><code>someObject.to_edge(上下左右四个方向, buff=number)</code></strong></p><p><strong><code>someObject.to_corner(左上左下右上右下四个方向, buff=number)</code></strong></p><p><code>to_edge</code>参数可以是<strong>任意方向</strong>(方向有哪些见附录中方向常数列表)以及它们的线性组合，如<strong>0.1*RIGHT+0.2*UP</strong>，<code>buff</code> 两者的边缘的距离</p><p><code>to_corner</code>仅接受组合方向<strong>UR，UL，DR，DL</strong></p><p><img src="1565752494266.png" srcset="/img/loading.gif" alt="1565752494266"></p><ul><li>如果没有<code>to_edge</code>和<code>to_center</code>默认为中间（<strong>ORIGIN</strong>）</li><li><strong><code>someObject.to_edge(UP + RIGHT)</code></strong>完全等效于<strong><code>someObject.to_corner(UR)</code></strong>,其余四个方向同理</li></ul><h4 id="2-5-2-move-to"><a href="#2-5-2-move-to" class="headerlink" title="2.5.2 move_to()"></a>2.5.2 <code>move_to()</code></h4><p><strong><code>someObject.move_to(DIRECTION的线性组合 or numpy的向量)</code></strong></p><p>在当前位置移动到对应的位置</p><p>参数可以是<strong>UP，DOWN，LEFT，RIGHT等</strong>的倍数，可以非整数，单位宽度大概是4倍默认字体的行高，<strong>下面只要跟这八个个固定值有关的均是如此</strong></p><pre><code class="hljs python">someObject.move_to(UP + <span class="hljs-number">2</span> * RIGHT)</code></pre><p>参数也可以是numpy向量：</p><pre><code class="hljs python">vec = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>])someObject.move_to(vec)</code></pre><p>因为图案的位置向量可以由<code>get_center</code>得到，所以可以如下操作：</p><pre><code class="hljs python">someObject.move_to(someObject2.get_center() + <span class="hljs-number">2</span> * RIGHT)</code></pre><p>参数还可以是另外一个图案，表示的位置是该图案的几何中心：</p><pre><code class="hljs python">someObject.move_to(someObject2)</code></pre><h4 id="2-5-3-next-to"><a href="#2-5-3-next-to" class="headerlink" title="2.5.3 next_to()"></a>2.5.3 <code>next_to()</code></h4><p><strong><code>someObject1.next_to(someObject2, DIRECTION, buff=number)</code></strong> </p><p>someObject1对于someObject2的相对位置</p><p>与<code>move_to</code>的区别在于，<code>next_to</code>表示的是边界的距离，而不是中心距离</p><p><img src="1565755487243.png" srcset="/img/loading.gif" alt="1565755487243"></p><p>如：<code>text1.next_to(text2, LEFT, buff=2)</code> ：</p><p><img src="1565702556749.png" srcset="/img/loading.gif" alt="1565702556749"></p><h4 id="2-5-4-shift"><a href="#2-5-4-shift" class="headerlink" title="2.5.4 shift()"></a>2.5.4 <code>shift()</code></h4><p><strong><code>someObject.shift(DIRECTION * number)</code>：</strong></p><p>自己垂直方向平移</p><h4 id="2-5-5-rotate"><a href="#2-5-5-rotate" class="headerlink" title="2.5.5 rotate()"></a>2.5.5 <code>rotate()</code></h4><p><strong><code>someObject.rotate(PI*number 或者 number，point)</code>：</strong> </p><p>逆时针旋转</p><p>如果相对图案为空，则自旋</p><p>如：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RotateObject</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        textM = TextMobject(<span class="hljs-string">"Text"</span>)        textC = TextMobject(<span class="hljs-string">"Reference text"</span>)        textM.shift(UP)        textM.rotate(PI/<span class="hljs-number">4</span>)         self.play(Write(textM), Write(textC))        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="1565702942360.png" srcset="/img/loading.gif" alt="1565702942360"></p><p>否则相对 相对图案旋转：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RotateObject</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        textM = TextMobject(<span class="hljs-string">"Text"</span>)        textC = TextMobject(<span class="hljs-string">"Reference text"</span>)        textM.rotate(PI/<span class="hljs-number">4</span>, textC)         self.play(Write(textM), Write(textC))        self.wait(<span class="hljs-number">2</span>)</code></pre><h4 id="2-5-6-flip"><a href="#2-5-6-flip" class="headerlink" title="2.5.6 flip()"></a>2.5.6 <code>flip()</code></h4><p><strong><code>someObject.flip(DIRECTION)</code>：</strong></p><p>按照矢量量方向翻转180度，方向遵循右手定则。</p><p>如<code>text.flip(UP)</code>：</p><p><img src="1565703056789.png" srcset="/img/loading.gif" alt="1565703056789"></p><h3 id="2-6-播放动画"><a href="#2-6-播放动画" class="headerlink" title="2.6 播放动画"></a>2.6 播放动画</h3><h4 id="2-6-1-play"><a href="#2-6-1-play" class="headerlink" title="2.6.1 play()"></a>2.6.1 <strong><code>play()</code></strong></h4><p>动画效果，可以是多个text，这个函数是多线程的，所以不会阻塞就会进入下一行操作</p><p><em>（如果下一个操作是remove掉text而没有使用wait函数进行等待，最终效果会变成立即销毁text即没有显示text，下面的add也同理）</em></p><ol><li><p><strong><code>play(SomePlayMethod(someObject), run_time=seconds)</code></strong> ： 播放某种动画方法</p><p>如果希望并行同时播放多个动画，仅仅是python语法问题，给出如下例子模板：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">concurrent</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        dot1 = Dot()        dot2 = Dot()        dot2.shift(UP)        dot3 = Dot()        dot3.shift(DOWN)         <span class="hljs-comment"># 单个动画的演示</span>        self.play(Write(dot1))        <span class="hljs-comment"># 多个动画演示</span>        self.play(*[            Transform(i.copy(), j) <span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> zip([dot1, dot1], [dot2, dot3])        ]) <span class="hljs-comment"># 故意使用i,j是为了显示zip的使用</span>        self.wait()</code></pre></li><li><p>同时改变某种或多种属性</p><pre><code class="hljs python">self.play(    someObjectX.methodX, functionParamX,    someObjectX.methodY, functionParamY,    ...,    run_time=seconds)</code></pre><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeColorAndSizeAnimation</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        text = TextMobject(<span class="hljs-string">"Text"</span>)        text.scale(<span class="hljs-number">2</span>)        text.shift(LEFT*<span class="hljs-number">2</span>)        self.play(Write(text))        self.wait()        self.play(            text.shift, RIGHT*<span class="hljs-number">2</span>,            text.scale, <span class="hljs-number">2</span>,            text.set_color, RED,            run_time=<span class="hljs-number">2</span>        )         self.wait()</code></pre></li></ol><h5 id="2-6-1-1-显示动画函数SomePlayMethods"><a href="#2-6-1-1-显示动画函数SomePlayMethods" class="headerlink" title="2.6.1.1 显示动画函数SomePlayMethods"></a>2.6.1.1 显示动画函数SomePlayMethods</h5><p>动画函数，主要包含下列几个：</p><ul><li><p><code>manimlib\animation\fading.py</code>：渐变效果 </p><p><strong><code>FadeXXX(someObject)</code></strong></p><ul><li>包含<code>FadeIn</code>，<code>FadeInFromDown</code>，<code>FadeOutAndShiftDown</code>，<code>FadeInFromPoint</code>，<code>FadeInFromLarge</code>等等</li><li>解释：fade in/out 渐入/出；shift down 垂直下降</li></ul></li><li><p><code>manimlib\animation\creation.py</code>：生成效果</p><p><strong><code>ShowCreation(someObject)</code></strong></p><ul><li>无法清楚表达，具体可以自行尝试看效果</li></ul><p><strong><code>UnCreate(someObject)</code></strong></p><ul><li>倒放ShowCreation动画效果</li></ul><p><strong><code>DrawBorderThenFill(someObject)</code></strong></p><ul><li>画出边界然后填充</li></ul><p><strong><code>Write(someObject)</code></strong></p><ul><li>继承自DrawBorderThenFill，增加从左往右逐渐显示的效果</li></ul></li><li><p><code>manimlib\animation\transform.py</code>从一个渐变成另一个</p><ul><li><strong><code>Transform(someObject1, someObject2)</code></strong></li><li><strong><code>ReplacementTransform(someObject1, someObject2)</code></strong></li></ul><p>两者的异同：</p><p><strong>共同点</strong> : 显示特效相同</p><p><strong>不同点</strong> : <strong><code>Transform</code></strong> 显示在画布上的object永远是someObject1</p><p>伪代码：</p><pre><code class="hljs python">Transform(someObject1, someObject2):show someObject1 on screenshow the transform course of someObject1 to someObject2someObject1 = someObject2show updated someObject1 on screen</code></pre><p><strong><code>ReplacementTransform</code></strong> 显示在画布上的从someObject1变成了someObject2</p><p>伪代码：</p><pre><code class="hljs python">ReplacementTransform(someObject1, someObject2):show someObject1 on screenshow the transform course of someObject1 to someObject2someObject1 = someObject2show someObject2 on screen<span class="hljs-comment"># 不同点在此</span>    remove someObject1 <span class="hljs-keyword">from</span> screen <span class="hljs-comment"># 不是从内存删除，仅仅不可见</span></code></pre><p>用两段代码来看看效果：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextArray</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        text = TextMobject(<span class="hljs-string">"tex1"</span>, <span class="hljs-string">"text2"</span>, <span class="hljs-string">"text3"</span>)        text[<span class="hljs-number">0</span>].shift(<span class="hljs-number">2</span> * LEFT)        text[<span class="hljs-number">0</span>].set_color(RED)        text[<span class="hljs-number">1</span>].shift(LEFT)        text[<span class="hljs-number">1</span>].set_color(BLUE)        self.play(Write(text[<span class="hljs-number">0</span>]))        self.wait(<span class="hljs-number">2</span>)        <span class="hljs-comment"># 显示的还是text[0]只是text[0]值变成了text[1]</span>        self.play(Transform(text[<span class="hljs-number">0</span>], text[<span class="hljs-number">1</span>]))        <span class="hljs-comment"># 此时没有让text[0]消失，但让text[1]显现并转换为text[2]</span>        <span class="hljs-comment"># 最终text[0]的值为初始text[1]的值，text[1]的值为初始text[2]的值</span>        self.play(Transform(text[<span class="hljs-number">1</span>], text[<span class="hljs-number">2</span>]))        <span class="hljs-comment"># 最终屏幕上显示的是text[0]和text[1]</span>        self.wait(<span class="hljs-number">3</span>)</code></pre><p><img src="1565773952504.png" srcset="/img/loading.gif" alt="1565773952504"></p><p><img src="1565773963920.png" srcset="/img/loading.gif" alt="1565773963920"></p><p><img src="1565773975419.png" srcset="/img/loading.gif" alt="1565773975419"></p><p>将上面的替换成<code>ReplacementTransform</code>：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextArray</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        text = TextMobject(<span class="hljs-string">"tex1"</span>, <span class="hljs-string">"text2"</span>, <span class="hljs-string">"text3"</span>)        text[<span class="hljs-number">0</span>].shift(<span class="hljs-number">2</span> * LEFT)        text[<span class="hljs-number">0</span>].set_color(RED)        text[<span class="hljs-number">1</span>].shift(LEFT)        text[<span class="hljs-number">1</span>].set_color(BLUE)        self.play(Write(text[<span class="hljs-number">0</span>]))        self.wait(<span class="hljs-number">2</span>)        <span class="hljs-comment"># 显示的是text[1]但是text[0]值也变成了text[1]，text[0]消失</span>        self.play(ReplacementTransform(text[<span class="hljs-number">0</span>], text[<span class="hljs-number">1</span>]))        <span class="hljs-comment"># 显示text[2],text[1]值也变成了text[2]，text[1]消失</span>        <span class="hljs-comment"># 最终text[0]的值为初始text[1]的值，text[1]的值为初始text[2]的值</span>        self.play(ReplacementTransform(text[<span class="hljs-number">1</span>], text[<span class="hljs-number">2</span>]))        <span class="hljs-comment"># 最终显示的是text[2]</span>        self.wait(<span class="hljs-number">3</span>)</code></pre><p>最后一幅图不一样：</p><p><img src="1565774075040.png" srcset="/img/loading.gif" alt="1565774075040"></p><p><strong>如果希望不要改变someObject1的值可以使用：<code>someObject1.copy()</code>进行深度拷贝</strong></p><p><code>someObject1.copy()</code>执行的伪代码：</p><pre><code class="hljs python">someObject1.copy():    new objectobject.allValue = self.allValue<span class="hljs-keyword">return</span> object</code></pre></li><li><p><strong><code>MoveToTarget(someObject):</code></strong></p><p>仅对自身产生变化</p><p>比较简单，用示例代码即可以看懂：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeColorAndSizeAnimation</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        text = TextMobject(<span class="hljs-string">"Text"</span>)        self.play(Write(text))        text.generate_target()        text.target = TextMobject(<span class="hljs-string">"Target"</span>)        text.target.set_color(RED)        text.target.scale(<span class="hljs-number">2</span>)        text.target.shift(LEFT)        self.play(MoveToTarget(text), run_time=<span class="hljs-number">2</span>)        self.wait()</code></pre></li><li><p><code>manimlib\animation\growing.py</code></p><ul><li><p><strong><code>GrowFromXXX(someObject)</code></strong></p><p><code>GrowFromCenter</code>,<code>GrowFromPoint</code>,<code>GrowFromEdge</code>,<code>GrowArrow</code>等等</p></li></ul></li><li><p><code>manimlib\animation\update.py</code></p><ul><li><p><strong><code>UpdateFromFunc(obj,update_function)</code></strong></p><p>同步播放,很好理解，见例子：</p><p>更多同步并发的播放见<strong>2.9</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Updater</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        dot = Dot()        text = TextMobject(<span class="hljs-string">"Label"</span>).next_to(dot, RIGHT, buff=SMALL_BUFF)        self.add(dot, text)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_text</span><span class="hljs-params">(obj)</span>:</span>            obj.next_to(dot, RIGHT, buff=SMALL_BUFF)        <span class="hljs-comment"># Only works in play</span>        self.play(            dot.shift, UP * <span class="hljs-number">2</span>,            UpdateFromFunc(text, update_text)        )        self.wait()</code></pre></li></ul></li></ul><h5 id="2-6-1-2-run-time"><a href="#2-6-1-2-run-time" class="headerlink" title="2.6.1.2 run_time"></a>2.6.1.2 <code>run_time</code></h5><p>动画从开始到结束所用的时间，决定了<strong>动画的总时长</strong> （如果动画后不加<code>wait</code>，可能会出现丢掉结尾的帧的情况）</p><h4 id="2-6-1-3-rate-func"><a href="#2-6-1-3-rate-func" class="headerlink" title="2.6.1.3 rate_func"></a>2.6.1.3 <code>rate_func</code></h4><p>直译为速度函数，即内定的动画函数</p><p>分为三个值： <strong><code>there_and_back</code>来回，<code>linear</code>线性变化，<code>smooth</code>平滑</strong> （速度先为0，然后加快，到了中间减速最后到达终点为0）</p><p>例：</p><pre><code class="hljs python"> self.play(     triangle.shift, RIGHT * <span class="hljs-number">2</span>,     rate_func=smooth, <span class="hljs-comment"># Change this with: linear,smooth</span>     run_time=<span class="hljs-number">5</span>)</code></pre><h4 id="2-6-2-add"><a href="#2-6-2-add" class="headerlink" title="2.6.2 add()"></a>2.6.2 <code>add()</code></h4><p><strong><code>self.add(someObject1, someObject2, ...)</code></strong></p><p>无动画添加文字，可以是多个text</p><h4 id="2-6-3-wait"><a href="#2-6-3-wait" class="headerlink" title="2.6.3 wait()"></a>2.6.3 <code>wait()</code></h4><p><strong><code>self.wait(seconds)</code>：</strong></p><p>等待动画停留时间，如果没有参数则默认等待到将动画播放完为止</p><h4 id="2-6-4-remove"><a href="#2-6-4-remove" class="headerlink" title="2.6.4 remove()"></a>2.6.4 <code>remove()</code></h4><p><strong><code>self.remove(someObject1, someObject2,…)</code>：</strong></p><p>移除text，可以是多个text，注意FadeOut类的动画虽然自带消失效果但是该变量还是会停留在内存中</p><h3 id="2-7-设置颜色"><a href="#2-7-设置颜色" class="headerlink" title="2.7 设置颜色"></a>2.7 设置颜色</h3><p><strong><code>someObject.set_color(COLOR)</code></strong></p><p>COLOR有哪些见附录的颜色一栏，COLOR本质上是一个字符串所以可以自定义字符串传入：</p><p><strong><code>someObject.set_color(string)</code></strong></p><p>如：</p><pre><code class="hljs python">someObject.set_color(<span class="hljs-string">"#0000FF"</span>)</code></pre><h3 id="2-8-缩放大小"><a href="#2-8-缩放大小" class="headerlink" title="2.8 缩放大小"></a>2.8 缩放大小</h3><p><strong><code>someObject.scale(number)</code></strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextArray</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        dot1 = Dot()        dot1.scale(<span class="hljs-number">3</span>)        dot1.shift(UP)        dot2 = Dot()        self.add(dot1, dot2)        self.wait(<span class="hljs-number">3</span>)</code></pre><p><img src="1565769895077.png" srcset="/img/loading.gif" alt="1565769895077"></p><h3 id="2-9-同步播放动画"><a href="#2-9-同步播放动画" class="headerlink" title="2.9 同步播放动画"></a>2.9 同步播放动画</h3><p>TODO：<strong>暂时没有时间理解源码</strong></p><p>让某一个物体（mobject）跟随另一个物体的移动而并行移动（使用其他移动方式，路径）</p><p><code>manimlib\mobject\mobject.py</code></p><ul><li><p><strong><code>add_updater(update_function, index=None, call_updater=True)</code></strong></p><ul><li><code>update_function</code>：更新函数，函数传入一个object对象，函数内部有一系列对该对象和已知的对象进行的一系列操作，可以是lambda表达式</li></ul><p>例子：让一个点在“label”文字右边，随着文字的移动，始终保持在其右侧</p></li></ul><pre><code class="hljs python"><span class="hljs-comment"># author:TB</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddUpdater1</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        dot = Dot()        text = TextMobject(<span class="hljs-string">"Label"</span>)\               .next_to(dot, RIGHT, buff=SMALL_BUFF)        self.add(dot, text)        <span class="hljs-comment"># Update function 更新函数</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_text</span><span class="hljs-params">(obj)</span>:</span>            obj.next_to(dot, RIGHT, buff=SMALL_BUFF)        <span class="hljs-comment"># Add update function to the objects</span>        <span class="hljs-comment"># 把更新函数加给对象</span>        text.add_updater(update_text)                <span class="hljs-comment"># 如果想简洁，lambda表达式如下：</span>        <span class="hljs-comment"># text.add_updater(lambda m: m.next_to(dot, RIGHT, buff=SMALL_BUFF))</span>        <span class="hljs-comment"># 此时下面的remove_updater(update_text)不能继续使用，需要改为clear_updaters</span>        <span class="hljs-comment"># Add the object again 重新加入text</span>        <span class="hljs-comment"># 注意这个步骤不能少，否则看不到！！！</span>        <span class="hljs-comment"># 即使之前加入过，现在还是要重新加入</span>        self.add(text)        self.play(dot.shift, UP * <span class="hljs-number">2</span>)        <span class="hljs-comment"># Remove update function</span>        text.remove_updater(update_text)        self.wait()</code></pre><ul><li><p><strong><code>remove_updater(update_function)</code></strong> 取消并行播放函数</p></li><li><p><strong><code>clear_updaters(recursive=True)</code></strong> 取消所有的并行播放函数</p></li><li><p><strong><code>UpdateFromFunc(Animation)</code></strong></p><p>见<strong>2.6.1.1</strong>,注意这个函数仅在play函数中生效，play结束后就不会继续同步</p></li></ul><p>更多例子（有时间再补充）：<a href="https://github.com/Elteoremadebeethoven/AnimationsWithManim/blob/master/English/update_successions/update_successions.py" target="_blank" rel="noopener">TB的更新函数页面</a></p><h2 id="3-text数组"><a href="#3-text数组" class="headerlink" title="3. text数组"></a>3. text数组</h2><p>在2中所有的显示方法几乎都可以对数组成立，</p><p>如文字串：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextArray</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        text = TextMobject(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>, <span class="hljs-string">"F"</span>)        text[<span class="hljs-number">0</span>].set_color(RED)        text[<span class="hljs-number">1</span>].set_color(ORANGE)        text[<span class="hljs-number">2</span>].set_color(YELLOW)        text[<span class="hljs-number">3</span>].set_color(GREEN)        text[<span class="hljs-number">4</span>].set_color(BLUE) <span class="hljs-comment">#Hexadecimal color</span>        self.play(Write(text))        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="1565768302203.png" srcset="/img/loading.gif" alt="1565768302203"></p><p>还可以拼接为LaTeX串(此处不能用TextMobject代替，否则报错)：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TexArray</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        text = TexMobject(<span class="hljs-string">"A"</span>, <span class="hljs-string">"{B"</span>, <span class="hljs-string">"\\over"</span>, <span class="hljs-string">"C}"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>)        text[<span class="hljs-number">0</span>].set_color(RED)        text[<span class="hljs-number">1</span>].set_color(ORANGE)        text[<span class="hljs-number">2</span>].set_color(YELLOW)        text[<span class="hljs-number">3</span>].set_color(GREEN)        text[<span class="hljs-number">4</span>].set_color(BLUE)        text[<span class="hljs-number">5</span>].set_color(BLUE)        self.play(Write(text))        self.wait(<span class="hljs-number">2</span>)</code></pre><p><img src="1565769578088.png" srcset="/img/loading.gif" alt="1565769578088"></p><p>对于数组可以直接如同对单个object操作,如：</p><pre><code class="hljs python">text.shift(UP)</code></pre><p><strong>注意：</strong></p><p><strong><code>text = TextMobject(string)</code>是一维数组</strong></p><p><strong>当<code>text = TextMobject(string1，string2，...)</code>中所有的string均为字母的时候，text为二维数组但是每一个子数组大小仅为1</strong></p><p><strong>如果有任意一个string是多个字母则text是二维数组</strong></p><h2 id="4-基础动画类-Scene"><a href="#4-基础动画类-Scene" class="headerlink" title="4. 基础动画类 Scene"></a>4. 基础动画类 Scene</h2><p>所有的动画均是scene类的子类产生的，因此scene的功能比较少，主要是对一些基础的属性进行配置</p><p><code>manimlib\scene\scene.py</code></p><p>变量的值得初始定义见下：</p><pre><code class="hljs python"><span class="hljs-comment"># manimlib\scene\scene.py</span>CONFIG = {        <span class="hljs-string">"camera_class"</span>: Camera,        <span class="hljs-string">"camera_config"</span>: {},        <span class="hljs-string">"file_writer_config"</span>: {},        <span class="hljs-string">"skip_animations"</span>: <span class="hljs-literal">False</span>,        <span class="hljs-string">"always_update_mobjects"</span>: <span class="hljs-literal">False</span>,        <span class="hljs-string">"random_seed"</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">"start_at_animation_number"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"end_at_animation_number"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"leave_progress_bars"</span>: <span class="hljs-literal">False</span>,    }</code></pre><p>其中 <strong><code>camera_config</code></strong> 是对视频的处理，由 <strong><code>Camera</code>类</strong> 完成:    </p><p><code>manimlib\camera\camera.py</code></p><pre><code class="hljs python"><span class="hljs-comment"># manimlib\camera\camera.py</span>CONFIG = {    <span class="hljs-comment"># 背景颜色</span>    <span class="hljs-string">"background_image"</span>: <span class="hljs-literal">None</span>,    <span class="hljs-comment"># 视频的高宽与帧率</span>    <span class="hljs-string">"pixel_height"</span>: DEFAULT_PIXEL_HEIGHT,    <span class="hljs-string">"pixel_width"</span>: DEFAULT_PIXEL_WIDTH,    <span class="hljs-string">"frame_rate"</span>: DEFAULT_FRAME_RATE,    <span class="hljs-comment"># Note: frame height and width will be resized to match</span>    <span class="hljs-comment"># the pixel aspect ratio</span>    <span class="hljs-comment"># FRAME_HEIGHT = 8.0</span>    <span class="hljs-comment"># FRAME_WIDTH = FRAME_HEIGHT * DEFAULT_PIXEL_WIDTH / DEFAULT_PIXEL_HEIGHT</span>    <span class="hljs-string">"frame_height"</span>: FRAME_HEIGHT,    <span class="hljs-string">"frame_width"</span>: FRAME_WIDTH,    <span class="hljs-comment"># 默认方向</span>    <span class="hljs-string">"frame_center"</span>: ORIGIN,    <span class="hljs-comment"># 背景颜色</span>    <span class="hljs-string">"background_color"</span>: BLACK,    <span class="hljs-string">"background_opacity"</span>: <span class="hljs-number">1</span>,    <span class="hljs-comment"># Points in vectorized mobjects with norm greater</span>    <span class="hljs-comment"># than this value will be rescaled.</span>    <span class="hljs-string">"max_allowable_norm"</span>: FRAME_WIDTH,    <span class="hljs-string">"image_mode"</span>: <span class="hljs-string">"RGBA"</span>,    <span class="hljs-string">"n_channels"</span>: <span class="hljs-number">4</span>,    <span class="hljs-string">"pixel_array_dtype"</span>: <span class="hljs-string">'uint8'</span>,    <span class="hljs-comment"># z_buff_func is only used if the flag above is set to True.</span>    <span class="hljs-comment"># round z coordinate to nearest hundredth when comparring</span>    <span class="hljs-string">"z_buff_func"</span>: <span class="hljs-keyword">lambda</span> m: np.round(m.get_center()[<span class="hljs-number">2</span>], <span class="hljs-number">2</span>),    <span class="hljs-string">"cairo_line_width_multiple"</span>: <span class="hljs-number">0.01</span>,}</code></pre><p>所有的动画都是继承自<code>Scene</code>,所以动画的某些特定的属性可以通过<code>CONFIG</code>修改：</p><p>例子：</p><p>插入背景图片</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextLike1DArrays</span><span class="hljs-params">(Scene)</span>:</span>    CONFIG={        <span class="hljs-string">"camera_config"</span>: {            <span class="hljs-string">"background_image"</span>: <span class="hljs-string">r"1.png"</span>,        },    }    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        self.add(TextMobject(<span class="hljs-string">"Text"</span>).set_color(RED))        self.wait()</code></pre><p><img src="1565833717545.png" srcset="/img/loading.gif" alt="1565833717545"></p><h2 id="5-二维坐标类-GraphScene"><a href="#5-二维坐标类-GraphScene" class="headerlink" title="5. 二维坐标类 GraphScene"></a>5. 二维坐标类 GraphScene</h2><p><code>manimlib\scene\graph_scene.py</code></p><p>继承自<code>Scene</code>类，用来绘制坐标</p><p>属性如下：</p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"x_min"</span>: <span class="hljs-number">-1</span>,        <span class="hljs-string">"x_max"</span>: <span class="hljs-number">10</span>,        <span class="hljs-string">"x_axis_width"</span>: <span class="hljs-number">9</span>,        <span class="hljs-string">"x_tick_frequency"</span>: <span class="hljs-number">1</span>,        <span class="hljs-string">"x_leftmost_tick"</span>: <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Change if different from x_min</span>        <span class="hljs-string">"x_labeled_nums"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"x_axis_label"</span>: <span class="hljs-string">"$x$"</span>,        <span class="hljs-string">"y_min"</span>: <span class="hljs-number">-1</span>,        <span class="hljs-string">"y_max"</span>: <span class="hljs-number">10</span>,        <span class="hljs-string">"y_axis_height"</span>: <span class="hljs-number">6</span>,        <span class="hljs-string">"y_tick_frequency"</span>: <span class="hljs-number">1</span>,        <span class="hljs-string">"y_bottom_tick"</span>: <span class="hljs-literal">None</span>,  <span class="hljs-comment"># Change if different from y_min</span>        <span class="hljs-string">"y_labeled_nums"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"y_axis_label"</span>: <span class="hljs-string">"$y$"</span>,        <span class="hljs-string">"axes_color"</span>: GREY,        <span class="hljs-string">"graph_origin"</span>: <span class="hljs-number">2.5</span> * DOWN + <span class="hljs-number">4</span> * LEFT,        <span class="hljs-string">"exclude_zero_label"</span>: <span class="hljs-literal">True</span>,        <span class="hljs-string">"default_graph_colors"</span>: [BLUE, GREEN, YELLOW],        <span class="hljs-string">"default_derivative_color"</span>: GREEN,        <span class="hljs-string">"default_input_color"</span>: YELLOW,        <span class="hljs-string">"default_riemann_start_color"</span>: BLUE,        <span class="hljs-string">"default_riemann_end_color"</span>: GREEN,        <span class="hljs-string">"area_opacity"</span>: <span class="hljs-number">0.8</span>,        <span class="hljs-string">"num_rects"</span>: <span class="hljs-number">50</span>,    }</code></pre><p>一般流程是：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph2D</span><span class="hljs-params">(GraphScene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x_2</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-keyword">return</span> x ** <span class="hljs-number">2</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        self.setup_axes(animate=<span class="hljs-literal">True</span>)        graph = self.get_graph(self.x_2, color=GREEN, x_min=<span class="hljs-number">2</span>, x_max=<span class="hljs-number">4</span>)        self.play(ShowCreation(graph), run_time=<span class="hljs-number">2</span>)        self.wait()</code></pre><p><img src="1565835900946.png" srcset="/img/loading.gif" alt="1565835900946"></p><h3 id="5-1-setup-axes"><a href="#5-1-setup-axes" class="headerlink" title="5.1 setup_axes()"></a>5.1 <code>setup_axes()</code></h3><p><strong><code>setup_axes(animate=Bool)</code>：</strong></p><p>默认没有动画效果，<code>setup_axes(animate=True)</code>则会显示动画 </p><h3 id="5-2-get-graph"><a href="#5-2-get-graph" class="headerlink" title="5.2 get_graph()"></a>5.2 <code>get_graph()</code></h3><p><strong>`get_graph(func, color=None, x_min=None, x_max=None, </strong>kwargs)`**</p><p>得到坐标系的句柄，并设置值</p><h3 id="5-3-coords-to-point"><a href="#5-3-coords-to-point" class="headerlink" title="5.3 coords_to_point()"></a>5.3 <code>coords_to_point()</code></h3><p><strong><code>coords_to_point(x, y)</code></strong></p><p>坐标变成对应的帧中的点，缩写<code>c2p()</code></p><h3 id="5-4-point-to-coords"><a href="#5-4-point-to-coords" class="headerlink" title="5.4 point_to_coords()"></a>5.4 <code>point_to_coords()</code></h3><p><strong><code>point_to_coords(point)</code></strong></p><p>帧中的点转换为坐标，返回x,y组成的元组，缩写<code>p2c()</code></p><h3 id="5-5-get-graph-label"><a href="#5-5-get-graph-label" class="headerlink" title="5.5 get_graph_label()"></a>5.5 <code>get_graph_label()</code></h3><p><strong><code>get_graph_label(graph, label="f(x)", x_val=None, direction=RIGHT, buff=MED_SMALL_BUFF, color=None)</code></strong></p><p><code>graph</code>：从graph中获得坐标标签</p><p><code>label</code>：默认为“f(x)”,可以改成自己想要的函数</p><p><code>x_val</code>：label在坐标系中所处位置的的x坐标</p><p><code>buff</code>：距离边界的距离</p><p><code>color</code>：颜色</p><h3 id="5-6-get-vertical-line-to-graph"><a href="#5-6-get-vertical-line-to-graph" class="headerlink" title="5.6 get_vertical_line_to_graph()"></a>5.6 <code>get_vertical_line_to_graph()</code></h3><p><strong>`get_vertical_line_to_graph(x, graph, line_class=Line, </strong>line_kwargs)`**</p><p>得到竖直线，起点为(x,0)终点为(x,f(x))</p><p>返回<code>line_class</code>类型的图像</p><h3 id="5-7-get-vertical-lines-to-graph"><a href="#5-7-get-vertical-lines-to-graph" class="headerlink" title="5.7 get_vertical_lines_to_graph()"></a>5.7 <code>get_vertical_lines_to_graph()</code></h3><p><strong>`get_vertical_lines_to_graph(graph, x_min=None, x_max=None, num_lines=20, </strong>kwargs)`**</p><p>同时得到画多条竖直线</p><p>返回<code>line_class</code>类型的<code>VGroup</code></p><h3 id="5-8-改变坐标标签的颜色"><a href="#5-8-改变坐标标签的颜色" class="headerlink" title="5.8 改变坐标标签的颜色"></a>5.8 改变坐标标签的颜色</h3><blockquote><p><a href="https://github.com/Elteoremadebeethoven/AnimationsWithManim/blob/master/English/6a_plots_2D/change_label_colors.md#change-labels-colors-in-graphscene" target="_blank" rel="noopener">https://github.com/Elteoremadebeethoven/AnimationsWithManim/blob/master/English/6a_plots_2D/change_label_colors.md#change-labels-colors-in-graphscene</a></p><p>Change labels colors in <code>GraphScene</code></p><p>Add this to the <code>CONFIG</code> dictionary:在CONFIG中加入：</p><pre><code class="hljs 1c"><span class="hljs-string">"x_label_color"</span>: RED,<span class="hljs-string">"y_label_color"</span>: BLUE</code></pre><p>In the <code>setup_axes</code> method change the lines：在源码的setup_axes中的两句：</p><pre><code class="hljs reasonml">x_label = <span class="hljs-constructor">TextMobject(<span class="hljs-params">self</span>.<span class="hljs-params">x_axis_label</span>)</span># <span class="hljs-keyword">and</span>y_label = <span class="hljs-constructor">TextMobject(<span class="hljs-params">self</span>.<span class="hljs-params">y_axis_label</span>)</span></code></pre><p>with改为</p><pre><code class="hljs reasonml">x_label = <span class="hljs-constructor">TextMobject(<span class="hljs-params">self</span>.<span class="hljs-params">x_axis_label</span>, <span class="hljs-params">color</span>=<span class="hljs-params">self</span>.<span class="hljs-params">x_label_color</span>)</span># <span class="hljs-keyword">and</span>y_label = <span class="hljs-constructor">TextMobject(<span class="hljs-params">self</span>.<span class="hljs-params">x_axis_label</span>, <span class="hljs-params">color</span>=<span class="hljs-params">self</span>.<span class="hljs-params">y_label_color</span>)</span></code></pre></blockquote><p>效果：</p><p><img src="ChanceColorLabels.png" srcset="/img/loading.gif" alt="img"></p><h2 id="6-文本类-TextMobject"><a href="#6-文本类-TextMobject" class="headerlink" title="6. 文本类 TextMobject"></a>6. 文本类 <code>TextMobject</code></h2><ol><li><p><strong><code>TextMobject(string)</code>：</strong> 传入一个字符串</p><p>字符串可以是普通字符串或LaTeX格式或两者混合：</p><pre><code class="hljs python">TextMobject(<span class="hljs-string">"This is a regular text"</span>)</code></pre><pre><code class="hljs python">TextMobject(<span class="hljs-string">"\\displaystyle\\frac{x}{y}"</span>) <span class="hljs-comment"># displaystyle使字体能显示正常大小</span></code></pre><p>两者混合则需要使用“$$”或者“$”包括：</p><pre><code class="hljs python">TextMobject(<span class="hljs-string">"""</span><span class="hljs-string">            This is a regular text,</span><span class="hljs-string">            $\\displaystyle\\frac{x}{y}$,</span><span class="hljs-string">            $$x^2+y^2=a^2$$</span><span class="hljs-string">            """</span>)</code></pre><p><img src="1565700699069.png" srcset="/img/loading.gif" alt="1565700699069"></p><p>自然地，可以用LaTeX调整字体大小：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SizeTextOnLaTeX</span><span class="hljs-params">(Scene)</span>:</span>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>       textHuge = TextMobject(<span class="hljs-string">"{\\Huge Huge Text 012.\\#!?} Text"</span>)       texthuge = TextMobject(<span class="hljs-string">"{\\huge huge Text 012.\\#!?} Text"</span>)       textLARGE = TextMobject(<span class="hljs-string">"{\\LARGE LARGE Text 012.\\#!?} Text"</span>)       textLarge = TextMobject(<span class="hljs-string">"{\\Large Large Text 012.\\#!?} Text"</span>)       textlarge = TextMobject(<span class="hljs-string">"{\\large large Text 012.\\#!?} Text"</span>)       textNormal = TextMobject(<span class="hljs-string">"{\\normalsize normal Text 012.\\#!?} Text"</span>)       textsmall = TextMobject(<span class="hljs-string">"{\\small small Text 012.\\#!?} Texto normal"</span>)       textfootnotesize = TextMobject(<span class="hljs-string">"{\\footnotesize footnotesize Text 012.\\#!?} Text"</span>)       textscriptsize = TextMobject(<span class="hljs-string">"{\\scriptsize scriptsize Text 012.\\#!?} Text"</span>)       texttiny = TextMobject(<span class="hljs-string">"{\\tiny tiny Texto 012.\\#!?} Text normal"</span>)       textHuge.to_edge(UP)       texthuge.next_to(textHuge, DOWN, buff=<span class="hljs-number">0.1</span>)       textLARGE.next_to(texthuge, DOWN, buff=<span class="hljs-number">0.1</span>)       textLarge.next_to(textLARGE, DOWN, buff=<span class="hljs-number">0.1</span>)       textlarge.next_to(textLarge, DOWN, buff=<span class="hljs-number">0.1</span>)       textNormal.next_to(textlarge, DOWN, buff=<span class="hljs-number">0.1</span>)       textsmall.next_to(textNormal, DOWN, buff=<span class="hljs-number">0.1</span>)       textfootnotesize.next_to(textsmall, DOWN, buff=<span class="hljs-number">0.1</span>)       textscriptsize.next_to(textfootnotesize, DOWN, buff=<span class="hljs-number">0.1</span>)       texttiny.next_to(textscriptsize, DOWN, buff=<span class="hljs-number">0.1</span>)       self.add(textHuge, texthuge, textLARGE, textLarge, textlarge, textNormal, textsmall, textfootnotesize, textscriptsize, texttiny)       self.wait(<span class="hljs-number">3</span>)</code></pre><p><img src="1565704370228.png" srcset="/img/loading.gif" alt="1565704370228"></p></li><li><p><strong><code>TextMobject(string1, string2, string3, ...)</code>：</strong> 传入多个字符串，返回<code>TextMobject</code>数组，可以按照下表索引数组的值</p></li></ol><h2 id="7-LaTeX文本类-TexMobject"><a href="#7-LaTeX文本类-TexMobject" class="headerlink" title="7. LaTeX文本类 TexMobject"></a>7. LaTeX文本类 <code>TexMobject</code></h2><p><code>manimlib\mobject\svg\tex_mobject.py</code></p><p>显示为LaTeX格式(在想要LaTeX字符串按照数组显示时必须使用这个实现)</p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"template_tex_file_body"</span>: TEMPLATE_TEX_FILE_BODY,    <span class="hljs-comment"># 笔画宽度</span>        <span class="hljs-string">"stroke_width"</span>: <span class="hljs-number">0</span>,    <span class="hljs-comment"># 填充不透明度</span>        <span class="hljs-string">"fill_opacity"</span>: <span class="hljs-number">1.0</span>,    <span class="hljs-comment"># 笔画的描边宽度</span>        <span class="hljs-string">"background_stroke_width"</span>: <span class="hljs-number">1</span>,    <span class="hljs-comment"># 笔画的描边颜色</span>        <span class="hljs-string">"background_stroke_color"</span>: BLACK,        <span class="hljs-string">"should_center"</span>: <span class="hljs-literal">True</span>,        <span class="hljs-string">"height"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"organize_left_to_right"</span>: <span class="hljs-literal">False</span>,        <span class="hljs-string">"alignment"</span>: <span class="hljs-string">""</span>,    }</code></pre><p>例：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Formula</span><span class="hljs-params">(Scene)</span>:</span>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>         formula = TexMobject(<span class="hljs-string">"This is a sentence"</span>)        self.play(Write(formula))        self.wait(<span class="hljs-number">3</span>)</code></pre><p><img src="1565769340216.png" srcset="/img/loading.gif" alt="1565769340216"></p><h2 id="8-二维图形类"><a href="#8-二维图形类" class="headerlink" title="8. 二维图形类"></a>8. 二维图形类</h2><p><code>manimlib\mobject\geometry.py</code></p><p>TODO：待完善</p><h3 id="8-1-点Dot"><a href="#8-1-点Dot" class="headerlink" title="8.1 点Dot"></a>8.1 点<code>Dot</code></h3><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"radius"</span>: DEFAULT_DOT_RADIUS,        <span class="hljs-string">"stroke_width"</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">"fill_opacity"</span>: <span class="hljs-number">1.0</span>,        <span class="hljs-string">"color"</span>: WHITE    }</code></pre><h3 id="8-2-圆形Circle"><a href="#8-2-圆形Circle" class="headerlink" title="8.2 圆形Circle"></a>8.2 圆形<code>Circle</code></h3><p>继承自Arc</p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"color"</span>: RED,        <span class="hljs-string">"close_new_points"</span>: <span class="hljs-literal">True</span>,        <span class="hljs-string">"anchors_span_full_range"</span>: <span class="hljs-literal">False</span>    }</code></pre><h3 id="8-3-环Annulus"><a href="#8-3-环Annulus" class="headerlink" title="8.3 环Annulus"></a>8.3 环<code>Annulus</code></h3><p>继承自圆形</p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"inner_radius"</span>: <span class="hljs-number">1</span>,        <span class="hljs-string">"outer_radius"</span>: <span class="hljs-number">2</span>,        <span class="hljs-string">"fill_opacity"</span>: <span class="hljs-number">1</span>,        <span class="hljs-string">"stroke_width"</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">"color"</span>: WHITE,        <span class="hljs-string">"mark_paths_closed"</span>: <span class="hljs-literal">False</span>,    }</code></pre><h3 id="8-4-长方形Rectangle"><a href="#8-4-长方形Rectangle" class="headerlink" title="8.4 长方形Rectangle"></a>8.4 长方形<code>Rectangle</code></h3><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"color"</span>: WHITE,        <span class="hljs-string">"height"</span>: <span class="hljs-number">2.0</span>,        <span class="hljs-string">"width"</span>: <span class="hljs-number">4.0</span>,        <span class="hljs-string">"mark_paths_closed"</span>: <span class="hljs-literal">True</span>,        <span class="hljs-string">"close_new_points"</span>: <span class="hljs-literal">True</span>,    }</code></pre><h3 id="8-5-方形Square"><a href="#8-5-方形Square" class="headerlink" title="8.5 方形Square"></a>8.5 方形<code>Square</code></h3><p>继承自长方形</p><pre><code class="hljs python">CONFIG = {    <span class="hljs-comment"># 边长</span>       <span class="hljs-string">"side_length"</span>: <span class="hljs-number">2.0</span>,   }</code></pre><h3 id="8-6-椭圆Ellipse"><a href="#8-6-椭圆Ellipse" class="headerlink" title="8.6 椭圆Ellipse"></a>8.6 椭圆<code>Ellipse</code></h3><p>继承自圆形</p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"width"</span>: <span class="hljs-number">2</span>,        <span class="hljs-string">"height"</span>: <span class="hljs-number">1</span>    }</code></pre><h3 id="8-7-弧Arc"><a href="#8-7-弧Arc" class="headerlink" title="8.7 弧Arc"></a>8.7 弧<code>Arc</code></h3><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"radius"</span>: <span class="hljs-number">1.0</span>,        <span class="hljs-string">"num_components"</span>: <span class="hljs-number">9</span>,        <span class="hljs-string">"anchors_span_full_range"</span>: <span class="hljs-literal">True</span>,        <span class="hljs-string">"arc_center"</span>: ORIGIN,    }</code></pre><h3 id="8-8-线Line"><a href="#8-8-线Line" class="headerlink" title="8.8 线Line"></a>8.8 线<code>Line</code></h3><p><strong>`Line(start=LEFT, end=RIGHT, </strong>kwargs)`**</p><p><code>start,end</code>:起点终点，形式是np向量</p><p><code>kwargs</code>为配置信息，继承自<code>VMobject</code></p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"fill_color"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"fill_opacity"</span>: <span class="hljs-number">0.0</span>,        <span class="hljs-string">"stroke_color"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"stroke_opacity"</span>: <span class="hljs-number">1.0</span>,        <span class="hljs-string">"stroke_width"</span>: DEFAULT_STROKE_WIDTH,        <span class="hljs-comment"># The purpose of background stroke is to have</span>        <span class="hljs-comment"># something that won't overlap the fill, e.g.</span>        <span class="hljs-comment"># For text against some textured background</span>        <span class="hljs-string">"background_stroke_color"</span>: BLACK,        <span class="hljs-string">"background_stroke_opacity"</span>: <span class="hljs-number">1.0</span>,        <span class="hljs-string">"background_stroke_width"</span>: <span class="hljs-number">0</span>,        <span class="hljs-comment"># When a color c is set, there will be a second color</span>        <span class="hljs-comment"># computed based on interpolating c to WHITE by with</span>        <span class="hljs-comment"># sheen_factor, and the display will gradient to this</span>        <span class="hljs-comment"># secondary color in the direction of sheen_direction.</span>        <span class="hljs-string">"sheen_factor"</span>: <span class="hljs-number">0.0</span>,        <span class="hljs-string">"sheen_direction"</span>: UL,        <span class="hljs-comment"># Indicates that it will not be displayed, but</span>        <span class="hljs-comment"># that it should count in parent mobject's path</span>        <span class="hljs-string">"close_new_points"</span>: <span class="hljs-literal">False</span>,        <span class="hljs-string">"pre_function_handle_to_anchor_scale_factor"</span>: <span class="hljs-number">0.01</span>,        <span class="hljs-string">"make_smooth_after_applying_functions"</span>: <span class="hljs-literal">False</span>,        <span class="hljs-string">"background_image_file"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"shade_in_3d"</span>: <span class="hljs-literal">False</span>,        <span class="hljs-comment"># This is within a pixel</span>        <span class="hljs-comment"># TODO, do we care about accounting for</span>        <span class="hljs-comment"># varying zoom levels?</span>        <span class="hljs-string">"tolerance_for_point_equality"</span>: <span class="hljs-number">1e-6</span>,        <span class="hljs-string">"n_points_per_cubic_curve"</span>: <span class="hljs-number">4</span>,    }</code></pre><h2 id="9-三维图形类"><a href="#9-三维图形类" class="headerlink" title="9. 三维图形类"></a>9. 三维图形类</h2><p><code>manimlib\mobject\three_dimensions.py</code></p><h3 id="9-1-球-Sphere"><a href="#9-1-球-Sphere" class="headerlink" title="9.1 球 Sphere"></a>9.1 球 <code>Sphere</code></h3><p>继承自<code>ParametricSurface</code>,实现通过绘制三维多边形曲面实现的，具体看源码</p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"resolution"</span>: (<span class="hljs-number">12</span>, <span class="hljs-number">24</span>),        <span class="hljs-string">"radius"</span>: <span class="hljs-number">1</span>,        <span class="hljs-string">"u_min"</span>: <span class="hljs-number">0.001</span>,        <span class="hljs-string">"u_max"</span>: PI - <span class="hljs-number">0.001</span>,        <span class="hljs-string">"v_min"</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">"v_max"</span>: TAU,    }</code></pre><h3 id="9-2-立方-Cube"><a href="#9-2-立方-Cube" class="headerlink" title="9.2 立方 Cube"></a>9.2 立方 <code>Cube</code></h3><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"fill_opacity"</span>: <span class="hljs-number">0.75</span>,        <span class="hljs-string">"fill_color"</span>: BLUE,        <span class="hljs-string">"stroke_width"</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">"side_length"</span>: <span class="hljs-number">2</span>,    }</code></pre><h3 id="9-3-棱柱-Prism"><a href="#9-3-棱柱-Prism" class="headerlink" title="9.3 棱柱 Prism"></a>9.3 棱柱 <code>Prism</code></h3><p>继承自<code>Cube</code></p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"dimensions"</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]    }</code></pre><h3 id="9-4-参数曲面-ParametricSurface"><a href="#9-4-参数曲面-ParametricSurface" class="headerlink" title="9.4 参数曲面 ParametricSurface"></a>9.4 参数曲面 <code>ParametricSurface</code></h3><p>参数方程表达的曲面</p><p><strong>`ParametricSurface(func, </strong>kwargs)`**</p><pre><code class="hljs python">CONFIG = {       <span class="hljs-string">"u_min"</span>: <span class="hljs-number">0</span>,       <span class="hljs-string">"u_max"</span>: <span class="hljs-number">1</span>,       <span class="hljs-string">"v_min"</span>: <span class="hljs-number">0</span>,       <span class="hljs-string">"v_max"</span>: <span class="hljs-number">1</span>,       <span class="hljs-string">"resolution"</span>: <span class="hljs-number">32</span>,       <span class="hljs-string">"surface_piece_config"</span>: {},       <span class="hljs-string">"fill_color"</span>: BLUE_D,       <span class="hljs-string">"fill_opacity"</span>: <span class="hljs-number">1.0</span>,       <span class="hljs-string">"checkerboard_colors"</span>: [BLUE_D, BLUE_E],       <span class="hljs-string">"stroke_color"</span>: LIGHT_GREY,       <span class="hljs-string">"stroke_width"</span>: <span class="hljs-number">0.5</span>,       <span class="hljs-string">"should_make_jagged"</span>: <span class="hljs-literal">False</span>,       <span class="hljs-string">"pre_function_handle_to_anchor_scale_factor"</span>: <span class="hljs-number">0.00001</span>,   }</code></pre><p><code>func</code>:自定义的方程，此方程传入两个参数，返回三维向量，每一个分量均是传入两个自变量的表达式</p><p>如：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(x, y)</span>:</span>    <span class="hljs-keyword">return</span> np.array([x ** <span class="hljs-number">2</span>, y + <span class="hljs-number">2</span>, x ** <span class="hljs-number">2</span> - y ** <span class="hljs-number">2</span>])</code></pre><p>绘制三维曲面的例子：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SurfacesAnimation</span><span class="hljs-params">(ThreeDScene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        axes = ThreeDAxes()        cylinder = ParametricSurface(            <span class="hljs-keyword">lambda</span> u, v: np.array([                np.cos(TAU * v),                np.sin(TAU * v),                <span class="hljs-number">2</span> * (<span class="hljs-number">1</span> - u)            ]),            resolution=(<span class="hljs-number">6</span>, <span class="hljs-number">32</span>)).fade(<span class="hljs-number">0.5</span>) <span class="hljs-comment">#Resolution of the surfaces</span>        paraboloid = ParametricSurface(            <span class="hljs-keyword">lambda</span> u, v: np.array([                np.cos(v) * u,                np.sin(v) * u,                u ** <span class="hljs-number">2</span>            ]), v_max=TAU,            checkerboard_colors=[PURPLE_D, PURPLE_E],            resolution=(<span class="hljs-number">10</span>, <span class="hljs-number">32</span>)).scale(<span class="hljs-number">2</span>)        para_hyp = ParametricSurface(            <span class="hljs-keyword">lambda</span> u, v: np.array([                u,                v,                u**<span class="hljs-number">2</span>-v**<span class="hljs-number">2</span>            ]), v_min=<span class="hljs-number">-2</span>, v_max=<span class="hljs-number">2</span>, u_min=<span class="hljs-number">-2</span>, u_max=<span class="hljs-number">2</span>, checkerboard_colors=[BLUE_D, BLUE_E],            resolution=(<span class="hljs-number">15</span>, <span class="hljs-number">32</span>)).scale(<span class="hljs-number">1</span>)        cone = ParametricSurface(            <span class="hljs-keyword">lambda</span> u, v: np.array([                u * np.cos(v),                u * np.sin(v),                u            ]), v_min=<span class="hljs-number">0</span>, v_max=TAU, u_min=<span class="hljs-number">-2</span>, u_max=<span class="hljs-number">2</span>, checkerboard_colors=[GREEN_D, GREEN_E],            resolution=(<span class="hljs-number">15</span>, <span class="hljs-number">32</span>)).scale(<span class="hljs-number">1</span>)        hip_one_side = ParametricSurface(            <span class="hljs-keyword">lambda</span> u, v: np.array([                np.cosh(u) *np.cos(v),                np.cosh(u) * np.sin(v),                np.sinh(u)            ]), v_min=<span class="hljs-number">0</span>, v_max=TAU, u_min=<span class="hljs-number">-2</span>, u_max=<span class="hljs-number">2</span>, checkerboard_colors=[YELLOW_D, YELLOW_E],            resolution=(<span class="hljs-number">15</span>, <span class="hljs-number">32</span>))        ellipsoid=ParametricSurface(            <span class="hljs-keyword">lambda</span> u, v: np.array([                <span class="hljs-number">1</span> * np.cos(u) * np.cos(v),                <span class="hljs-number">2</span> * np.cos(u) * np.sin(v),                <span class="hljs-number">0.5</span> * np.sin(u)            ]), v_min=<span class="hljs-number">0</span>, v_max=TAU, u_min=-PI/<span class="hljs-number">2</span>, u_max=PI/<span class="hljs-number">2</span>, checkerboard_colors=[TEAL_D, TEAL_E],            resolution=(<span class="hljs-number">15</span>, <span class="hljs-number">32</span>)).scale(<span class="hljs-number">2</span>)        sphere = ParametricSurface(            <span class="hljs-keyword">lambda</span> u, v: np.array([                <span class="hljs-number">1.5</span> * np.cos(u) * np.cos(v),                <span class="hljs-number">1.5</span> * np.cos(u) * np.sin(v),                <span class="hljs-number">1.5</span> * np.sin(u)            ]), v_min=<span class="hljs-number">0</span>, v_max=TAU, u_min=-PI/<span class="hljs-number">2</span>, u_max=PI/<span class="hljs-number">2</span>, checkerboard_colors=[RED_D, RED_E],            resolution=(<span class="hljs-number">15</span>, <span class="hljs-number">32</span>)).scale(<span class="hljs-number">2</span>)        self.set_camera_orientation(phi=<span class="hljs-number">75</span> * DEGREES)        self.begin_ambient_camera_rotation(rate=<span class="hljs-number">0.2</span>)        self.add(axes)        self.play(Write(sphere))        self.wait()        self.play(ReplacementTransform(sphere, ellipsoid))        self.wait()        self.play(ReplacementTransform(ellipsoid, cone))        self.wait()        self.play(ReplacementTransform(cone, hip_one_side))        self.wait()        self.play(ReplacementTransform(hip_one_side, para_hyp))        self.wait()        self.play(ReplacementTransform(para_hyp, paraboloid))        self.wait()        self.play(ReplacementTransform(paraboloid, cylinder))        self.wait()        self.play(FadeOut(cylinder))</code></pre><h3 id="9-5-参数曲线-ParametricFunction"><a href="#9-5-参数曲线-ParametricFunction" class="headerlink" title="9.5 参数曲线 ParametricFunction"></a>9.5 参数曲线 <code>ParametricFunction</code></h3><p><strong>`ParametricSurface(func, </strong>kwargs)`**</p><p><code>func</code>:自定义的方程，此方程传入一个参数，返回三维向量，每一个分量均是传入自变量的表达式</p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"t_min"</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">"t_max"</span>: <span class="hljs-number">1</span>,        <span class="hljs-string">"step_size"</span>: <span class="hljs-number">0.01</span>,  <span class="hljs-comment"># Use "auto" (lowercase) for automatic step size</span>        <span class="hljs-string">"dt"</span>: <span class="hljs-number">1e-8</span>,        <span class="hljs-comment"># TODO, be smarter about figuring these out?</span>        <span class="hljs-string">"discontinuities"</span>: [],    }</code></pre><p>例：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParametricCurve2</span><span class="hljs-params">(ThreeDScene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        curve1=ParametricFunction(                <span class="hljs-keyword">lambda</span> u: np.array([                <span class="hljs-number">1.2</span> * np.cos(u),                <span class="hljs-number">1.2</span> * np.sin(u),                u / <span class="hljs-number">2</span>            ]), color=RED, t_min=-TAU, t_max=TAU,        )        curve2=ParametricFunction(                <span class="hljs-keyword">lambda</span> u: np.array([                <span class="hljs-number">1.2</span> * np.cos(u),                <span class="hljs-number">1.2</span> * np.sin(u),                u            ]), color=RED, t_min=-TAU, t_max=TAU,        )        curve1.set_shade_in_3d(<span class="hljs-literal">True</span>)        curve2.set_shade_in_3d(<span class="hljs-literal">True</span>)        axes = ThreeDAxes()        self.add(axes)        self.set_camera_orientation(phi=<span class="hljs-number">80</span> * DEGREES, theta=<span class="hljs-number">-60</span> * DEGREES)        self.begin_ambient_camera_rotation(rate=<span class="hljs-number">0.1</span>)         self.play(ShowCreation(curve1))        self.wait()        self.play(Transform(curve1, curve2), rate_func=there_and_back, run_time=<span class="hljs-number">3</span>)        self.wait()</code></pre><h2 id="10-群组类VGroup"><a href="#10-群组类VGroup" class="headerlink" title="10. 群组类VGroup"></a>10. 群组类<code>VGroup</code></h2><p>可以将多个图像合并为一个组进行批量同步操作(自我理解为<code>Vectorized Group</code>的缩写)</p><p><strong><code>someObjectGroup = VGroup(someObject1, someObject2, ...)</code></strong></p><h3 id="10-1-arrange"><a href="#10-1-arrange" class="headerlink" title="10.1 arrange()"></a>10.1 <code>arrange()</code></h3><p><strong><code>someObjectGroup.arrange(DIRECTION, aligned_edge=DIRECTION, buff=number)</code></strong></p><p><strong><code>DIRECTION</code>：</strong> 以someObject1,someObject2,…顺序按照此方向排列</p><p><strong><code>aligned_edge</code>：</strong> 对齐</p><p><strong><code>buff</code>：</strong> 成员之间的距离</p><p>例：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrangeObjects</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        text1 = TextMobject(<span class="hljs-string">"text1"</span>)        text2 = TextMobject(<span class="hljs-string">"text2 text2"</span>)        text3 = TextMobject(<span class="hljs-string">"text3 text3 text3"</span>)        textgroup = VGroup(text1, text2, text3)        textgroup.arrange(            UP,            aligned_edge=LEFT,            buff=<span class="hljs-number">0.4</span>        )        self.add(textgroup)        self.wait()</code></pre><p><img src="1565844643807.png" srcset="/img/loading.gif" alt="1565844643807"></p><p>动画效果：</p><p>因为<code>arrange</code>第一个参数不在<code>config</code>里面，需要单独放在外面</p><pre><code class="hljs python">self.play(    text_group.arrange,    UP,    {<span class="hljs-string">"aligned_edge"</span>: RIGHT, <span class="hljs-string">"buff"</span>: <span class="hljs-number">2</span>})</code></pre><h2 id="11-相机参数"><a href="#11-相机参数" class="headerlink" title="11. 相机参数"></a>11. 相机参数</h2><p>相机是针对3D动画类(<strong><code>ThreeDScene</code></strong>)的方法</p><p><code>manimlib\scene\three_d_scene.py</code></p><p>将视频的视窗看做相机，就可以通过调整相机的远近，角度来观察三维物体，这就是相机类的作用</p><h3 id="11-1-set-camera-orientation"><a href="#11-1-set-camera-orientation" class="headerlink" title="11.1 set_camera_orientation"></a>11.1 <code>set_camera_orientation</code></h3><p><strong><code>threeDScene.set_camera_orientation(phi=degrees1, theta=degrees2, gamma=degrees3, distance=number)</code></strong></p><p>设置相机的角度</p><h3 id="11-2-move-camera"><a href="#11-2-move-camera" class="headerlink" title="11.2 move_camera"></a>11.2 <code>move_camera</code></h3><p><strong>`threeDScene.move_camera(phi=None, theta=None, distance=None, gamma=None, frame_center=None, added_anims=[], </strong>kwargs)`**</p><p>例子：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoveCamera2</span><span class="hljs-params">(ThreeDScene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        axes = ThreeDAxes()        circle = Circle()        self.set_camera_orientation(phi=<span class="hljs-number">80</span> * DEGREES)                   self.play(ShowCreation(circle), ShowCreation(axes))        <span class="hljs-comment"># Start moving camera</span>        self.begin_ambient_camera_rotation(rate=<span class="hljs-number">0.1</span>)                    self.wait(<span class="hljs-number">5</span>)        <span class="hljs-comment"># Stop moving camera</span>        self.stop_ambient_camera_rotation()                             <span class="hljs-comment"># Return the position of the camera</span>        self.move_camera(phi=<span class="hljs-number">80</span>*DEGREES, theta=-PI/<span class="hljs-number">2</span>)                    self.wait()</code></pre><h3 id="11-3-set-to-default-angled-camera-orientation"><a href="#11-3-set-to-default-angled-camera-orientation" class="headerlink" title="11.3 set_to_default_angled_camera_orientation"></a>11.3 <code>set_to_default_angled_camera_orientation</code></h3><p>还原为默认角度</p><h3 id="11-4-add-fixed-in-frame-mobjects"><a href="#11-4-add-fixed-in-frame-mobjects" class="headerlink" title="11.4 add_fixed_in_frame_mobjects"></a>11.4 <code>add_fixed_in_frame_mobjects</code></h3><p>加入固定在屏幕的图像，此图像不随相机变化而变化</p><p><strong><code>add_fixed_in_frame_mobjects(*mobjects)</code></strong></p><p>例：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Text3D3</span><span class="hljs-params">(ThreeDScene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        axes = ThreeDAxes()        self.set_camera_orientation(phi=<span class="hljs-number">75</span> * DEGREES, theta=<span class="hljs-number">-45</span> * DEGREES)        text3d = TextMobject(<span class="hljs-string">"This is a 3D text"</span>)        self.add_fixed_in_frame_mobjects(text3d) <span class="hljs-comment"># &lt;----- Add this</span>        text3d.to_corner(UL)        self.add(axes)        self.begin_ambient_camera_rotation()        self.play(Write(text3d))        sphere = ParametricSurface(            <span class="hljs-keyword">lambda</span> u, v: np.array([                <span class="hljs-number">1.5</span> * np.cos(u) * np.cos(v),                <span class="hljs-number">1.5</span> * np.cos(u) * np.sin(v),                <span class="hljs-number">1.5</span> * np.sin(u)            ]), v_min=<span class="hljs-number">0</span>, v_max=TAU, u_min=-PI/<span class="hljs-number">2</span>, u_max=PI/<span class="hljs-number">2</span>, checkerboard_colors=[RED_D, RED_E],            resolution=(<span class="hljs-number">15</span>, <span class="hljs-number">32</span>)).scale(<span class="hljs-number">2</span>)        self.play(LaggedStartMap(ShowCreation, sphere))        self.wait(<span class="hljs-number">2</span>)</code></pre><h2 id="12-坐标系类"><a href="#12-坐标系类" class="headerlink" title="12. 坐标系类"></a>12. 坐标系类</h2><h3 id="12-0-数轴类-NumberLine"><a href="#12-0-数轴类-NumberLine" class="headerlink" title="12.0 数轴类 NumberLine"></a>12.0 数轴类 <code>NumberLine</code></h3><p>继承于<code>Line</code>,属性如下：</p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"color"</span>: LIGHT_GREY,        <span class="hljs-comment"># X的范围</span>        <span class="hljs-string">"x_min"</span>: -FRAME_X_RADIUS,        <span class="hljs-string">"x_max"</span>: FRAME_X_RADIUS,        <span class="hljs-comment"># 单元格的大小，默认和单位长度一致</span>        <span class="hljs-string">"unit_size"</span>: <span class="hljs-number">1</span>,        <span class="hljs-comment"># 是否包含刻度tick</span>        <span class="hljs-string">"include_ticks"</span>: <span class="hljs-literal">True</span>,        <span class="hljs-comment"># tick的尺寸，大小为：2个单位*tick_size</span>        <span class="hljs-string">"tick_size"</span>: <span class="hljs-number">0.1</span>,        <span class="hljs-comment"># tick的分布密度</span>        <span class="hljs-string">"tick_frequency"</span>: <span class="hljs-number">1</span>,        <span class="hljs-comment"># Defaults to value near x_min s.t. 0 is a tick</span>        <span class="hljs-comment"># TODO, rename this</span>        <span class="hljs-string">"leftmost_tick"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-comment"># Change name</span>        <span class="hljs-comment"># 最长的tick,作者原意应该是作为数轴标识的tick,一般为中间的tick即原点，会画长一点</span>        <span class="hljs-string">"numbers_with_elongated_ticks"</span>: [<span class="hljs-number">0</span>],        <span class="hljs-comment"># 标上数字</span>        <span class="hljs-string">"include_numbers"</span>: <span class="hljs-literal">False</span>,        <span class="hljs-comment"># 显示的数字格式</span>        <span class="hljs-string">"numbers_to_show"</span>: <span class="hljs-literal">None</span>,        <span class="hljs-string">"longer_tick_multiple"</span>: <span class="hljs-number">2</span>,        <span class="hljs-comment"># 中间的数字</span>        <span class="hljs-string">"number_at_center"</span>: <span class="hljs-number">0</span>,        <span class="hljs-string">"number_scale_val"</span>: <span class="hljs-number">0.75</span>,        <span class="hljs-string">"label_direction"</span>: DOWN,        <span class="hljs-string">"line_to_number_buff"</span>: MED_SMALL_BUFF,        <span class="hljs-comment"># 包含箭头</span>        <span class="hljs-string">"include_tip"</span>: <span class="hljs-literal">False</span>,        <span class="hljs-comment"># tip:箭头，下面两个是其尺寸设置</span>        <span class="hljs-string">"tip_width"</span>: <span class="hljs-number">0.25</span>,        <span class="hljs-string">"tip_height"</span>: <span class="hljs-number">0.25</span>,        <span class="hljs-string">"decimal_number_config"</span>: {            <span class="hljs-string">"num_decimal_places"</span>: <span class="hljs-number">0</span>,        },        <span class="hljs-comment"># 从数字标记中去掉0这个标记</span>        <span class="hljs-string">"exclude_zero_from_default_numbers"</span>: <span class="hljs-literal">False</span>,    }</code></pre><p>注意其中<code>x_min，x_max</code>均为帧的左右范围即每帧的最左边和最右边</p><p><img src="1567675075732.png" srcset="/img/loading.gif" alt="1567675075732"></p><p>本质上来说，数轴是一条线（Line），每一个间隔（tick）均为小的线(Line)</p><p>整个构建流程是，先画出横线作为坐标轴，然后从左到右画出一个个小竖线，最后增加数字，箭头等小部件</p><h3 id="12-1-坐标系抽象类-CoordinateSystem"><a href="#12-1-坐标系抽象类-CoordinateSystem" class="headerlink" title="12.1 坐标系抽象类 CoordinateSystem"></a>12.1 坐标系抽象类 <code>CoordinateSystem</code></h3><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"dimension"</span>: <span class="hljs-number">2</span>,        <span class="hljs-string">"x_min"</span>: -FRAME_X_RADIUS,        <span class="hljs-string">"x_max"</span>: FRAME_X_RADIUS,        <span class="hljs-string">"y_min"</span>: -FRAME_Y_RADIUS,        <span class="hljs-string">"y_max"</span>: FRAME_Y_RADIUS,    }</code></pre><p>主要的几个抽象方法：</p><p><strong><code>coords</code>指的是坐标轴中的点的值,<code>point</code>指没有坐标轴时真实的坐标，在创建坐标轴时候中心设置在ORIGIN，坐标大小没有缩放的时候两者是一样的</strong></p><ul><li><p><code>coords_to_point(*coords)；c2p(*coords)</code>:将坐标系中的点的坐标值转换为屏幕上的点</p></li><li><p><code>point_to_coords(point)；p2c(point)</code>：coords_to_point逆方法</p></li><li><p><code>get_axes()</code>:得到CoordinateSystem对象，一般为包含x,y,z坐标的数组</p></li><li><p><code>get_axis(index)</code>:得到index对应的坐标，xyz坐标对应的index分别为1，2，3</p></li><li><p><code>get_x_axis(); get_y_axis(); get_z_axis()</code></p></li><li><p><code>get_axis_label</code>一类：给对应的坐标（轴）添加标签，显示标签，并返回标签对象</p><ul><li><code>get_axis_label(label_tex, axis, edge, direction, buff=MED_SMALL_BUFF)</code>:</li><li><p><code>get_axis_labels(x_label_tex="x", y_label_tex="y")</code>：</p></li><li><p><code>get_x_axis_label(label_tex, edge=RIGHT, direction=DL, **kwargs)</code>：</p></li><li><p><code>get_y_axis_label(label_tex, edge=UP, direction=DR, **kwargs)</code>:</p></li></ul><p><code>label_tex</code>:坐标标签，使用latex字符串(TexMobject)</p><p><code>axis</code>:想获取的坐标标签的对应的坐标对象</p><p><code>edge</code>:四个边缘位置</p><p><code>direction</code>：在坐标轴的相对位置</p><p><code>**kwargs</code>:其他在config内的配置，如颜色等，自行修改</p></li></ul><p><code>get_graph(function, **kwargs)</code>:给定方程，绘制图像并返回</p><p><code>get_parametric_curve(function, **kwargs)</code>:绘制给定参数曲线方程并返回</p><p><code>input_to_graph_point(x, graph)</code>:暂时没搞清楚啥玩意</p><h3 id="12-2-二维坐标类-Axes"><a href="#12-2-二维坐标类-Axes" class="headerlink" title="12.2 二维坐标类 Axes"></a>12.2 二维坐标类 <code>Axes</code></h3><p>继承<code>CoordinateSystem</code></p><p>实质是创造两个NumberLine数轴，然后将其中一个按照中心旋转90度，作为Y轴，然后对X，Y轴进行其他的属性进行调整，所以配置里面有<code>"number_line_config"</code></p><p><strong>`Axes(</strong>kwargs)`**</p><pre><code class="hljs python">CONFIG = {    <span class="hljs-comment"># 数轴的配置</span>        <span class="hljs-string">"number_line_config"</span>: {            <span class="hljs-string">"color"</span>: LIGHT_GREY,            <span class="hljs-string">"include_tip"</span>: <span class="hljs-literal">True</span>,            <span class="hljs-string">"exclude_zero_from_default_numbers"</span>: <span class="hljs-literal">True</span>,        },    <span class="hljs-comment"># 横坐标轴和数轴的默认配置一样不需要修改</span>        <span class="hljs-string">"x_axis_config"</span>: {},        <span class="hljs-string">"y_axis_config"</span>: {            <span class="hljs-comment"># 默认将“y”这个标签放在纵坐标轴的左侧</span>            <span class="hljs-string">"label_direction"</span>: LEFT,        },    <span class="hljs-comment"># 原点默认和帧图的中心点一致</span>        <span class="hljs-string">"center_point"</span>: ORIGIN,    }</code></pre><p>实现了：</p><ol><li><p><code>coords_to_point(*coords)；c2p(*coords)</code>:将坐标系中的点的坐标值转换为屏幕（帧图）上的点</p><p>分析一下源码：</p></li></ol><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coords_to_point</span><span class="hljs-params">(self, *coords)</span>:</span>    <span class="hljs-comment"># 将坐标轴中的原点0换算为对应的帧图中的坐标</span>    origin = self.x_axis.number_to_point(<span class="hljs-number">0</span>)    <span class="hljs-comment"># 将帧图坐标转换为向量</span>    result = np.array(origin)    <span class="hljs-comment"># result = 原点对应的帧图的坐标+coord相对帧图中原点的坐标 = coord在帧图中的实际坐标</span>    <span class="hljs-keyword">for</span> axis, coord <span class="hljs-keyword">in</span> zip(self.get_axes(), coords):        result += (axis.number_to_point(coord) - origin)    <span class="hljs-keyword">return</span> result</code></pre><ol><li><code>point_to_coords(point)；p2c(point)</code></li></ol><p>增加了方法：</p><p><code>get_coordinate_labels(x_vals=None, y_vals=None)</code>：传入x,y标签的latex字符串，得到对应的x,y坐标轴的标签的对象</p><p><code>add_coordinates(x_vals=None, y_vals=None)</code>:和<code>get_coordinate_labels</code>相似，但是将其加入了自己的成员变量并返回了自己</p><h3 id="12-3-三维坐标系类-ThreeDAxes"><a href="#12-3-三维坐标系类-ThreeDAxes" class="headerlink" title="12.3 三维坐标系类 ThreeDAxes"></a>12.3 三维坐标系类 <code>ThreeDAxes</code></h3><p>继承自Axes</p><p><strong>`ThreeDAxes(</strong>kwargs)`**</p><pre><code class="hljs python">CONFIG = {        <span class="hljs-string">"dimension"</span>: <span class="hljs-number">3</span>,        <span class="hljs-string">"x_min"</span>: <span class="hljs-number">-5.5</span>,        <span class="hljs-string">"x_max"</span>: <span class="hljs-number">5.5</span>,        <span class="hljs-string">"y_min"</span>: <span class="hljs-number">-5.5</span>,        <span class="hljs-string">"y_max"</span>: <span class="hljs-number">5.5</span>,        <span class="hljs-string">"z_axis_config"</span>: {},        <span class="hljs-string">"z_min"</span>: <span class="hljs-number">-3.5</span>,        <span class="hljs-string">"z_max"</span>: <span class="hljs-number">3.5</span>,        <span class="hljs-string">"z_normal"</span>: DOWN,        <span class="hljs-string">"num_axis_pieces"</span>: <span class="hljs-number">20</span>,        <span class="hljs-string">"light_source"</span>: <span class="hljs-number">9</span> * DOWN + <span class="hljs-number">7</span> * LEFT + <span class="hljs-number">1</span>    }</code></pre><h3 id="12-4-NumberPlane"><a href="#12-4-NumberPlane" class="headerlink" title="12.4 NumberPlane"></a>12.4 <code>NumberPlane</code></h3><h3 id="12-5-ComplexPlane"><a href="#12-5-ComplexPlane" class="headerlink" title="12.5 ComplexPlane"></a>12.5 <code>ComplexPlane</code></h3><p>复数坐标系，继承于<code>NumberPlane</code></p><pre><code class="hljs python"><span class="hljs-comment"># author:TB</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComplexPlaneScene</span><span class="hljs-params">(Scene)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">construct</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-comment"># See manimlib/mobject/number_line.py and coordinate_systems.py</span>        cp = ComplexPlane(            y_axis_config={<span class="hljs-string">"decimal_number_config"</span>: {<span class="hljs-string">"unit"</span>: <span class="hljs-string">"i"</span>}},            number_line_config={<span class="hljs-string">"include_numbers"</span>: <span class="hljs-literal">True</span>}        )        x_axis = cp[<span class="hljs-number">-2</span>]        y_axis = cp[<span class="hljs-number">-1</span>]        x_axis.set_color(RED)        y_axis.set_color(PURPLE)        x_labels = x_axis[<span class="hljs-number">1</span>]        x_labels.set_color(ORANGE)        y_labels = y_axis[<span class="hljs-number">1</span>]        y_labels.set_color(YELLOW)        <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> y_labels:            y.rotate(-PI / <span class="hljs-number">2</span>)        x_label = TexMobject(<span class="hljs-string">"x"</span>)        x_label.move_to(cp.c2p(<span class="hljs-number">6.8</span>, x_label.get_height()))        y_label = TexMobject(<span class="hljs-string">"y"</span>)        y_label.move_to(cp.c2p(-y_label.get_width(), <span class="hljs-number">3.8</span>))        self.add(cp, x_label, y_label)        self.wait()</code></pre><h2 id="附录A：常见的常数"><a href="#附录A：常见的常数" class="headerlink" title="附录A：常见的常数"></a>附录A：常见的常数</h2><p><code>manimlib\constants.py</code></p><h3 id="1-颜色"><a href="#1-颜色" class="headerlink" title="1. 颜色"></a>1. 颜色</h3><p>见<code>constants.py</code>中 <strong><code>COLOR_MAP</code></strong> 中的列表</p><p>具体效果见<a href="https://elteoremadebeethoven.github.io/manim_3feb_docs.github.io/html/_static/colors/colors.html" target="_blank" rel="noopener">TB的教程</a></p><h3 id="2-方向"><a href="#2-方向" class="headerlink" title="2. 方向"></a>2. 方向</h3><pre><code class="hljs python">ORIGIN = np.array((<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>))UP = np.array((<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>))DOWN = np.array((<span class="hljs-number">0.</span>, <span class="hljs-number">-1.</span>, <span class="hljs-number">0.</span>))RIGHT = np.array((<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>))LEFT = np.array((<span class="hljs-number">-1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>))IN = np.array((<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">-1.</span>))OUT = np.array((<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>))X_AXIS = np.array((<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>))Y_AXIS = np.array((<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>))Z_AXIS = np.array((<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>))<span class="hljs-comment"># Useful abbreviations for diagonals</span>UL = UP + LEFTUR = UP + RIGHTDL = DOWN + LEFTDR = DOWN + RIGHTTOP = FRAME_Y_RADIUS * UPBOTTOM = FRAME_Y_RADIUS * DOWNLEFT_SIDE = FRAME_X_RADIUS * LEFTRIGHT_SIDE = FRAME_X_RADIUS * RIGHT</code></pre><h3 id="3-角度"><a href="#3-角度" class="headerlink" title="3. 角度"></a>3. 角度</h3><pre><code class="hljs python">PI = np.piTAU = <span class="hljs-number">2</span> * PIDEGREES = TAU / <span class="hljs-number">360</span></code></pre><h3 id="4-距离"><a href="#4-距离" class="headerlink" title="4. 距离"></a>4. 距离</h3><pre><code class="hljs python">SMALL_BUFF = <span class="hljs-number">0.1</span>MED_SMALL_BUFF = <span class="hljs-number">0.25</span>MED_LARGE_BUFF = <span class="hljs-number">0.5</span>LARGE_BUFF = <span class="hljs-number">1</span>DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFFDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>manim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>manim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/03/26/hello-world/"/>
    <url>/2020/03/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>大家好,这个是我的个人博客<br>第一次部署博客可能有点生疏,而且这个博客仅仅是我武汉疫情期间的无聊消遣的时候搭建的<br>如果做的不好大家就谅解一下吧</p><h2 id="以下是博客功能的测试"><a href="#以下是博客功能的测试" class="headerlink" title="以下是博客功能的测试:"></a>以下是博客功能的测试:</h2><ol><li>视频播放: <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;box-shadow: 10px 10px 5px #888888;">     <iframe src="//player.bilibili.com/player.html?aid=3746956&amp;bvid=BV1ys411X7Gt&amp;cid=6008537&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;border-radius: 8px;">      </iframe> </div></li></ol><ol><li><p>嵌入数学公式的书写<br> 欧拉公式:$e^{i\pi}+1=0$非常漂亮</p></li><li><p>数学公式</p><script type="math/tex; mode=display"> \sum_{n=1}^{\infty}\frac{1}{n^2}=\frac{1}{1^2}+\frac{1}{2^2}+\frac{1}{3^2}+...=\frac{\pi^{2}}{6}</script></li><li><p>嵌入代码</p> <pre><code class="hljs python"><span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):        print(<span class="hljs-string">"hello world!!"</span>)</code></pre></li></ol><h2 id="搭建的参考资料"><a href="#搭建的参考资料" class="headerlink" title="搭建的参考资料:"></a>搭建的参考资料:</h2><ol><li>基本的搭建:<br> <a href="https://www.jianshu.com/p/a1a4ebf0e5fc" target="_blank" rel="noopener">https://www.jianshu.com/p/a1a4ebf0e5fc</a><br> <a href="https://www.jianshu.com/p/e995fd69c519" target="_blank" rel="noopener">https://www.jianshu.com/p/e995fd69c519</a></li><li>markdown添加图片遇到坑:<br> <a href="https://www.jianshu.com/p/db02d775aed0" target="_blank" rel="noopener">https://www.jianshu.com/p/db02d775aed0</a><br> <a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345</a></li><li>每页的front-matter设置:<br> <a href="https://www.dazhuanlan.com/2019/11/30/5de154d0810af/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/11/30/5de154d0810af/</a></li><li>文章字数统计与阅读时长:<br> <a href="https://www.jianshu.com/p/f615e79a50d7" target="_blank" rel="noopener">https://www.jianshu.com/p/f615e79a50d7</a></li><li>分类及标签:<br> <a href="https://www.jianshu.com/p/e17711e44e00" target="_blank" rel="noopener">https://www.jianshu.com/p/e17711e44e00</a></li><li>邮箱链接:<br> <a href="https://blog.csdn.net/qq_42893625/article/details/102671013" target="_blank" rel="noopener">https://blog.csdn.net/qq_42893625/article/details/102671013</a></li><li>自适应BiliBili视频大小:<br> <a href="https://teamssix.com/year/190614-111512.html" target="_blank" rel="noopener">https://teamssix.com/year/190614-111512.html</a></li><li>评论系统—Gitalk:<br><a href="https://www.jianshu.com/p/656e6101bf0f" target="_blank" rel="noopener">https://www.jianshu.com/p/656e6101bf0f</a></li><li>coding与github双部署:<br><a href="https://blog.csdn.net/qq_41890607/article/details/104338125" target="_blank" rel="noopener">https://blog.csdn.net/qq_41890607/article/details/104338125</a></li></ol><h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p>主题开发者: <a href="https://jerryc.me/" target="_blank" rel="noopener">https://jerryc.me/</a></p><h2 id="主题的更换"><a href="#主题的更换" class="headerlink" title="主题的更换"></a>主题的更换</h2><p>由于原来的主题感觉过于华丽,不利于阅读,改成了更加的易于阅读的现在的主题</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>csapp-chapter02</title>
    <link href="/2020/03/25/chapter02/"/>
    <url>/2020/03/25/chapter02/</url>
    
    <content type="html"><![CDATA[<h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><p><img src="image-20200320224158463.png" srcset="/img/loading.gif" alt="image-20200320224158463" style="zoom:50%;"></p><h3 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h3><p>在计算机内存中，通常是以字节（Byte），也就是 8 个位（Bit）为基本存储单元（也有以 16 位为基本存储单元的）。对于跨越多个字节的数据类型（比如 int 长 4 个字节），如何在内存中对这些字节进行排序有两种常见的方法：大端法（Big-endian）和小端法（Little-endian）。</p><p><strong>【注】不管是大端法还是小端法存储，计算机在内存中存放数据的顺序都是从低地址到高地址，所不同的是首先取低字节的数据存放在低地址还是取高字节数据存放在低地址。</strong></p><ul><li>若首先取高字节的数据存放在低地址，则是大端法</li><li>若首先取低字节的数据存放在低地址，则是小端法</li></ul><p><img src="image-20200321000815181.png" srcset="/img/loading.gif" alt="image-20200321000815181" style="zoom:50%;"></p><p>大多数Intel兼容机是小端法</p><h3 id="2-1-9-C语言中的移位运算"><a href="#2-1-9-C语言中的移位运算" class="headerlink" title="2.1.9 C语言中的移位运算"></a>2.1.9 C语言中的移位运算</h3><p><img src="image-20200321181504713.png" srcset="/img/loading.gif" alt="image-20200321181504713" style="zoom:50%;"></p><p><strong>遇到一行多个移位运算的时候要记得打括号</strong></p><h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><p>为了表示负数,最常见的计算机表示方式就是补码,将最高位表示为负权:</p><p><img src="image-20200322211917167.png" srcset="/img/loading.gif" alt="image-20200322211917167"></p><p>最高位表示的权重为$-2^{w-1}$.</p><p>补码和计算机表示的二进制码的转换是一一对应的(双射)</p><blockquote><p>为什么不用原码和反码表示负数:</p><ul><li>原码:最高位表示符号,剩下位表示数字</li><li>反码:和补码类似,不过最高位表示的权重为$-(2^{w-1}-1)$</li></ul><p>这两个编码有一个不好的性质,对数字0有两个不同的编码:</p><ul><li>原码中[00..0]表示+0,[10..0]表示-0</li><li>反码中[00..0]表示+0,[11..1]表示-0</li></ul><p>即表示的编码不是一一对应的双射关系</p></blockquote><h3 id="2-2-4-C语言中有符号数和无符号数之间的转换"><a href="#2-2-4-C语言中有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 C语言中有符号数和无符号数之间的转换"></a>2.2.4 C语言中有符号数和无符号数之间的转换</h3><p>强制转换对于有一点编程经验的人来说,看似习以为常,但是在设计强制转换的时候可以选择很多规则,C语言转换规则是:从位级来看,而不是从数值来看.即对应的二进制不变.</p><h3 id="2-2-6-扩展一个数字的位表示"><a href="#2-2-6-扩展一个数字的位表示" class="headerlink" title="2.2.6 扩展一个数字的位表示"></a>2.2.6 扩展一个数字的位表示</h3><p>较大的数据类型转换位较小的可能会出错,但是从较小的数字转换为较大的应该是可以实现的.</p><ul><li><p>将一个无符号数转换为更大的数据类型,只需在开头加0即可,称为<strong>零扩展</strong>:</p><p><img src="image-20200322153501910.png" srcset="/img/loading.gif" alt="image-20200322153501910"></p></li><li><p>将一个补码数字转换为更大的数据类型,可以在在前面填充最高有效位的值,称为符号扩展:</p><p><img src="image-20200322153834509.png" srcset="/img/loading.gif" alt="image-20200322153834509"></p><p>其中$x_{w-1}$为符号位</p></li></ul><h2 id="2-3-整数运算"><a href="#2-3-整数运算" class="headerlink" title="2.3 整数运算"></a>2.3 整数运算</h2><h3 id="2-3-1-无符号加法"><a href="#2-3-1-无符号加法" class="headerlink" title="2.3.1 无符号加法"></a>2.3.1 无符号加法</h3><p>考虑两个非负数x,y,满足$0 \le x,y\le 2^w-1$,每个数都能表示为w位无符号数,则有$0 \le x+y\le 2^{w+1}-2$,表示这个和可能需要w+1位表示.</p><p>一般常见的编程语言仅仅支持固定精度的计算,因此会产生溢出:</p><p><img src="image-20200322175257127.png" srcset="/img/loading.gif" alt="image-20200322175257127"></p><p>上述的也可以称为模数加法,形成了一个数学结构,阿贝尔群,满足如下性质:</p><ul><li>可交换</li><li>仅有一个单位元(这里单位元是0)</li><li>每个元素有一个加法逆元</li></ul><p>所以对于无符号数$x$都有唯一一个逆元$-_w^u x$:</p><p><img src="image-20200322181059389.png" srcset="/img/loading.gif" alt="image-20200322181059389"></p><h3 id="2-3-2-补码加法"><a href="#2-3-2-补码加法" class="headerlink" title="2.3.2 补码加法"></a>2.3.2 补码加法</h3><p>补码加法和无符号加法,对于计算机来说处理是一样的,即截断,然后计算机会将截断后的数字当做补码进行解读.</p><p><img src="image-20200322195842080.png" srcset="/img/loading.gif" alt="image-20200322195842080"></p><h3 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h3><p>范围在$TMin_w \le x\le TMax_w$中的每个数字x都有$+^t_w$下的加法逆元$-^t_w$,称为补码的非:</p><p><img src="image-20200322211418982.png" srcset="/img/loading.gif" alt="image-20200322211418982"></p><h3 id="2-3-4-无符号乘法"><a href="#2-3-4-无符号乘法" class="headerlink" title="2.3.4 无符号乘法"></a>2.3.4 无符号乘法</h3><p>范围在$0\le x,y\le2^w-1$内的整数x,y可以被表示为w位的无符号数,对应的乘积$x \cdot y$的取值范围为$[0,2^{2w}-2^{w+1}+1]$需要2w位表示,但是C语言是用w位表示的,所以有截断:</p><p><img src="image-20200322214057227.png" srcset="/img/loading.gif" alt="image-20200322214057227"></p><h3 id="2-3-5-补码乘法"><a href="#2-3-5-补码乘法" class="headerlink" title="2.3.5 补码乘法"></a>2.3.5 补码乘法</h3><p>范围在$-2^{w-1}\le x,y\le 2^{w-1}-1$内的整数x,y可以被表示位w位的补码,但是成乘积范围在$-2^{w-1}\cdot (2^{w-1}-1)=-2^{2w-2}+2^{w-1}$到$-2^{w-1}\cdot -2^{w-1}=2^{2w-2}$之间,这个范围需要2w位表示,C语言将其截断为w位,将其记为$x*_w^t y$.</p><p>上述机器计算的结果,可以用算法表示为:先将乘积得到的值模$2^w$,得到的无符号数转换为补码:</p><p><img src="image-20200322223742838.png" srcset="/img/loading.gif" alt="image-20200322223742838"></p><p>根据书上的证明有如下结论:相同位表示的无符号数乘法和补码乘法得到的二进制数结果是一样的:</p><p><img src="image-20200322230146529.png" srcset="/img/loading.gif" alt="image-20200322230146529"></p><h3 id="2-3-6-乘以常数"><a href="#2-3-6-乘以常数" class="headerlink" title="2.3.6 乘以常数"></a>2.3.6 乘以常数</h3><p>大多数机器上整数乘法指令相当慢,大多需要10+个时钟周期,编译器因此进行了一定的优化:试着用位移和加法运算的组合来代替乘以常数因子的乘法.</p><p>下面首先说说乘以2的幂的情况:</p><p><img src="image-20200322231300422.png" srcset="/img/loading.gif" alt="image-20200322231300422"></p><p>因此,左移一个数值等价于一个与2的幂相乘的无符号乘法:</p><p><img src="image-20200322231444005.png" srcset="/img/loading.gif" alt="image-20200322231444005"></p><p>无论是无符号还是补码运算,乘以2的幂都会导致溢出,但是即使溢出,通过移位的结果都是一样的</p><p>为了减少代价,许多C语言编译器试图以位移,加法减法消除很多整数乘以常数的情况,例如x*14可以重写为:(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1),更好地有:(x&lt;&lt;4)-(x&lt;&lt;1)</p><p><strong>选择上述的方法还是使用乘法指令,取决于指令的相对速度,而这个与机器高度相关,一般只在仅需要少量位移,加法减法就足够的时候使用这种优化</strong></p><h3 id="2-3-7-除以2的幂"><a href="#2-3-7-除以2的幂" class="headerlink" title="2.3.7 除以2的幂"></a>2.3.7 除以2的幂</h3><p>一般地,整数除法比整数乘法更慢—需要30+个周期,但是除以2的运算可以通过右移计算.无符号和补码数分别通过逻辑右移和算数右移实现.</p><ol><li><p>无符号右移非常简单,因为一定是逻辑右移:</p><p><img src="image-20200322234628390.png" srcset="/img/loading.gif" alt="image-20200322234628390"></p></li><li><p>除以2的幂的补码运算,情况稍有复杂,首先为了保证为负,需要算术右移:</p><p><img src="image-20200322235518595.png" srcset="/img/loading.gif" alt="image-20200322235518595"></p><p><img src="image-20200323000249985.png" srcset="/img/loading.gif" alt="image-20200323000249985"></p><p><strong>注意:上图中向上舍入原理,经过与英文版比较,最后应为”产生数值$\lceil  x/2^k\rceil$”</strong>,定义偏量为$(1&lt;&lt;k)-1$,下面有几个例子:</p><p><img src="image-20200323003738528.png" srcset="/img/loading.gif" alt="image-20200323003738528"></p><p>根据下图的几个数据与相关的证明可以知道:</p><ul><li>对于不需要舍入的情况,加上偏量只会影响最后被移掉的位</li><li>对于需要舍入的情况,加上偏量会导致较高的位加1,这个会导致向0舍入</li></ul><blockquote><p>偏置技术用的数学知识:$\lceil x/y\rceil=\lfloor (x+y-1)/y\rfloor$(x,y为整数)</p><p>所以上面的式子:(x+(1&lt;<k)-1)>&gt;k,中,y为$2^k$,$(x+2^k-1)/2^k$就表示$\lceil  x/2^k\rceil$</k)-1)></p></blockquote></li></ol><p>综合1,2两个情况,得到C的算术右移的补码机器,计算$x/2^k$:</p><pre><code class="hljs c++">(x&lt;<span class="hljs-number">0</span> ? x+(<span class="hljs-number">1</span>&lt;&lt;k)<span class="hljs-number">-1</span> : x)&gt;&gt;k</code></pre><p>可惜的是,不能将除以2的幂推广到一般除法.</p><h2 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h2><p>与十进制类似,形如$b<em>mb</em>{m-1}…b<em>1b_0.b</em>{-1}b<em>{-2}…b</em>{-n-1}b_{-n}$的二进制数,其对应的十进制的值为:</p><script type="math/tex; mode=display">b=\sum_{i=-n}^{m}2^i\times b_i</script><p>有限长度的编码不能表示如$\frac{1}{3},\frac{5}{7}$的数字,小数的二进制表示法仅能表示能被写成$x\times2^y$的数.</p><h3 id="2-4-2-IEEE浮点表示"><a href="#2-4-2-IEEE浮点表示" class="headerlink" title="2.4.2 IEEE浮点表示"></a>2.4.2 IEEE浮点表示</h3><p><img src="image-20200323182025508.png" srcset="/img/loading.gif" alt="image-20200323182025508"></p><p>下图是常见的单双精度的浮点数的格式:</p><p><img src="image-20200323183711302.png" srcset="/img/loading.gif" alt="image-20200323183711302"></p><p>上图说明了:</p><div class="table-container"><table><thead><tr><th>精度</th><th>s位数</th><th>exp位数</th><th>frac位数</th></tr></thead><tbody><tr><td>单</td><td>1</td><td>8</td><td>23</td></tr><tr><td>双</td><td>1</td><td>11</td><td>52</td></tr></tbody></table></div><p>给定位表示,根据exp的值,被编码的值可以分成三种不同的情况(最后一种有两个不同的变种),下图为单精度的数字表示:</p><p><img src="image-20200323192300543.png" srcset="/img/loading.gif" alt="image-20200323192300543"></p><p>由上图有以下几个解码:</p><ol><li><p>规格化的数值</p><p>此时,阶码的值E=e-Bias,e是exp字段对应的无符号数,Bias为$2^{k-1}-1$,其中k为exp的位数,因此产生的指数E的范围对于单精度为-126~+127,对于双精度为-1022~+1023</p><p>frac是小数值$f$,$0\le f &lt; 1$,二进制表示为$0.f_{n-1}…f_1f_0$,为数M定义为$M=1+f$,因为对于二进制来说,按照十进制的科学计数法的规则,二进制科学计数法第一位一定为1,为了节省比特位,直接将其隐藏,这种方法也叫隐含的以1开头的表示.</p></li><li><p>非规格化的值</p><p>当阶码域exp全部是0的时候,所表示的数字是非规格化的形式,此时阶码$E=1-Bias$,尾数的值是$M=f$,也就是小数字段的值,不包含隐含的1</p><blockquote><p>为什么要对于非规格化的值设置这样的偏置值:</p><p>这样可以让从非规格化到规格化的转换平滑</p></blockquote><p>非规格化的用途:</p><ul><li><p>提供一种表示0的方法,如果使用规格化数,必须$M\ge 1$,所以不能表示0,$+0.0$的浮点表示位模式为所有位为0,此时$M=f=0$,当符号位为1,其他所有位为0的的时候,表示$-0.0$.</p><p>IEEE的浮点格式表示,$+0.0$和$-0.0$在某些方面是不同的</p></li><li><p>表示那些非常接近0.0的数,非规格化提供一种属性:逐渐溢出(gradual underflow),表示一个数与0的距离非常小</p></li></ul></li><li><p>特殊值</p><ul><li>3a: 当阶码域exp全是1,小数域全是0,得到的值表示无穷,s决定是正无穷还是负无穷,当把两个非常大的数字相乘或者进行了除以0的操作后,无穷能表示溢出</li><li>3b: 当小数域非0的时候,结果值为NaN(Not a Number),这用于表示不是实数或者无穷:$\sqrt{-1}或\infty - \infty $等</li></ul></li></ol><h3 id="2-4-3-数字示例"><a href="#2-4-3-数字示例" class="headerlink" title="2.4.3 数字示例"></a>2.4.3 数字示例</h3><p><img src="image-20200323232701819.png" srcset="/img/loading.gif" alt="image-20200323232701819"></p><p><img src="image-20200323232716933.png" srcset="/img/loading.gif" alt="image-20200323232716933"></p><h3 id="2-4-4-舍入"><a href="#2-4-4-舍入" class="headerlink" title="2.4.4 舍入"></a>2.4.4 舍入</h3><p>默认的方式为:向偶数舍入,也被称为向最近的值舍入(round-to-nearest),又叫向偶数舍入(round-to-even).方法为”四舍六入五成双”,使得到的最低有效位为偶数</p><p>其他的几种有:向零舍入,向下舍入,向上舍入</p><p>向偶舍入的原因:为了将50%的几率向上舍入和50%几率向下舍入</p><p>向偶舍入也可以应用到二进制:将最低有效位的值为0认为是偶数,1为奇数</p><h3 id="2-4-5-浮点运算"><a href="#2-4-5-浮点运算" class="headerlink" title="2.4.5 浮点运算"></a>2.4.5 浮点运算</h3><p>IEEE标准制定了简单的规则确定加法乘法这样的算术运算结果:</p><p>由于精度的限制,对于两个浮点数x,y,某个运算$x\bigodot y$产生的值,计算机会再进行舍入:$Round(x\bigodot y)$</p><p>当其中有一个为特殊值的时候(如-0,无穷,NaN),IEEE定义了一些更合理的规则:1/-0产生$-\infty$,1/+0产生$+\infty$.</p><p>整数加法形成了阿贝尔群,IEEE标准实数加法也构成了阿贝尔群,但是证明过程需要加上Round()函数的证明:</p><p>将$x+^fy$定义为$Round(x+y)$,如果不考虑溢出则直接可以得到就是阿贝尔群,但是如果考虑溢出:</p><ol><li><p>交换律</p><p>交换律:交换x,y是都会同样的方式溢出,所以$+^f$是可交换的;</p></li><li><p>不可结合:例如,使用单精度浮点(3.14+1e10)-1e10=0.0因为3.14作为尾数被舍入,减去1e10变为0,而3.14+(1e10-1e10)=3.14）</p></li><li><p>逆元</p><p>对于x,不考虑溢出明显有逆元-x,如果考虑溢出:$x+^f(-x)$一般都为0,但是有例外$+\infty+^f(-\infty)=NaN$,$NaN+^fx=NaN$</p><p>可见这个逆元不能普适,所以也不存在单位元,所以$+^{f}$不是阿贝尔群</p></li><li><p>另外浮点加法的性质还包含单调性</p></li></ol><p>浮点乘法具有:</p><ol><li><p>交换律</p></li><li><p>不可结合</p></li><li><p>对加法不具有分配律</p></li><li><p>单调性:</p><script type="math/tex; mode=display">a \ge b 且 c \ge 0 \to a * ^f c\ge b*^fc\\a \ge b 且 c \le 0 \to a * ^f c\le b*^fc</script></li><li><p>平方大于等于0:</p><p>若$a\ne 0:a*a\ge0$</p></li></ol><p>缺乏结合性和分配性对科学计算程序员和编译器的编写造成麻烦</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <categories>
      
      <category>深入理解计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
