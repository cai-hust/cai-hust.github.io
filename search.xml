<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql源码--main函数</title>
      <link href="/2020/07/03/mysql-yuan-ma-main-han-shu/"/>
      <url>/2020/07/03/mysql-yuan-ma-main-han-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-main函数的理解"><a href="#1-main函数的理解" class="headerlink" title="1. main函数的理解"></a>1. main函数的理解</h1><p>函数的入口在<code>mysqld/main.cc</code>里面：</p><p><img src="image-20200627163326858.png" alt="mysqld/main.cc"></p><p>而里面的函数在两个地方出现：</p><p><img src="image-20200627163411816.png" alt="vs终端显示"></p><p>第一处在<code>mysqld.cc</code>的4364行出现：</p><p><img src="image-20200627165111499.png" alt="第一处"></p><p>从上很明显看出，如果是WIN32系统，则函数名字是<code>win_main</code>,而我的系统是64位的系统，所以函数才会被命名为<code>mysqld_main</code>.</p><p>第二个<code>mysqld_main</code>是在WIN32系统中定义的，在此不考虑：</p><p><img src="image-20200627165736272.png" alt="第二处"></p><p>查阅资料发现，Mysql为了实现可以在win32平台与类Uninx平台代码共用，将一些公用的函数抽象出来，但是win32和类unix平台启动方式不一样。细看win32的mysqld_main调用了mysql_service，mysql_service又调用了win_main函数，经过特殊操作处理后又回到了函数的公共定义内容：</p><pre class=" language-lang-C++"><code class="language-lang-C++">//win32的mysqld_mainint mysqld_main(int argc, char **argv){    //...    mysql_service(NULL);    //...}int mysql_service(void *p){    //...    if (use_opt_args)        win_main(opt_argc, opt_argv);      else        win_main(Service.my_argc, Service.my_argv);    //...}//此win_main，就是第一个mysqld_main的代码内容</code></pre><h1 id="2-main函数的流程"><a href="#2-main函数的流程" class="headerlink" title="2. main函数的流程"></a>2. main函数的流程</h1><h2 id="2-1准备"><a href="#2-1准备" class="headerlink" title="2.1准备"></a>2.1准备</h2><ol><li><p>执行基本的线程库和malloc初始化，读取默认文件和解析选项。</p><pre class=" language-lang-c++"><code class="language-lang-c++">if (load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv))  {    flush_error_log_messages();    return 1;  }</code></pre></li><li><p>是否使用PERFORMANCE_SCHEMA存储引擎</p><pre class=" language-lang-c++"><code class="language-lang-c++">#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE  /*    Initialize the array of performance schema instrument configurations.  */  init_pfs_instrument_array();#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */</code></pre><p><img src="image-20200627203915117.png" alt="mysql架构"><br>图源自:<a href="https://draven.co/" target="_blank" rel="noopener">https://draven.co/</a></p></li><li><p>默认配置文件的加载</p><pre class=" language-lang-c++"><code class="language-lang-c++">load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv)</code></pre><p>my.ini文件的加载顺序，它会这样加载：<br>C:/WINDOWS/my.cnf　C:/WINDOWS/my.ini　C:/my.cnf 　C:/my.ini</p><p>如果指定了MYSQL_HOME，在找不到前边4个文件的时候，它会去查找$MYSQL_HOME$/my.cnf或my.ini</p><p>对应的代码如下：</p><pre class=" language-lang-c++"><code class="language-lang-c++">char fname_buffer[FN_REFLEN];//C:/WINDOWS/my.cnfif (my_get_system_windows_directory(fname_buffer, sizeof(fname_buffer)))   errors += add_directory(alloc, fname_buffer, dirs);//C:/WINDOWS/my.iniif (GetWindowsDirectory(fname_buffer, sizeof(fname_buffer)))   errors += add_directory(alloc, fname_buffer, dirs);//C:/my.cnferrors += add_directory(alloc, "C:/", dirs);//C:/my.iniif (my_get_module_parent(fname_buffer, sizeof(fname_buffer)) != NULL)   errors += add_directory(alloc, fname_buffer, dirs);//。。。如果是Linux系统。。。//如果上面的四个位置找不到，则进行下面查找if ((env= getenv("MYSQL_HOME")))    errors += add_directory(alloc, env, dirs);  /* Placeholder for --defaults-extra-file=<path> */  errors += add_directory(alloc, "", dirs);</code></pre></li></ol><h2 id="2-1WITH-PERFSCHEMA-STORAGE-ENGINE宏定义"><a href="#2-1WITH-PERFSCHEMA-STORAGE-ENGINE宏定义" class="headerlink" title="2.1WITH_PERFSCHEMA_STORAGE_ENGINE宏定义"></a>2.1<code>WITH_PERFSCHEMA_STORAGE_ENGINE</code>宏定义</h2><pre class=" language-lang-C++"><code class="language-lang-C++">#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE  /*    Initialize the array of performance schema instrument configurations.  */  init_pfs_instrument_array();#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */</code></pre><p>对应的编译的参数为<code>-DWITH_ARCHIVE_STORAGE_ENGINE=1</code>，对应的详细信息在：</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/performance-schema.html</a></p><p><img src="image-20200628123338750.png" alt="文件位置"></p><ol><li><p>初始化一些线程会用到的锁、信号量、变量等，其中封装了一些pthread的函数</p><p>接了下来调用了各种线程的初始化，过程感觉不是重点，没有继续看下去</p><pre class=" language-lang-C++"><code class="language-lang-C++">if (my_init())  {    sql_print_error("my_init() failed.");    flush_error_log_messages();    return 1;  }</code></pre></li><li><p>初始化SQL statement</p><p><code>init_sql_statement_names();</code></p></li><li><p>初始化系统变量</p><pre class=" language-lang-C++"><code class="language-lang-C++">int sys_var_init(){  DBUG_ENTER("sys_var_init");  /* Must be already initialized. */  DBUG_ASSERT(system_charset_info != NULL);  if (my_hash_init(&system_variable_hash, system_charset_info, 100, 0,                   0, (my_hash_get_key) get_sys_var_length, 0, HASH_UNIQUE,                   PSI_INSTRUMENT_ME))    goto error;  if (mysql_add_sys_var_chain(all_sys_vars.first))    goto error;  DBUG_RETURN(0);error:  my_message_local(ERROR_LEVEL, "failed to initialize system variables");  DBUG_RETURN(1);}</code></pre><p><code>system_variable_hash</code>是一个用于保存<code>sys_var</code>的哈希表</p><p><code>mysql_add_sys_var_chain</code>这个函数的本意应该是将<code>all_sys_vars</code>中的数据都加入<code>system_variable_hash</code>这个哈希表中</p></li><li><p>调整相关的选项</p><pre class=" language-lang-c++"><code class="language-lang-c++">adjust_related_options(&requested_open_files);</code></pre><p>具体的内容不是很清楚，看方法名猜测是调整函数名字对应的几个参数：</p><pre class=" language-lang-c++"><code class="language-lang-c++">void adjust_related_options(ulong *requested_open_files){  /* In bootstrap, disable grant tables (we are about to create them) */  if (opt_bootstrap)    opt_noacl= 1;  /* The order is critical here, because of dependencies. */  adjust_open_files_limit(requested_open_files);  adjust_max_connections(*requested_open_files);  adjust_table_cache_size(*requested_open_files);  adjust_table_def_size();}</code></pre><p>打开文件的数量，最大连接数，表缓存大小等等</p><ul><li><p>open_files_limit值：</p><p>my.cnf里如果配置了open_files_limit，open_files_limit最后取值为 配置文件 open_files_limit，max_connections*5， wanted_files= 10+max_connections+table_cache_size*2 三者中的最大值。</p><p>如果my.cnf里如果没配置open_files_limit，open_files_limit最后取值为max_connections*5，10+max_connections+table_cache_size*2，ulimit -n中的最大者</p></li><li><p>max_connections的限制：</p><p>因为MySQL的最大连接数受到了安装平台的线程库、可用内存、每个连接需要使用的内存、每个连接的工作量、响应时间的影响，linux大概能承受500～1000并发请求，而Windows由于Posix通用接口层的限制，必须满足(open tables × 2 + open connections) &lt; 2048</p><pre class=" language-lang-c++"><code class="language-lang-c++">void adjust_max_connections(ulong requested_open_files){  ulong limit;  limit= requested_open_files - 10 - TABLE_OPEN_CACHE_MIN * 2;  if (limit < max_connections)  {    sql_print_warning("Changed limits: max_connections: %lu (requested %lu)",                      limit, max_connections);    // This can be done unprotected since it is only called on startup.    max_connections= limit;  }}</code></pre><p>TABLE_OPEN_CACHE_MIN是写死的宏：400</p></li><li><p>table_open_cache</p><p>table_open_cache受到了max_connections的限制，至少需要连接数*该链接执行的join表的个数</p><pre class=" language-lang-c++"><code class="language-lang-c++">void adjust_table_cache_size(ulong requested_open_files){  ulong limit;  limit= max<ulong>((requested_open_files - 10 - max_connections) / 2,                    TABLE_OPEN_CACHE_MIN);  if (limit < table_cache_size)  {    sql_print_warning("Changed limits: table_open_cache: %lu (requested %lu)",                      limit, table_cache_size);    table_cache_size= limit;  }  table_cache_size_per_instance= table_cache_size / table_cache_instances;}</code></pre></li><li><p>table_definition_cache</p><p>table_definition_cache是能放在缓存中的表的定义的数量，表的定义在缓存中的时候能够加快打开表的速度，默认是400 + (table_open_cache / 2)</p><pre class=" language-lang-c++"><code class="language-lang-c++">default_value= min<ulong> (400 + table_cache_size / 2, 2000);  var= intern_find_sys_var(STRING_WITH_LEN("table_definition_cache"));  DBUG_ASSERT(var != NULL);  var->update_default(default_value);</code></pre></li></ul></li><li><p>对相关的配置进行生效</p><pre class=" language-lang-c++"><code class="language-lang-c++">if (ho_error == 0)  {    if (!opt_help && !opt_bootstrap)    {      /* Add sizing hints from the server sizing parameters. */      pfs_param.m_hints.m_table_definition_cache= table_def_size;      pfs_param.m_hints.m_table_open_cache= table_cache_size;      pfs_param.m_hints.m_max_connections= max_connections;      pfs_param.m_hints.m_open_files_limit= requested_open_files;      pfs_param.m_hints.m_max_prepared_stmt_count= max_prepared_stmt_count;      PSI_hook= initialize_performance_schema(&pfs_param);      if (PSI_hook == NULL && pfs_param.m_enabled)      {        pfs_param.m_enabled= false;        sql_print_warning("Performance schema disabled (reason: init failed).");      }    }  }</code></pre></li></ol><h2 id="2-2HAVE-PSI-INTERFACE宏定义"><a href="#2-2HAVE-PSI-INTERFACE宏定义" class="headerlink" title="2.2HAVE_PSI_INTERFACE宏定义"></a>2.2<code>HAVE_PSI_INTERFACE</code>宏定义</h2><p>PSI代表：Performance schema instrumentation interface性能模式检测接口</p><pre class=" language-lang-c++"><code class="language-lang-c++">#ifdef HAVE_PSI_INTERFACE  /*    获取当前的性能模式检测接口，如果可供使用的话。  */  if (PSI_hook)  {    PSI *psi_server= (PSI*) PSI_hook->get_interface(PSI_CURRENT_VERSION);    if (likely(psi_server != NULL))    {      set_psi_server(psi_server);      /*        2.1解析了命令行参数，并且已经初始化了性能模式(performance schema instrument)，接下来注册所有服务器检测      */      init_server_psi_keys();      /* 检测主要的线程 */      PSI_thread *psi= PSI_THREAD_CALL(new_thread)(key_thread_main, NULL, 0);      PSI_THREAD_CALL(set_thread_os_id)(psi);      PSI_THREAD_CALL(set_thread)(psi);      /*        一些检测已经到位,重新初始化在之前已经初始化的对象,以便更好的检测.      */      my_thread_global_reinit();    }  }#endif /* HAVE_PSI_INTERFACE */</code></pre><h2 id="2-3-query日志初始化"><a href="#2-3-query日志初始化" class="headerlink" title="2.3 query日志初始化"></a>2.3 query日志初始化</h2><pre class=" language-lang-C++"><code class="language-lang-C++">init_error_log();  /* Initialize audit interface globals. Audit plugins are inited later. */  mysql_audit_initialize();#ifndef EMBEDDED_LIBRARY  Srv_session::module_init();#endif  /*    执行基本查询日志初始化。 应该在MY_INIT之后调用，因为它会初始化互斥量。  */  query_logger.init();</code></pre><h2 id="2-4-如果错误则退出"><a href="#2-4-如果错误则退出" class="headerlink" title="2.4 如果错误则退出"></a>2.4 如果错误则退出</h2><pre class=" language-lang-C++"><code class="language-lang-C++">  if (ho_error)  {    /*     解析命令行选项失败，由于没有可行的剩下的_argc / remaining_argv来继续服务器初始化，因此代码已尽其所能。       这是记录有意义消息的最大努力：       -消息将打印到stderr，但尚未重定向，       -对于Windows，消息将打印在NT事件日志中。    */    flush_error_log_messages();    /*      Not enough initializations for unireg_abort()      Using exit() for windows.    */    exit (MYSQLD_ABORT_EXIT);  }  if (init_common_variables())    unireg_abort(MYSQLD_ABORT_EXIT);        // 如果初始化失败就直接退出SQL  my_init_signals();</code></pre><h2 id="2-5-堆栈的大小初始化"><a href="#2-5-堆栈的大小初始化" class="headerlink" title="2.5 堆栈的大小初始化"></a>2.5 堆栈的大小初始化</h2><pre class=" language-lang-C++"><code class="language-lang-C++">my_thread_attr_setstacksize(&connection_attrib,                            my_thread_stack_size + guardize);  {    /* Retrieve used stack size;  Needed for checking stack overflows */    size_t stack_size= 0;    my_thread_attr_getstacksize(&connection_attrib, &stack_size);    /* We must check if stack_size = 0 as Solaris 2.9 can return 0 here */    if (stack_size && stack_size < (my_thread_stack_size + guardize))    {      sql_print_warning("Asked for %lu thread stack, but got %ld",                        my_thread_stack_size + guardize, (long) stack_size);#if defined(__ia64__) || defined(__ia64)      my_thread_stack_size= stack_size / 2;#else      my_thread_stack_size= static_cast<ulong>(stack_size - guardize);#endif    }  }</code></pre><h2 id="2-6-开启binlog会检查server-id"><a href="#2-6-开启binlog会检查server-id" class="headerlink" title="2.6 开启binlog会检查server_id"></a>2.6 开启binlog会检查server_id</h2><pre class=" language-lang-python"><code class="language-lang-python">if (opt_bin_log && !(server_id_supplied) )  {    sql_print_error("You have enabled the binary log, but you haven't provided "                    "the mandatory server-id. Please refer to the proper "                    "server start-up parameters documentation");    unireg_abort(MYSQLD_ABORT_EXIT);  }</code></pre><p>如果开启二进制日志但是没有提供操作服务器ID就会报错并退出</p><h2 id="2-7-服务器组件初始化"><a href="#2-7-服务器组件初始化" class="headerlink" title="2.7 服务器组件初始化"></a>2.7 服务器组件初始化</h2><pre class=" language-lang-c++"><code class="language-lang-c++">if (init_server_components())    unireg_abort(MYSQLD_ABORT_EXIT);</code></pre><h2 id="2-8检查data目录下是否有auto-cnf"><a href="#2-8检查data目录下是否有auto-cnf" class="headerlink" title="2.8检查data目录下是否有auto.cnf"></a>2.8检查data目录下是否有auto.cnf</h2><pre class=" language-lang-c++"><code class="language-lang-c++">  /*    Each server should have one UUID. We will create it automatically, if it    does not exist.   */  if (init_server_auto_options())  {    sql_print_error("Initialization of the server's UUID failed because it could"                    " not be read from the auto.cnf file. If this is a new"                    " server, the initialization failed because it was not"                    " possible to generate a new UUID.");    unireg_abort(MYSQLD_ABORT_EXIT);  }</code></pre><h2 id="2-9将uuid加入sid-map-中"><a href="#2-9将uuid加入sid-map-中" class="headerlink" title="2.9将uuid加入sid_map()中"></a>2.9将uuid加入sid_map()中</h2><pre class=" language-lang-c++"><code class="language-lang-c++">  /*    Add server_uuid to the sid_map.  This must be done after    server_uuid has been initialized in init_server_auto_options and    after the binary log (and sid_map file) has been initialized in    init_server_components().    No error message is needed: init_sid_map() prints a message.    Strictly speaking, this is not currently needed when    opt_bin_log==0, since the variables that gtid_state->init    initializes are not currently used in that case.  But we call it    regardless to avoid possible future bugs if gtid_state ever    needs to do anything else.  */  global_sid_lock->wrlock();  int gtid_ret= gtid_state->init();  global_sid_lock->unlock();  if (gtid_ret)    unireg_abort(MYSQLD_ABORT_EXIT);</code></pre><h2 id="2-10初始化gtid-state对象以及对应的操作"><a href="#2-10初始化gtid-state对象以及对应的操作" class="headerlink" title="2.10初始化gtid_state对象以及对应的操作"></a>2.10初始化gtid_state对象以及对应的操作</h2><pre class=" language-lang-c++"><code class="language-lang-c++">  // Initialize executed_gtids from mysql.gtid_executed table.  if (gtid_state->read_gtid_executed_from_table() == -1)    unireg_abort(1);</code></pre><p>GTID (Global Transaction ID)是全局事务ID,当在主库上提交事务或者被从库应用时，可以定位和追踪每一个事务，对DBA来说意义就很大了，我们可以适当的解放出来，不用手工去可以找偏移量的值了，而是通过CHANGE MASTER TO MASTER_HOST=’xxx’, MASTER_AUTO_POSITION=1的即可方便的搭建从库，在故障修复中也可以采用MASTER_AUTO_POSITION=‘X’的方式。</p><p>在以下四种情况下，将未保存的GTID保存到gtid_exected表中：</p><ol><li>升级</li><li>从主服务器的备份中配置了一个从服务器，并且在此之前通过RESET MASTER和RESET SLAVE清除了从服务器。</li><li>在崩溃前从服务器上的最后一个RESET MASTER没有发生二进制日志轮换</li><li>如果服务器崩溃，则最后一个binlog的GTID集不会保存到gtid_exected表中，因此在从崩溃中恢复期间，我们将其保存到gtid_executed表和execute_gtids中。</li></ol><p>其中的代码我没有仔细研究</p><h2 id="2-11-网络连接"><a href="#2-11-网络连接" class="headerlink" title="2.11 网络连接"></a>2.11 网络连接</h2><ul><li><p>SSL支持与网络的初始化</p><pre class=" language-lang-C++"><code class="language-lang-C++">  if (init_ssl())    unireg_abort(MYSQLD_ABORT_EXIT);  if (network_init())    unireg_abort(MYSQLD_ABORT_EXIT);</code></pre><p>network_init主要做了以下几件事情：</p><blockquote><p><a href="https://blog.csdn.net/Martin201609/article/details/100747413" target="_blank" rel="noopener">https://blog.csdn.net/Martin201609/article/details/100747413</a></p></blockquote><p>set_ports() 进行相应的初始化端口,创建监听对象Mysqld_socket_listener，并对其进行相应的初始化操作。然后对listener进行相应的侦听动作</p><pre class=" language-lang-C++"><code class="language-lang-C++">static bool network_init(void){  if (opt_bootstrap)    return false;  set_ports(); //端口设置  //... Mysqld_socket_listener *mysqld_socket_listener=      new (std::nothrow) Mysqld_socket_listener(bind_addr_str,                                                mysqld_port, back_log,                                                mysqld_port_timeout,                                                unix_sock_name);}//监听对象// ...mysqld_socket_acceptor=      new (std::nothrow) Connection_acceptor<Mysqld_socket_listener>(mysqld_socket_listener);////...    if (mysqld_socket_acceptor->init_connection_acceptor())//实例化并监听      return true; // mysqld_socket_acceptor would be freed in unireg_abort.</code></pre><p><code>set_port()</code>:</p><pre class=" language-lang-c++"><code class="language-lang-c++">static void set_ports(){  char  *env;  if (!mysqld_port && !opt_disable_networking)  {         // Get port if not from commandline    mysqld_port= MYSQL_PORT;    /*      如果构建器明确要求使用默认端口，则使用该端口（即使它与默认值一致）。 只有在他们没有这样做的情况下，我们才        检查/etc/services（如果失败，则退回到出厂默认值3306）。 这两个默认值都可以被环境变量MYSQL_TCP_PORT        覆盖，而环境变量又可以由命令行选项覆盖。    */#if MYSQL_PORT_DEFAULT == 0 //这个参数是在make编译生成之后，在include/mysql_version.h生成，其值为 #define MYSQL_PORT_DEFAULT          @MYSQL_TCP_PORT_DEFAULT@    //MYSQL_TCP_PORT_DEFAULT这个值是在cmake/mysql_version.cmake的文件中配置的    /*    [root@pcserver mysql-5.7.27]# grep -rn "MYSQL_TCP_PORT_DEFAULT" *    cmake/mysql_version.cmake:88:SET(MYSQL_TCP_PORT_DEFAULT "3306")    cmake/mysql_version.cmake:91:  SET(MYSQL_TCP_PORT ${MYSQL_TCP_PORT_DEFAULT})    cmake/mysql_version.cmake:92:  SET(MYSQL_TCP_PORT_DEFAULT "0")    cmake/mysql_version.cmake:93:ELSEIF(MYSQL_TCP_PORT EQUAL MYSQL_TCP_PORT_DEFAULT)    cmake/mysql_version.cmake:94:  SET(MYSQL_TCP_PORT_DEFAULT "0")    include/mysql_version.h.in:18:#define MYSQL_PORT_DEFAULT          @MYSQL_TCP_PORT_DEFAULT@    scripts/mysql_config.pl.in:161:if ( '@MYSQL_TCP_PORT_DEFAULT@' == 0 ) {    scripts/mysql_config.sh:106:if [ @MYSQL_TCP_PORT_DEFAULT@ -eq 0 ]; then    */    struct  servent *serv_ptr;    if ((serv_ptr= getservbyname("mysql", "tcp")))      mysqld_port= ntohs((u_short) serv_ptr->s_port); /* purecov: inspected */#endif    if ((env = getenv("MYSQL_TCP_PORT")))       mysqld_port= (uint) atoi(env);    /* purecov: inspected 通过getenv获取启动配置命令行的端口*/  }  if (!mysqld_unix_port)  {#ifdef _WIN32    mysqld_unix_port= (char*) MYSQL_NAMEDPIPE;#else    mysqld_unix_port= (char*) MYSQL_UNIX_ADDR;#endif    if ((env = getenv("MYSQL_UNIX_PORT")))      mysqld_unix_port= env;      /* purecov: inspected */  }}</code></pre><p>创建监听:</p><p>创建 Mysqld_socket_listener 类型对象</p><pre class=" language-lang-c++"><code class="language-lang-c++">Mysqld_socket_listener *mysqld_socket_listener=      new (std::nothrow) Mysqld_socket_listener(bind_addr_str,                                                mysqld_port, back_log,                                                mysqld_port_timeout,                                                unix_sock_name);</code></pre><p>通过Connection_acceptor模板进行Mysqld_socket_listener的初始化，通过循环监控不同类型的client connection event的，也就是通过循环监听客户端来的连接</p><p>创建mysql_socket_acceptor对象：</p><pre class=" language-lang-c++"><code class="language-lang-c++">mysqld_socket_acceptor=      new (std::nothrow) Connection_acceptor<Mysqld_socket_listener>(mysqld_socket_listener);</code></pre><p>初始化listener：</p><pre class=" language-lang-c++"><code class="language-lang-c++"> if (mysqld_socket_acceptor->init_connection_acceptor())      return true; // mysqld_socket_acceptor would be freed in unireg_abort.</code></pre><p>查看Mysqld_socket_listener中的setup_listener()具体的实现：<br>通过以下关键变量来记录listener的主要信息<br><strong>m_tcp_port</strong>:记录tcp socket连接<br><strong>m_unix_sockname</strong>: 使用的是std::string类型记录如果使用socket文件，则文件名（路径+文件）<br>通过使用m_socket_map来区分所使用的连接是tcp_socket还是unix socket的连接方式</p><p>通过两个if判断，分别判断是否tcp还是socket文件连接，并记录于m_socket_map中然后通过迭代器循环实现监听事件的记录，代码通过pool_info_t实现监听相应的事件</p></li><li><p>UDP初始化</p><pre class=" language-lang-C++"><code class="language-lang-C++">udf_init();</code></pre></li><li><p>slave初始化</p></li></ul><pre class=" language-lang-c++"><code class="language-lang-c++">if (server_id != 0)      init_slave(); /* Ignoring errors while configuring replication. */</code></pre><h2 id="2-12-初始化线程"><a href="#2-12-初始化线程" class="headerlink" title="2.12 初始化线程"></a>2.12 初始化线程</h2><pre class=" language-lang-C++"><code class="language-lang-C++">#ifdef _WIN32  create_shutdown_thread();#endif  start_handle_manager();  create_compress_gtid_table_thread();  sql_print_information(ER_DEFAULT(ER_STARTUP),                        my_progname,                        server_version,#ifdef HAVE_SYS_UN_H                        (opt_bootstrap ? (char*) "" : mysqld_unix_port),#else                        (char*) "",#endif                         mysqld_port,                         MYSQL_COMPILATION_COMMENT);#if defined(_WIN32)  Service.SetRunning();#endifstart_processing_signals();</code></pre><h2 id="2-13循环监听客户端"><a href="#2-13循环监听客户端" class="headerlink" title="2.13循环监听客户端"></a>2.13循环监听客户端</h2><p><strong>此处循环监听客户端,直到客户端选择退出再进行后续的操作,所以此函数一般情况是SQL的耗时最多,执行代码最多的地方,也是mysql的核心算法的代码</strong></p><p>此时要分为两种系统讨论:windows和Linux</p><pre class=" language-lang-c++"><code class="language-lang-c++">#if defined(_WIN32)  setup_conn_event_handler_threads();#else  mysql_mutex_lock(&LOCK_socket_listener_active);  // Make it possible for the signal handler to kill the listener.  socket_listener_active= true;  mysql_mutex_unlock(&LOCK_socket_listener_active);  if (opt_daemonize)    mysqld::runtime::signal_parent(pipe_write_fd,1);  mysqld_socket_acceptor->connection_event_loop();#endif /* _WIN32 */</code></pre><h3 id="2-13-1-linux系统"><a href="#2-13-1-linux系统" class="headerlink" title="2.13.1 linux系统"></a>2.13.1 linux系统</h3><pre class=" language-lang-c++"><code class="language-lang-c++">  mysql_mutex_lock(&LOCK_socket_listener_active);  // Make it possible for the signal handler to kill the listener.  socket_listener_active= true;  //从这里开始，服务器启动线程一直等待，直到shutdown后，继续向下执行  mysql_mutex_unlock(&LOCK_socket_listener_active);  if (opt_daemonize)    mysqld::runtime::signal_parent(pipe_write_fd,1);  mysqld_socket_acceptor->connection_event_loop();</code></pre><p>通过nysqld_socket_acceptor变量引用connect_event_loop()方法，循环监听客户端来的连接。通过模板调用如下 ：</p><pre class=" language-lang-c++"><code class="language-lang-c++">/**    Connection acceptor loop to accept connections from clients.  */  void connection_event_loop()  {    Connection_handler_manager *mgr= Connection_handler_manager::get_instance();    while (!abort_loop)    {      Channel_info *channel_info= m_listener->listen_for_connection_event();      if (channel_info != NULL)        mgr->process_new_connection(channel_info);    }  }</code></pre><p>通过查看Mysqld_socket_listener类中listen_for_connection_event()来得到Channel_info信息，然后通过process_new_connection创建新的连接来。再进一步查看Connection_handler_manager的process_new_connection的方法，发现有m_connection_handler-&gt;add_connection(channel_info)在connection_handler中增加一个connection,并记录数量增加:</p><pre class=" language-lang-c++"><code class="language-lang-c++">void Connection_handler_manager::process_new_connection(Channel_info* channel_info){  if (abort_loop || !check_and_incr_conn_count())  {    channel_info->send_error_and_close_channel(ER_CON_COUNT_ERROR, 0, true);    delete channel_info;    return;  }  if (m_connection_handler->add_connection(channel_info)) //增加一个connection  {    inc_aborted_connects(); //记录数量增加    delete channel_info;  }}</code></pre><p>对于m_connection_handler的add_connection增加connection，看具体的实现：</p><pre class=" language-lang-c++"><code class="language-lang-c++">bool Per_thread_connection_handler::add_connection(Channel_info* channel_info){  int error= 0;  my_thread_handle id;  DBUG_ENTER("Per_thread_connection_handler::add_connection");  // Simulate thread creation for test case before we check thread cache  DBUG_EXECUTE_IF("fail_thread_create", error= 1; goto handle_error;);  if (!check_idle_thread_and_enqueue_connection(channel_info))    DBUG_RETURN(false);  /*    There are no idle threads avaliable to take up the new    connection. Create a new thread to handle the connection  */  channel_info->set_prior_thr_create_utime();  error= mysql_thread_create(key_thread_one_connection, &id,                             &connection_attrib,                             handle_connection,                             (void*) channel_info);//给定信息，创建thread进程#ifndef DBUG_OFFhandle_error:#endif // !DBUG_OFF  if (error)  {    connection_errors_internal++;    if (!create_thd_err_log_throttle.log())      sql_print_error("Can't create thread to handle new connection(errno= %d)",                      error);    channel_info->send_error_and_close_channel(ER_CANT_CREATE_THREAD,                                               error, true);    Connection_handler_manager::dec_connection_count();    DBUG_RETURN(true);  }  Global_THD_manager::get_instance()->inc_thread_created();  DBUG_PRINT("info",("Thread created"));  DBUG_RETURN(false);}</code></pre><p>创建mysql_thread_create创建thread，并接收一个方法参数 handle_connection，这个是一个函数:</p><pre class=" language-lang-c++"><code class="language-lang-c++">extern "C" void *handle_connection(void *arg){//... THD *thd= init_new_thd(channel_info); //创建线程对象 //...mysql_thread_set_psi_id(thd->thread_id()); //初始化线程信息等    mysql_thread_set_psi_THD(thd);    mysql_socket_set_thread_owner(      thd->get_protocol_classic()->get_vio()->mysql_socket);    thd_manager->add_thd(thd);//向线程管理器增加一个线程信息    if (thd_prepare_connection(thd))      handler_manager->inc_aborted_connects();    else    {      while (thd_connection_alive(thd))//循环检测线程状态      {        if (do_command(thd)) // 执行相关参数命令          break;      }      end_connection(thd);    }    close_connection(thd, 0, false, false);    thd->get_stmt_da()->reset_diagnostics_area();    thd->release_resources();//...}</code></pre><blockquote><p><a href="https://www.itread01.com/content/1546137727.html" target="_blank" rel="noopener">https://www.itread01.com/content/1546137727.html</a></p></blockquote><p>在handle_connection中,通过while回圈呼叫sql_parse.cc中的do_command()，回圈的作用是从使用者输入的多个命令中依次选择一个命令去执行.在do_command()中，呼叫Protocol_classic::get_command()，进入Protocol_classic::parse_packet()读取一个数据包，解析为command命令,command命令有COM_QUERY、 COM_FIELD_LIST、COM_STMT_EXECUTE等。在在do_command()中继续呼叫sql_parse()档案中的dispatch_command().在dispatch_command()中包含了各种型别的command怎么处理的switch case。比如select的进入case COM_QUERY.先alloc_query()复制执行绪执行绪过来的查询命令。再进入sql_parse.cc档案中的mysql_parse()方法,开始sql语法解析.</p><p><strong>sql语法解析阶段</strong>:</p><ul><li>在mysql_parse()中,主要完成三个工作。检查查询快取里是否有以前执行过的某个查询。呼叫词法解析器(通过parse_sql()方法)，呼叫查询优化器(通过mysql_execute_command()方法).</li><li>依次进入sql_parse.cc中的parse_sql(),进入sql_class.cc中的THD::sql_parser() ,进入MYSQLparse().MYSQLparse是个巨集定义,为#define yyparse MYSQLparse.这时进入yacc的sql_yacc.cc档案中的语法解析器函式yyparse()开始语法解析.解析器基于sql_yacc.yy档案通过yacc生成.Mysql的词法解析器没有用flex,自己编写的。语法解析器用的Bison.</li><li>在mysql_parse()中继续呼叫sql_parse()档案中的mysql_execute_command()方法,为sql优化做准备.在该方法中,通过switch case为各种sql命令优化做准备.如果是select查询，进入case SQLCOM_SELECT，进入Sql_cmd_dml::execute()方法.在execute()方法中,先呼叫precheck()查询是否有许可权，然后呼叫open_tables_for_query()开启要查询的表，然后呼叫lock_tables()锁定相关的表，然后呼叫Sql_cmd_dml::execute_inner(),进入真正的查询优化.</li></ul><p><strong>sql查询优化阶段</strong>:</p><ul><li>在Sql_cmd_dml::execute_inner()方法中，先进入sql_optimizer.cc档案中的JOIN::optimize(),再进入sql_executor.cc档案中的JOIN::exec()开始查询执行器。</li></ul><p><strong>sql查询执行器</strong>:</p><ul><li>在sql_executor.cc档案中的JOIN::exec()中.先呼叫send_result_set_metadata()生成查询标题，再进入sql_executor.cc中的do_select()生成查询结果.在do_select()中呼叫sub_select ().在sub_select()中，先判断是否是最后一条记录.然后while回圈每次读取一条记录。</li></ul><p><strong>sql查询优化阶段</strong>:</p><ul><li>在Sql_cmd_dml::execute_inner()方法中，先进入sql_optimizer.cc档案中的JOIN::optimize(),再进入sql_executor.cc档案中的JOIN::exec()开始查询执行器。</li></ul><p><strong>sql查询执行器</strong>:</p><ul><li>在sql_executor.cc档案中的JOIN::exec()中.先呼叫send_result_set_metadata()生成查询标题，再进入sql_executor.cc中的do_select()生成查询结果.在do_select()中呼叫sub_select ().在sub_select()中，先判断是否是最后一条记录.然后while回圈每次读取一条记录。</li></ul><h3 id="2-13-2-windows系统"><a href="#2-13-2-windows系统" class="headerlink" title="2.13.2 windows系统"></a>2.13.2 windows系统</h3><p>调用函数<code>setup_conn_event_handler_threads();</code>,此时创建监听线程,启动三个单独线程处理不同的连接方式，即Mysqld_socket_listener/Named_pipe_listener/Shared_mem_listener,函数执行了的操作如下:</p><pre class=" language-lang-c++"><code class="language-lang-c++">void setup_conn_event_handler_threads(){  my_thread_handle hThread;  //...  //互斥锁  mysql_mutex_lock(&LOCK_handler_count);  handler_count=0;  //类似于上面Linux的`对于m_connection_handler的add_connection增加connection`  if (opt_enable_named_pipe)  {    int error= mysql_thread_create(key_thread_handle_con_namedpipes,                                   &hThread, &connection_attrib,                                   named_pipe_conn_event_handler,                                   named_pipe_acceptor);    if (!error)      handler_count++;    else      sql_print_warning("Can't create thread to handle named pipes"                        " (errno= %d)", error);  }  if (have_tcpip && !opt_disable_networking)  {    int error= mysql_thread_create(key_thread_handle_con_sockets,                                   &hThread, &connection_attrib,                                   socket_conn_event_handler,                                   mysqld_socket_acceptor);    if (!error)      handler_count++;    else      sql_print_warning("Can't create thread to handle TCP/IP (errno= %d)",                        error);  }  if (opt_enable_shared_memory)  {    int error= mysql_thread_create(key_thread_handle_con_sharedmem,                                   &hThread, &connection_attrib,                                   shared_mem_conn_event_handler,                                   shared_mem_acceptor);    if (!error)      handler_count++;    else      sql_print_warning("Can't create thread to handle shared memory"                        " (errno= %d)", error);  }  // Block until all connection listener threads have exited.  while (handler_count > 0)    mysql_cond_wait(&COND_handler_count, &LOCK_handler_count);  mysql_mutex_unlock(&LOCK_handler_count);  DBUG_VOID_RETURN;}</code></pre><p>拿第一个<code>opt_enable_named_pipe</code>为例,调用了’死’循环函数<code>named_pipe_conn_event_handler</code>:</p><pre class=" language-lang-c++"><code class="language-lang-c++">extern "C" void *named_pipe_conn_event_handler(void *arg){  my_thread_init();  Connection_acceptor<Named_pipe_listener> *conn_acceptor=    static_cast<Connection_acceptor<Named_pipe_listener>*>(arg);  conn_acceptor->connection_event_loop();  decrement_handler_count();  my_thread_end();  return 0;}</code></pre><p>和Linux分析一样,<code>conn_acceptor-&gt;connection_event_loop();</code>进行’通过nysqld_socket_acceptor变量引用connect_event_loop()方法，循环监听客户端来的连接’,接着就回到了Linux的分析</p><h2 id="2-14-后续的结束收尾工作"><a href="#2-14-后续的结束收尾工作" class="headerlink" title="2.14 后续的结束收尾工作"></a>2.14 后续的结束收尾工作</h2><p>略</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>本次源码的分析主要是针对main函数的分析,初步了解了main函数的工作流程,后续将会主要针对Innodb引擎进行分析</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql5.7+vs安装源码调试环境</title>
      <link href="/2020/07/03/mysql5-7-vs-an-zhuang-yuan-ma-diao-shi-huan-jing/"/>
      <url>/2020/07/03/mysql5-7-vs-an-zhuang-yuan-ma-diao-shi-huan-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="1-源码以及软件下载"><a href="#1-源码以及软件下载" class="headerlink" title="1. 源码以及软件下载"></a>1. 源码以及软件下载</h1><ol><li>Visual Code community 2019</li><li>MySQL源码5.7.19</li><li>与MySQL5.7.19配套的boost_1_59_0-msvc-14.0-64</li><li>ActivePerl-5.28</li><li>cmake-3.18.0</li></ol><h1 id="2-源码的编译"><a href="#2-源码的编译" class="headerlink" title="2. 源码的编译"></a>2. 源码的编译</h1><p><img src="image-20200626142031305.png" alt="源码的编译"></p><h1 id="3-VS编译遇到的报错问题"><a href="#3-VS编译遇到的报错问题" class="headerlink" title="3. VS编译遇到的报错问题"></a>3. VS编译遇到的报错问题</h1><h2 id="3-1-Call-Stack-most-recent-call-first-cmake-boost-cmake-238-COULD-NOT-FIND-BOOST-CMakeList"><a href="#3-1-Call-Stack-most-recent-call-first-cmake-boost-cmake-238-COULD-NOT-FIND-BOOST-CMakeList" class="headerlink" title="3.1 Call Stack (most recent call first): cmake/boost.cmake:238 (COULD_NOT_FIND_BOOST) CMakeList"></a>3.1 Call Stack (most recent call first): cmake/boost.cmake:238 (COULD_NOT_FIND_BOOST) CMakeList</h2><p>boost的版本不对,改为boost_1_59_0就成功编译</p><h2 id="3-2-“对COM-组件的调用返回了错误-HRESULT-E-FAIL”无法加载项目"><a href="#3-2-“对COM-组件的调用返回了错误-HRESULT-E-FAIL”无法加载项目" class="headerlink" title="3.2 “对COM 组件的调用返回了错误 HRESULT E_FAIL”无法加载项目"></a>3.2 “对COM 组件的调用返回了错误 HRESULT E_FAIL”无法加载项目</h2><ol><li><p><img src="20200607002041265.png" alt="1"></p></li><li><p><img src="20200607002123675.png" alt="2"></p></li><li><p><img src="20200607002217417.png" alt="3"></p></li></ol><h2 id="3-3-“该文件包含不能在当前代码页-936-中表示的字符。请将该文件保存为-Unicode-格式以防止数据丢失”"><a href="#3-3-“该文件包含不能在当前代码页-936-中表示的字符。请将该文件保存为-Unicode-格式以防止数据丢失”" class="headerlink" title="3.3 “该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失”"></a>3.3 “该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失”</h2><p><a href="https://www.cnblogs.com/leokale-zz/p/11423953.html" target="_blank" rel="noopener">https://www.cnblogs.com/leokale-zz/p/11423953.html</a></p><h2 id="3-4-运行报错"><a href="#3-4-运行报错" class="headerlink" title="3.4 运行报错"></a>3.4 运行报错</h2><p>mysql.cc 文件中函数test_lc_time_sz 最后的DBUG_ASSERT(0); 需要改成DBUG_ASSERT(1);</p><h2 id="3-5-编译成功后运行：mysqld-Could-not-create-or-access-the-registry-key-needed-for-the-MySQL-app"><a href="#3-5-编译成功后运行：mysqld-Could-not-create-or-access-the-registry-key-needed-for-the-MySQL-app" class="headerlink" title="3.5 编译成功后运行：mysqld: Could not create or access the registry key needed for the MySQL app"></a>3.5 编译成功后运行：mysqld: Could not create or access the registry key needed for the MySQL app</h2><p>以管理员方式进行运行程序</p><p><a href="https://blog.csdn.net/zeqi1991/article/details/96195127" target="_blank" rel="noopener">https://blog.csdn.net/zeqi1991/article/details/96195127</a></p><h2 id="3-6-运行报错Table-‘mysql-plugin’-doesn’t-exist"><a href="#3-6-运行报错Table-‘mysql-plugin’-doesn’t-exist" class="headerlink" title="3.6 运行报错Table ‘mysql.plugin’ doesn’t exist"></a>3.6 运行报错Table ‘mysql.plugin’ doesn’t exist</h2><ol><li><p>删除data的文件夹内的所有的内容</p></li><li><p>sql \Debug \ .\mysqld —initialize</p><p><img src="image-20200627012830324.png" alt="sql \Debug \ .\mysqld --initialize"></p></li></ol><h1 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h1><p><img src="image-20200626150116025.png" alt="结果"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manim学习--camera类(一)</title>
      <link href="/2020/07/02/manim-xue-xi-camera-lei/"/>
      <url>/2020/07/02/manim-xue-xi-camera-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-camera的所有子类以及相关的类"><a href="#1-camera的所有子类以及相关的类" class="headerlink" title="1. camera的所有子类以及相关的类"></a>1. camera的所有子类以及相关的类</h2><p><img src="Camera.png" alt="Camera"></p><h2 id="2-camera主要的变量与属性"><a href="#2-camera主要的变量与属性" class="headerlink" title="2. camera主要的变量与属性"></a>2. camera主要的变量与属性</h2><h3 id="2-1-CONFIG"><a href="#2-1-CONFIG" class="headerlink" title="2.1 CONFIG"></a>2.1 CONFIG</h3><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "background_image": None,        "pixel_height": DEFAULT_PIXEL_HEIGHT,        "pixel_width": DEFAULT_PIXEL_WIDTH,        "frame_rate": DEFAULT_FRAME_RATE,        # Note: 帧的高度和宽度将被调整大小以匹配像素长宽比        #         这个在constant.py中可以看到：        #         FRAME_WIDTH = FRAME_HEIGHT * DEFAULT_PIXEL_WIDTH / DEFAULT_PIXEL_HEIGHT        "frame_height": FRAME_HEIGHT,        "frame_width": FRAME_WIDTH,        "frame_center": ORIGIN,        "background_color": BLACK,        "background_opacity": 1,        # vectorized mobjects的点在大于下面的范围时候会缩小        "max_allowable_norm": FRAME_WIDTH,        # 图像的模式，此处默认是RGBA，参见数字图像处理        "image_mode": "RGBA",        # 图像通道，参见数字图像处理        "n_channels": 4,        "pixel_array_dtype": 'uint8',        # z_buff_func is only used if the flag above is set to True.        # 比较时将z坐标舍入到最接近的百分之一        "z_buff_func": lambda m: np.round(m.get_center()[2], 2),        "cairo_line_width_multiple": 0.01,    }</code></pre><h3 id="2-2-init-函数"><a href="#2-2-init-函数" class="headerlink" title="2.2__init__()函数"></a>2.2<code>__init__()</code>函数</h3><ul><li><p><code>rgb_max_val</code>RGB色彩的取值的最大值，默认的<code>uint8</code>取值最大值是255</p></li><li><p><code>pixel_array_to_cairo_context</code>将像素变成cairo能处理的形式</p></li></ul><h2 id="3-camera的主要方法"><a href="#3-camera的主要方法" class="headerlink" title="3. camera的主要方法"></a>3. camera的主要方法</h2><ol><li><p><code>reset_pixel_shape(new_height, new_width)</code>设置帧的像素宽与高</p><pre class=" language-lang-python"><code class="language-lang-python">class Test_pixel(ThreeDScene):    def construct(self):        axes = ThreeDAxes()        cube = Cube(fill_color=GREEN).scale([2, 0.5, 0.5])        theta_0 = 0 # 起始角度        theta =  -120 * DEGREES # 目标角度        self.set_camera(ThreeDCamera(background_color=BLUE))        self.camera.reset_pixel_shape(854,854)        self.set_camera_orientation(60 * DEGREES, theta=theta_0)        self.add(axes, cube)        self.wait()        dt = 1/15        delta_theta = (theta - theta_0) / 60        for i in range(60):            theta_0 += delta_theta            self.set_camera_orientation(theta=theta_0)            self.wait(dt)        self.wait(2)</code></pre><p>上面代码设置宽高为854*854，最后就会产生大小为854*854的视频：</p><p><img src="Test_pixel.gif" alt="Test_pixel"></p></li><li><p>一些get,set函数：</p><pre class=" language-lang-python"><code class="language-lang-python">    def get_pixel_height(self):        return self.pixel_height    def get_pixel_width(self):        return self.pixel_width    def get_frame_height(self):        return self.frame_height    def get_frame_width(self):        return self.frame_width    def get_frame_center(self):        return self.frame_center    def set_frame_height(self, frame_height):        self.frame_height = frame_height    def set_frame_width(self, frame_width):        self.frame_width = frame_width    def set_frame_center(self, frame_center):        self.frame_center = frame_center</code></pre><p>frame和pixel的区别是：一个是将帧分为多少格，一个是将帧的大小设置为多少，前者仅仅会改变坐标的间隔，后者会改变视频的宽高</p><p>原始的默认为frame_width=14，frame_height=8：</p><pre class=" language-lang-python"><code class="language-lang-python">class Set_frame1(Scene):    def construct(self):        numberplane = NumberPlane()        numberplane.add_coordinates()        text = Text("frame_width=14\nframe_height=8").shift(LEFT*5+UP*3)        self.add(numberplane,text)        self.wait(2)</code></pre><p><img src="set_frame14.png" alt="set_frame14"></p><p>重新设置frame_width:</p><pre class=" language-lang-python"><code class="language-lang-python">class Set_frame1(Scene):    def construct(self):        numberplane = NumberPlane()        numberplane.add_coordinates()        self.camera.set_frame_width(8)        text = Text("frame_width=8\nframe_height=8").shift(UP*3)        self.add(numberplane,text)        self.wait(2)</code></pre><p>可以看到宽也被拉长了：</p><p><img src="set_frame8.png" alt="set_frame8"></p></li><li><p><code>resize_frame_shape(fixed_dimension=0)</code>:</p><p>更改frame_shape以匹配像素的长宽比，其中fixed_dimension确定frame_height或frame_width是否保持固定，而其他值则相应改变。</p><pre class=" language-lang-python"><code class="language-lang-python">class Set_frame1(Scene):    def construct(self):        numberplane = NumberPlane()        numberplane.add_coordinates()        self.camera.set_frame_width(8)        self.camera.resize_frame_shape()        text = Text("frame_width=8")        self.add(numberplane,text)        self.wait(2)</code></pre><p><img src="resize_frame_shape.png" alt="resize_frame_shape"></p></li><li><p><code>get_image(pixel_array=None)</code></p><p>返回<code>pixel_array</code>对应的Image类型的对象，如果<code>pixel_array</code>为空,则返回自身的<code>pixel_array</code>对应的Image图像,此函数一般不用</p></li><li><p><code>get_pixel_array()</code></p><p>返回自身的<code>pixel_array</code></p></li><li><p><code>convert_pixel_array(pixel_array, convert_from_floats=False)</code></p><p>将格式为<code>PIL</code> 的<code>pixel_array</code>图片转换为<code>np.array</code>的格式</p><p>其中<code>pixel_array</code>的形式可能有两种,第一种是RGB的格式进行表示,第二种是被归一化到[0,1]的小数形式,此时需要启用<code>convert_from_floats=True</code></p></li><li><p><code>set_pixel_array(pixel_array, convert_from_floats=False)</code></p><p>设置camera的<code>pixel_array</code>为参数中的pixel_array,对应的选项同理于`convert_pixel_array</p></li><li><p><code>set_background(pixel_array, convert_from_floats=False)</code></p><p>设置背景(本人没有成功尝试出来换背景图片不知道出了什么问题,代码如下)</p><pre class=" language-lang-python"><code class="language-lang-python">class Set_background(Scene):    def construct(self):        image = Image.open(r"XXX.png")        self.camera.set_background(image)        # self.camera.init_background()        numberplane = NumberPlane()        numberplane.add_coordinates()        self.add(numberplane)        self.wait(2)</code></pre><p>上面就是随便加了个物体,不知道为什么出现这个问题</p></li><li><p><code>make_background_from_func(coords_to_colors_func)</code></p><p>另一个函数是<code>set_background_from_func(coords_to_colors_func)</code>功能一样</p><p>使用coords_to_colors_func设置背景以确定每个像素的颜色。 coords_to_colors_func的每个输入在空间中都是（x，y）对（在frame对应的普通空间坐标,不是像素坐标），并且每个输出应为4个浮点数的RGBA数组。</p><pre class=" language-lang-python"><code class="language-lang-python">def coords_to_colors_func(point):    return (int)(255*(point[0]+7)/17),(int)(255*(point[1]+4)/8),(int)(255*(point[0]+11)/22),1class Set_bacground_func(Scene):    def construct(self):        self.camera.set_background_from_func(coords_to_colors_func)        square = Square()        self.add(square)        self.wait(2)</code></pre><p><img src="set_background_func.jpg" alt="set_background_func"></p></li><li><p><code>reset()</code></p><p>重设背景</p></li><li><p><code>get_mobjects_to_display()</code></p><p>得到要展示的mobject</p></li><li><p><code>is_in_frame(mobject)</code></p><p>判断mobject是否在frame里面</p></li><li><p><code>points_to_pixel_coords(mobject, points)</code></p><p>将普通坐标,转换为像素坐标</p></li></ol><p>其他的函数本人也没有很理解,而且涉及到cairo库的学习,个人觉得没有必要深入了解其他的函数,因为有的函数3b1b仅仅是用来子类实现或者根本没有用过,如果需要请自行阅读源码</p><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>本次学习camera很多函数偏于底层,我们平时绘制的时候应该用不上,camera的很多关于背景(background)的函数感觉很多都难以使用或者有各种bug(不知道是不是我自己不会用的原因),如果有人发现错误欢迎评论留言<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> manim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> manim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex入门</title>
      <link href="/2020/07/01/latex-ru-men/"/>
      <url>/2020/07/01/latex-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Latex框架和总体设置"><a href="#1-Latex框架和总体设置" class="headerlink" title="1. Latex框架和总体设置"></a>1. Latex框架和总体设置</h1><h2 id="1-1-框架"><a href="#1-1-框架" class="headerlink" title="1.1 框架"></a>1.1 框架</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\documentclass[UTF8,a4paper,12pt]{ctexart}\title{LaTeX入门教程}\date{} %不显示时间\begin{document}  \maketitle  中文内容\end{document}</code></pre><h1 id="1-2-标题-section"><a href="#1-2-标题-section" class="headerlink" title="1.2 标题 section"></a>1.2 标题 section</h1><h3 id="1-2-1-一级标题"><a href="#1-2-1-一级标题" class="headerlink" title="1.2.1 一级标题"></a>1.2.1 一级标题</h3><pre class=" language-lang-latex"><code class="language-lang-latex">\section{一级标题}  % 有序号\section*{一级标题} % 无序号</code></pre><h3 id="1-2-2-二级标题"><a href="#1-2-2-二级标题" class="headerlink" title="1.2.2 二级标题"></a>1.2.2 二级标题</h3><pre class=" language-lang-latex"><code class="language-lang-latex">\subsection{二级标题}  % 有序号\subsection*{二级标题} % 无序号</code></pre><h3 id="1-2-3-标题label"><a href="#1-2-3-标题label" class="headerlink" title="1.2.3 标题label"></a>1.2.3 标题label</h3><pre class=" language-lang-latex"><code class="language-lang-latex">\section{System} % 章节标题    \label{sec:system} %标题的标签\ref{sec:conclusions} %在正文中引用这个标题名</code></pre><h2 id="1-3-标题形式"><a href="#1-3-标题形式" class="headerlink" title="1.3 标题形式"></a>1.3 标题形式</h2><pre class=" language-lang-latex"><code class="language-lang-latex">% 章节序号 和 序号字体大小\renewcommand{\thesection}{{\zihao{4} \chinese{section}.}} % 一.\renewcommand{\thesubsection}{{\zihao{-4}\arabic{section}.\arabic{subsection}}} % 1.1\arabic (1, 2, 3, ...)\alph (a, b, c, ...)\Alph (A, B, C, ...)\roman (i, ii, iii, ...)\Roman (I, II, III, ...)\chinese (一，二，三，四，...)</code></pre><h2 id="1-4-字体字号"><a href="#1-4-字体字号" class="headerlink" title="1.4 字体字号"></a>1.4 字体字号</h2><pre class=" language-lang-latex"><code class="language-lang-latex">{\songti 你好} % 宋体{\heiti 你好}  % 黑体\textbf{你好}  % 加粗</code></pre><pre><code>{\zihao{4} 你好} % 四号字体{\zihao{-4} 你好} % 小四号字体</code></pre><h2 id="1-5-行距"><a href="#1-5-行距" class="headerlink" title="1.5 行距"></a>1.5 行距</h2><p>在导言部分</p><pre class=" language-lang-latex"><code class="language-lang-latex">% 行距，单倍行距\usepackage{setspace}\setstretch{1}1：单倍行距1.2：1.5倍行距1.6：2倍行距</code></pre><p>或者</p><pre class=" language-lang-latex"><code class="language-lang-latex">\linespread{1}1：单倍行距1.2：1.5倍行距1.6：2倍行距</code></pre><h2 id="1-6-页眉页脚"><a href="#1-6-页眉页脚" class="headerlink" title="1.6 页眉页脚"></a>1.6 页眉页脚</h2><pre class=" language-lang-latex"><code class="language-lang-latex">% 页眉页脚\usepackage{fancyhdr}\pagestyle{fancy}\fancyhf{}\cfoot{\thepage} % 页脚居中写页码\fancyhead[R]{\textbf{参赛队号 $\#\,6794$}} % 页脚写队名</code></pre><h2 id="1-7-图表公式的编号形式"><a href="#1-7-图表公式的编号形式" class="headerlink" title="1.7 图表公式的编号形式"></a>1.7 图表公式的编号形式</h2><pre class=" language-lang-latex"><code class="language-lang-latex">% 图、表、公式的编号\renewcommand{\thefigure}{\arabic{section}-\arabic{figure}} # 5-1\renewcommand{\thetable}{\arabic{section}-\arabic{table}} # 5-1\renewcommand{\theequation}{\arabic{section}-\arabic{equation}} # 5-1% 单独一个图的引用如图 \ref{Fig:character}所示 % 如图5-1所示% 对多个图中的字图的引用如图 \arabic{section}-\ref{Fig:character:a}所示 % 如图5-1(a)所示</code></pre><h2 id="1-8-字体"><a href="#1-8-字体" class="headerlink" title="1.8 字体"></a>1.8 字体</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\textbf{字体} % 粗体\textit{字体} % 斜体\emph{重点}   % 强调</code></pre><h2 id="1-9-颜色"><a href="#1-9-颜色" class="headerlink" title="1.9 颜色"></a>1.9 颜色</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\definecolor{Red}{RGB}{225,0,0}\definecolor{Green}{RGB}{0,225,0}\definecolor{Blue}{RGB}{0,0,225}\textcolor{Red}{text}\textcolor{Green}{text}\textcolor{Blue}{text}</code></pre><h2 id="1-10-空格"><a href="#1-10-空格" class="headerlink" title="1.10 空格"></a>1.10 空格</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\quad\qquad\,\ (空格)\/</code></pre><h1 id="2-插入图片"><a href="#2-插入图片" class="headerlink" title="2. 插入图片"></a>2. 插入图片</h1><h2 id="2-1-单个图片"><a href="#2-1-单个图片" class="headerlink" title="2.1 单个图片"></a>2.1 单个图片</h2><pre class=" language-lang-latex"><code class="language-lang-latex">% 添加包% figure 1\usepackage{graphicx}\usepackage{float}% 需要添加图片的地方\begin{figure}[H] % 此处需要用到宏包 float\centering % 图片居中\includegraphics[width = 8.3cm]{figures/figure_1.png}\caption{The caption of this figure.}\label{fig:figure1label}\end{figure}% 在中文中需要引用图片的地方如图 \ref{fig:figure1label} 所示</code></pre><h2 id="2-2-两个图片并列"><a href="#2-2-两个图片并列" class="headerlink" title="2.2 两个图片并列"></a>2.2 两个图片并列</h2><h3 id="2-2-1-两个并排图片，单独标题"><a href="#2-2-1-两个并排图片，单独标题" class="headerlink" title="2.2.1 两个并排图片，单独标题"></a>2.2.1 两个并排图片，单独标题</h3><pre class=" language-lang-latex"><code class="language-lang-latex">% 使用的宏包\begin{minipage}[t]{0.5\linewidth}\end{minipage}</code></pre><pre class=" language-lang-latex"><code class="language-lang-latex">\begin{figure}[H]        \begin{minipage}[t]{0.5\linewidth}            \centering            \includegraphics[width=6cm]{figures/butterfly.jpg}            \caption{left}            \label{Fig:left}        \end{minipage}        \begin{minipage}[t]{0.5\linewidth}            \centering            \includegraphics[width=6cm]{figures/butterfly.jpg}            \caption{right}            \label{Fig:right}        \end{minipage}    \end{figure}</code></pre><h3 id="2-2-2-两个并排图片，单独小标题，共享大标题"><a href="#2-2-2-两个并排图片，单独小标题，共享大标题" class="headerlink" title="2.2.2 两个并排图片，单独小标题，共享大标题"></a>2.2.2 两个并排图片，单独小标题，共享大标题</h3><pre class=" language-lang-latex"><code class="language-lang-latex">% 使用宏包\subfigure[小标题]{}</code></pre><pre class=" language-lang-latex"><code class="language-lang-latex">% 添加红包 \usepackage{subfigure}\begin{figure}[H]        \subfigure[left]{        \begin{minipage}[t]{0.5\linewidth}            \centering            \includegraphics[width=6cm]{figures/butterfly.jpg}            \label{Fig:left}        \end{minipage}        }        \subfigure[right]{        \begin{minipage}[t]{0.5\linewidth}            \centering            \includegraphics[width=6cm]{figures/butterfly.jpg}            \label{Fig:right}        \end{minipage}        }        \caption{G1 after first step of algorithm.}\end{figure}</code></pre><h1 id="3-插入表格"><a href="#3-插入表格" class="headerlink" title="3. 插入表格"></a>3. 插入表格</h1><h2 id="3-1-生成表格"><a href="#3-1-生成表格" class="headerlink" title="3.1 生成表格"></a>3.1 生成表格</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\usepackage{booktabs} % 绘制三线表</code></pre><pre class=" language-lang-latex"><code class="language-lang-latex">\begin{table}[htp]    \centering    \caption{常用符号说明}    \begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}ll}%表格两边顶格        \toprule        符号             & 说明 \\        \midrule        $s(x)$           & 径向基函数      \\        $I_1,I_2$        & 不同纹理特征的图像\\        \bottomrule    \end{tabular*}    \label{tab:symbol}\end{table}</code></pre><ul><li>latex表格生成网站:<a href="http://www.tablesgenerator.com/" target="_blank" rel="noopener">http://www.tablesgenerator.com/</a></li><li>excel转latex:<a href="https://tableconvert.com/" target="_blank" rel="noopener">https://tableconvert.com/</a></li></ul><h2 id="3-2-表格引用"><a href="#3-2-表格引用" class="headerlink" title="3.2 表格引用"></a>3.2 表格引用</h2><pre class=" language-lang-latex"><code class="language-lang-latex">如表格 \ref{tab:DH}所示。</code></pre><h1 id="4-数学公式"><a href="#4-数学公式" class="headerlink" title="4. 数学公式"></a>4. 数学公式</h1><h2 id="4-0-包"><a href="#4-0-包" class="headerlink" title="4.0 包"></a>4.0 包</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\usepackage{amsmath}\usepackage{bm} % 数学公式中使用的黑体 \bm{R}</code></pre><h2 id="4-1-单个方程"><a href="#4-1-单个方程" class="headerlink" title="4.1 单个方程"></a>4.1 单个方程</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\begin{equation}y = ax+b\end{equation}</code></pre><script type="math/tex; mode=display">\begin{equation}y = ax+b\end{equation}</script><h2 id="4-2-方程组"><a href="#4-2-方程组" class="headerlink" title="4.2 方程组"></a>4.2 方程组</h2><pre class=" language-lang-latex"><code class="language-lang-latex">% 左大括号\begin{equation}    \begin{cases}    y_1 = a_1x + b_1\\    y_2 = a_2x + b_2    \end{cases}\end{equation}% 两个方程是一组(使用1个编号)，没有左大括号\begin{equation}    \begin{gathered}    y_1 = a_1x + b_1\\    y_2 = a_2x + b_2    \end{gathered}\end{equation}% 两个方程是一组(使用1个编号)，有左大括号\begin{equation}    \left \{        \begin{gathered}            y_1 = a_1x + b_1\\            y_2 = a_2x + b_2        \end{gathered}    \right .\end{equation}</code></pre><script type="math/tex; mode=display">% 左大括号\begin{equation}    \begin{cases}    y_1 = a_1x + b_1\\    y_2 = a_2x + b_2    \end{cases}\end{equation}</script><script type="math/tex; mode=display">% 两个方程是一组(使用1个编号)，没有左大括号\begin{equation}    \begin{gathered}    y_1 = a_1x + b_1\\    y_2 = a_2x + b_2    \end{gathered}\end{equation}</script><script type="math/tex; mode=display">% 两个方程是一组(使用1个编号)，有左大括号\begin{equation}    \left \{        \begin{gathered}            y_1 = a_1x + b_1\\            y_2 = a_2x + b_2        \end{gathered}    \right .\end{equation}</script><h2 id="4-3-拆分单个公式"><a href="#4-3-拆分单个公式" class="headerlink" title="4.3 拆分单个公式"></a>4.3 拆分单个公式</h2><pre class=" language-lang-latex"><code class="language-lang-latex">% 将一个长的公式分两行写\begin{equation}    \begin{split}    y =& a + b + c\\       & + d + e    \end{split}\end{equation}</code></pre><script type="math/tex; mode=display">% 将一个长的公式分两行写\begin{equation}    \begin{split}    y =& a + b + c\\       & + d + e    \end{split}\end{equation}</script><h2 id="4-4-分段函数"><a href="#4-4-分段函数" class="headerlink" title="4.4 分段函数"></a>4.4 分段函数</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\begin{equation}T=    \begin{cases}        0       & a<2\\        1       & a=2\\        3       & a>2    \end{cases}\end{equation}</code></pre><script type="math/tex; mode=display">\begin{equation}T=    \begin{cases}        0       & a<2\\        1       & a=2\\        3       & a>2    \end{cases}\end{equation}</script><h2 id="4-5-矩阵"><a href="#4-5-矩阵" class="headerlink" title="4.5 矩阵"></a>4.5 矩阵</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\begin{equation}    \begin{bmatrix}        a & b\\        c & d    \end{bmatrix}\end{equation}</code></pre><script type="math/tex; mode=display">\begin{equation}    \begin{bmatrix}        a & b\\        c & d    \end{bmatrix}\end{equation}</script><h2 id="4-6-分子分母"><a href="#4-6-分子分母" class="headerlink" title="4.6 分子分母"></a>4.6 分子分母</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\begin{equation}    \frac{a+b}{c+d}\end{equation}</code></pre><script type="math/tex; mode=display">\begin{equation}    \frac{a+b}{c+d}\end{equation}</script><h2 id="4-7-希腊字母"><a href="#4-7-希腊字母" class="headerlink" title="4.7 希腊字母"></a>4.7 希腊字母</h2><pre class=" language-lang-latex"><code class="language-lang-latex">% 小写希腊字母(大写希腊字母时，首字母大写即可)\alpha\beta\gamma\delta\epsilon\eta\theta\lambda\mu\sigma\tau\phi\varphi\chi\psi\omega</code></pre><script type="math/tex; mode=display">% 小写希腊字母(大写希腊字母时，首字母大写即可)\alpha\beta\gamma\delta\epsilon\eta\theta\lambda\mu\sigma\tau\phi\varphi\chi\psi\omega</script><h2 id="4-8-数学算子"><a href="#4-8-数学算子" class="headerlink" title="4.8 数学算子"></a>4.8 数学算子</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\sum     % 求和\prod    % 乘积\partial % 微分\int     % 积分\iint    % 二级积分\iiint   % 三级积分</code></pre><script type="math/tex; mode=display">\sum     \\ % 求和 \prod    \\ % 乘积 \partial \\ % 微分\int     \\ % 积分\iint    \\ % 二级积分\iiint   \\ % 三级积分</script><h1 id="5-一些符号"><a href="#5-一些符号" class="headerlink" title="5. 一些符号"></a>5. 一些符号</h1><h2 id="5-1-度"><a href="#5-1-度" class="headerlink" title="5.1 度"></a>5.1 度</h2><pre class=" language-lang-latex"><code class="language-lang-latex">90^{\circ}</code></pre><script type="math/tex; mode=display">90^{\circ}</script><h2 id="5-2-角"><a href="#5-2-角" class="headerlink" title="5.2 角"></a>5.2 角</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\angle A = 90^{\circ}</code></pre><script type="math/tex; mode=display">\angle A = 90^{\circ}</script><h2 id="5-3-单引号，双引号"><a href="#5-3-单引号，双引号" class="headerlink" title="5.3 单引号，双引号"></a>5.3 单引号，双引号</h2><pre class=" language-lang-latex"><code class="language-lang-latex">'单引号'\\''双引号''</code></pre><script type="math/tex; mode=display">'单引号'\\''双引号''</script><h2 id="5-4-横杠"><a href="#5-4-横杠" class="headerlink" title="5.4 横杠"></a>5.4 横杠</h2><pre class=" language-lang-latex"><code class="language-lang-latex">-   \\ % 连字符--  \\ % 数字范围--- \\ % 破折号</code></pre><h2 id="5-5-下划线"><a href="#5-5-下划线" class="headerlink" title="5.5 下划线"></a>5.5 下划线</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\underline{论文} % 单下划线\uuline{论文}    % 双下划线</code></pre><h1 id="6-列表"><a href="#6-列表" class="headerlink" title="6. 列表"></a>6. 列表</h1><h2 id="6-1-列表"><a href="#6-1-列表" class="headerlink" title="6.1 列表"></a>6.1 列表</h2><pre class=" language-lang-latex"><code class="language-lang-latex">% 列表里面嵌套列表\begin{enumerate}    \item [1.] 大学        \begin{enumerate}            \item [1.1] 大一            \item [1.2] 大二            \item [1.3] 大三            \item [1.4] 大四        \end{enumerate}    \item [2.] 研究生\end{enumerate}</code></pre><h1 id="7-插入代码"><a href="#7-插入代码" class="headerlink" title="7. 插入代码"></a>7. 插入代码</h1><h2 id="7-1-包"><a href="#7-1-包" class="headerlink" title="7.1 包"></a>7.1 包</h2><pre class=" language-lang-latex"><code class="language-lang-latex">\usepackage{listings} % 插入代码的包\usepackage{xcolor} %颜色包\lstset{ %    language=Matlab,                % the language of the code    basicstyle=\zihao{-4},       % the size of the fonts that are used for the code    numbers=left,                   % where to put the line-numbers    numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers    stepnumber=1,                   % the step between two line-numbers. If it is 1, each line will be numbered    numbersep=5pt,                  % how far the line-numbers are from the code    backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}    showspaces=false,               % show spaces adding particular underscores    showstringspaces=false,         % underline spaces within strings    showtabs=false,                 % show tabs within strings adding particular underscores    frame=single,                   % adds a frame around the code    rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))    tabsize=2,                      % sets default tabsize to 2 spaces    captionpos=b,                   % sets the caption-position to bottom    breaklines=true,                % sets automatic line breaking    breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace    title=\lstname,                 % show the filename of files included with \lstinputlisting;    % also try caption instead of title    keywordstyle=\color{blackred},          % keyword style    commentstyle=\color{dkgreen},   % comment style    stringstyle=\color{MidnightBlue},         % string literal style    escapeinside={\%*}{*)},         % if you want to add LaTeX within your code    morekeywords={*,...},           % if you want to add more keywords to the set    escapechar=`,                    % 中文注释    columns=flexible                % 非等款输出}</code></pre><h2 id="7-2-代码"><a href="#7-2-代码" class="headerlink" title="7.2 代码"></a>7.2 代码</h2><pre class=" language-lang-latex"><code class="language-lang-latex">% 先定义颜色\definecolor{dkgreen}{rgb}{0,0.6,0}\definecolor{gray}{rgb}{0.5,0.5,0.5}\definecolor{MidnightBlue}{RGB}{25,25,112}\definecolor{blackred}{RGB}{199,21,133} % 关键字颜色% 代码\begin{lstlisting}[language = Matlab]  function [W, Z, mu, mse] = pcaEm(X, m)  % Perform EM-like algorithm for PCA (by Sam Roweis).  % Input:  %   X: d x n data matrix  %   m: dimension of target space  % Output:  %   W: d x m weight matrix  %   Z: m x n projected data matrix  %   mu: d x 1 mean vector  %   mse: mean square error  % Reference:   %   Pattern Recognition and Machine Learning by Christopher M. Bishop   %   EM algorithms for PCA and SPCA by Sam Roweis   % Written by Mo Chen (sth4nth@gmail.com).  d = size(X,1);  mu = mean(X,2);  X = bsxfun(@minus,X,mu);  W = rand(d,m);   tol = 1e-6;  mse = inf;  maxIter = 200;  for iter = 1:maxIter      Z = (W'*W)\(W'*X);             % 12.58      W = (X*Z')/(Z*Z');              % 12.59  %...\end{lstlisting}</code></pre><h1 id="8-文献引用"><a href="#8-文献引用" class="headerlink" title="8. 文献引用"></a>8. 文献引用</h1><h2 id="8-1-文献的下载"><a href="#8-1-文献的下载" class="headerlink" title="8.1 文献的下载"></a>8.1 文献的下载</h2><p>谷歌学术上下载文献后,点击如下图标:</p><p><img src="image-20200111205436290.png" alt="谷歌学术上下载文献"></p><p>得到如下文本:</p><pre class=" language-lang-tex"><code class="language-lang-tex">@article{李德毅2004不确定性人工智能,  title={不确定性人工智能},  author={李德毅 and 刘常昱 and 杜鹢 and 韩旭},  journal={软件学报},  volume={15},  number={11},  year={2004}}</code></pre><p>复制到剪切板,打开zotero,文件=&gt;从剪切板导入:</p><p><img src="image-20200111205718228.png" alt="剪切板导入文本"></p><p>右键该条目,添加附件=&gt;附加文件副本,可以将文件添加入内:</p><p><img src="image-20200111205910856.png" alt="添加文件副本"></p><p>当有多条的时候,将需要的选中,然后右键导出条目.可以将所有选中条目导出为bibtex(.bib)文件:</p><p><img src="image-20200111210233332.png" alt="导出为bibtex"></p><h2 id="8-2-bibtex文件的使用"><a href="#8-2-bibtex文件的使用" class="headerlink" title="8.2 bibtex文件的使用"></a>8.2 bibtex文件的使用</h2><p>latex文件使用cite包:</p><pre class=" language-lang-latex"><code class="language-lang-latex">\usepackage{cite}</code></pre><p>文档的结尾使用这两句话:</p><pre class=" language-lang-latex"><code class="language-lang-latex">\bibliographystyle{plain}\bibliography{ref}</code></pre><p>其中ref是bibtex文件的名字(此代码处为ref.bib)</p><p>当上面的文章需要使用bibtex中的文件,使用:</p><pre class=" language-lang-latex"><code class="language-lang-latex">\cite{__2004}</code></pre><p>其中”__2004”是你要引用的条目的第一句话,例如本ref.bib文件如下:</p><pre class=" language-lang-latex"><code class="language-lang-latex">@article{__2004,    title = {不确定性人工智能},    volume = {15},    number = {11},    journal = {软件学报},    author = {{李德毅} and {刘常昱} and {杜鹢} and {韩旭}},    year = {2004},    file = {李德毅 等。 - 2004 - 不确定性人工智能.pdf:C\:\\Users\\25648\\Zotero\\storage\\TV4IWQII\\李德毅 等。 - 2004 - 不确定性人工智能.pdf:application/pdf}}@article{__2012,    title = {人工智能及其发展应用},    volume = {12},    number = {2},    journal = {信息网络安全},    author = {{邹蕾} and {张先锋}},    year = {2012},    pages = {0--0},    file = {邹蕾 和 张先锋 - 2012 - 人工智能及其发展应用.pdf:C\:\\Users\\25648\\Zotero\\storage\\3U4NZ6YF\\邹蕾 和 张先锋 - 2012 - 人工智能及其发展应用.pdf:application/pdf}}</code></pre><p>所以”__2004”显示后就是如下效果:</p><p>代码部分:</p><pre class=" language-lang-latex"><code class="language-lang-latex">李德毅的文章\cite{__2004}\bibliographystyle{plain}\bibliography{ref}</code></pre><p>效果:</p><p><img src="image-20200111211644798.png" alt="效果"></p><p>注意,在没有前文引用的情况下,文献是不会显示的,如上面的&lt;&lt;人工智能及其发展应用&gt;&gt;没有被引用所以没有对应的条目.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> latex </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python笔记</title>
      <link href="/2020/04/25/python-bi-ji/"/>
      <url>/2020/04/25/python-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="函数参数中含有列表的问题"><a href="#函数参数中含有列表的问题" class="headerlink" title="函数参数中含有列表的问题"></a>函数参数中含有列表的问题</h2><p><strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888</a></p></blockquote><p>有如下函数</p><pre class=" language-lang-python"><code class="language-lang-python">def add_end(L=[]):    L.append('END')    return L</code></pre><p>正常使用没问题,但是如果如下操作:</p><pre class=" language-lang-bash"><code class="language-lang-bash">>>> add_end()['END', 'END']>>> add_end()['END', 'END', 'END']</code></pre><p>则会出现令人费解的问题,原因如下:</p><p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p><p>为了避免这个问题,可以用<code>None</code>这个不变对象来实现:</p><pre class=" language-lang-python"><code class="language-lang-python">def add_end(L=None):    if L is None:        L = []    L.append('END')    return L</code></pre><h2 id="可变参数与列表的结合-与-的使用"><a href="#可变参数与列表的结合-与-的使用" class="headerlink" title="可变参数与列表的结合:*与**的使用"></a>可变参数与列表的结合:*与**的使用</h2><p>如果python代码看的比较多的时候,就会发现有类似如下的写法:</p><pre class=" language-lang-python"><code class="language-lang-python">def function(*args,**kwargs):    ...</code></pre><p>*args 用来将参数打包成tuple给函数体调用, **kwargs 打包关键字参数成dict给函数体调用</p><p>如果某函数如下:</p><pre class=" language-lang-python"><code class="language-lang-python">def function(arg1,arg2,*args,**kwargs):    print(arg1,arg2,args,kwargs)</code></pre><p>调用如下:</p><pre class=" language-lang-bash"><code class="language-lang-bash">>>> funtion(1,2,3,4,5,6,7,a=1,b=2,c=3)1 2 (3, 4, 5, 6, 7) {'a': 1, 'b': 2, 'c': 3}</code></pre><p>可以看到对应的结果</p><p>如果想传入现成的列表和字典的时候可以使用*和**进行输入:</p><pre class=" language-lang-python"><code class="language-lang-python">>>> lst = [1,2,3,4]>>> dict={"a":1,"b":2,"c":3}>>> function(1,2,*lst,**dict)1 2 (1, 2, 3, 4) {'a': 1, 'b': 2, 'c': 3}</code></pre><p>甚至对于普通的函数也可以用**进行输入参数:</p><pre class=" language-lang-python"><code class="language-lang-python">def func(name,age):    print(name,age)>>>dicts = {"name":"cc","age":11}>>>func(**dicts)>>>cc 11</code></pre><blockquote><p>下段代码来源:<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888</a></p></blockquote><p>当需要限定关键字,可以使用*作为分隔符，*后面的参数被视为命名关键字参数</p><pre class=" language-lang-python"><code class="language-lang-python">def person(name, age, *, city, job):    print(name, age, city, job)>>> person('Jack', 24, city='Beijing', job='Engineer')Jack 24 Beijing Engineer</code></pre><h2 id="列表的等间隔切片"><a href="#列表的等间隔切片" class="headerlink" title="列表的等间隔切片"></a>列表的等间隔切片</h2><p>给个例子就很明确了:</p><pre class=" language-lang-python"><code class="language-lang-python">>>>lst = [1,2,3,4,5]>>>lst[1:4:2][2,4]</code></pre><h2 id="生成器generator与yield结合的用法"><a href="#生成器generator与yield结合的用法" class="headerlink" title="生成器generator与yield结合的用法"></a>生成器generator与yield结合的用法</h2><p>详见<a href="https://blog.csdn.net/mieleizhi0522/article/details/82142856/" target="_blank" rel="noopener">https://blog.csdn.net/mieleizhi0522/article/details/82142856/</a></p><h2 id="map和reduce"><a href="#map和reduce" class="headerlink" title="map和reduce"></a>map和reduce</h2><p>map就是映射函数于列表,非常方便产生列表,例子如下:</p><pre class=" language-lang-python"><code class="language-lang-python">>>> def f(x):...     return x * x...>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])>>> list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre><p>reduce函数用一个例子表述,功能是不用<code>int()</code>进行字符串转整型数:</p><pre class=" language-lang-python"><code class="language-lang-python">from functools import reduceDIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}def char2num(s):    return DIGITS[s]def str2int(s):    return reduce(lambda x, y: x * 10 + y, map(char2num, s))</code></pre><h2 id="lambda表达式和列表生成式产生的奇妙反应"><a href="#lambda表达式和列表生成式产生的奇妙反应" class="headerlink" title="lambda表达式和列表生成式产生的奇妙反应"></a>lambda表达式和列表生成式产生的奇妙反应</h2><p>先看一段代码:</p><pre class=" language-lang-python"><code class="language-lang-python">def num():    return [lambda x:i*x for i in range(4)]>>>[m(1) for m in num()][3, 3, 3, 3]</code></pre><p>如果你不知道为什么会这样,具体原因见:</p><p><a href="https://blog.csdn.net/CxsGhost/article/details/103697506" target="_blank" rel="noopener">https://blog.csdn.net/CxsGhost/article/details/103697506</a></p><p>个人的解释是:上面的代码可以等价为下列代码:</p><pre class=" language-lang-python"><code class="language-lang-python">def num():    i = 0    lst = []    def fun(x):        return i * x    for j in range(4):        i = j        lst.append(fun)    return lst>>>[m(1) for m in num()]</code></pre><p>因为i是命名空间lambda里面所以外部的i是不会进入内部的,首先产生<code>[lambda x:i*x,lambda x:i*x,lambda x:i*x,lambda x:i*x]</code>,循环完了后,i=3,所以返回<code>[lambda x:3*x,lambda x:3*x,lambda x:3*x,lambda x:3*x]</code></p><h2 id="偏函数的用法"><a href="#偏函数的用法" class="headerlink" title="偏函数的用法"></a>偏函数的用法</h2><p>有的时候,希望某些函数的参数固定,就可以使用如下方法进行固定</p><pre class=" language-lang-python"><code class="language-lang-python">functools.partial()</code></pre><p>用法详见网上</p><h2 id="类与对象的方法"><a href="#类与对象的方法" class="headerlink" title="类与对象的方法"></a>类与对象的方法</h2><ol><li><p>getattr(),setattr(),hasattr()三种方法的</p></li><li><p><code>__getitem__()</code>:</p><p>如果想要一个类既有索引又可以切片,需要类似如下的操作</p><pre class=" language-lang-python"><code class="language-lang-python">class Fib(object):    def __getitem__(self, n):        if isinstance(n, int): # n是索引            a, b = 1, 1            for x in range(n):                a, b = b, a + b            return a        if isinstance(n, slice): # n是切片            start = n.start            stop = n.stop            if start is None:                start = 0            a, b = 1, 1            L = []            for x in range(stop):                if x >= start:                    L.append(a)                a, b = b, a + b            return L</code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络第一章</title>
      <link href="/2020/04/25/ji-suan-ji-wang-luo-di-yi-zhang/"/>
      <url>/2020/04/25/ji-suan-ji-wang-luo-di-yi-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="1-2-互联网概述"><a href="#1-2-互联网概述" class="headerlink" title="1.2 互联网概述"></a>1.2 互联网概述</h2><h3 id="1-2-1网络的网络"><a href="#1-2-1网络的网络" class="headerlink" title="1.2.1网络的网络"></a>1.2.1网络的网络</h3><p><strong>计算机网络（简称为网络）</strong>由若干结点（node）和连接这些结点的链路（link）组成。网络中的结点可以是计算机、集线器、交换机或路由器等</p><p><img src="image-20200422123653298.png" alt="网络"></p><p>(a)图三个计算机和一个节点组成了一个网络,上面一片云代表一个网络,(b)图中,很多网络连接起来组成更大的网络,成为网络的网络,即互联网</p><p>习惯上，与网络相连的计算机或手机等终端常称为<strong>主机</strong>（host）。</p><h3 id="1-2-2-互联网基础结构发展的三个阶段"><a href="#1-2-2-互联网基础结构发展的三个阶段" class="headerlink" title="1.2.2 互联网基础结构发展的三个阶段"></a>1.2.2 互联网基础结构发展的三个阶段</h3><ol><li><p>第一阶段是从单个网络ARPANET向互连网发展的过程</p><p>1969年美国国防部创建的第一个分组交换网ARPANET最初只是一个单个的分组交换网（并不是一个互连的<br>网络）。</p><p>1983年TCP/IP协议成为ARPANET上的标准协议，使得所有使用TCP/IP协议的计算机都能利用互连网相互通信，因而人们就把1983年作为互联网的诞生时间。</p><p><strong>internet和Internet的区别:</strong></p><ul><li><p>以小写字母i开始的internet（互连网）是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。在这些网络之间的通信协议（即通信规则）可以任意选择，不一定非要使用TCP/IP协议。</p></li><li><p>以大写字母I开始的Internet（互联网，或因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用TCP/IP协议族作为通信的规则，且其前身是美国的ARPANET。</p></li></ul></li><li><p>第二阶段的特点是建成了三级结构的互联网</p><p>从1985年起，美国国家科学基金会NSF（National Science Foundation）就围绕六个大型计算机中心建设计算机网络，即国家科学基金网NSFNET。它是一个三级计算机网络，分为主干网、地区网和校园网（或企业网）。</p></li><li><p>第三阶段的特点是逐渐形成了多层次ISP结构的互联网</p><p>1993年开始出现互联网服务提供者ISP（Internet Service Provider）。在许多情况下，ISP就是一个进行商业活动的公司，因此ISP又常译为互联网服务提供商。例如，中国电信、中国联通和中国移动等公司都是我国最有名的ISP。</p></li></ol><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><p>可以划分为以下两大块：</p><ul><li>边缘部分　由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享</li><li>核心部分　由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）</li></ul><p><img src="image-20200423114135405.png" alt="互联网边缘部分和核心部分"></p><h3 id="1-3-1-互联网的边缘部分"><a href="#1-3-1-互联网的边缘部分" class="headerlink" title="1.3.1 互联网的边缘部分"></a>1.3.1 互联网的边缘部分</h3><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为端系统（end system）</p><p><strong>“主机A和主机B进行通信”，实际上是指：“运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。由于“进程”就是“运行着的程序”，因此这也就是指：“主机A的某个进程和主机B上的另一个进程进行通信”。这种比较严密的说法通常可以简称为“计算机之间通信”。</strong></p><p>在网络边缘的端系统之间的通信方式通常可划分为两大类：客户-服务器方式（C/S方式）和对等方式（P2P方式):</p><ol><li><p>客户-服务器方式</p><p>上网发送电子邮件或在网站上查找资料时，都是使用客户-服务器方式（有时写为客户/服务器方式）。</p><p>客户（client）和服务器（server）都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服务和被服务的关系。</p><p>客户程序的特点:</p><ul><li>被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。</li><li>不需要特殊的硬件和很复杂的操作系统。</li></ul><p>服务器程序：</p><ul><li>是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li><li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</li><li>一般需要有强大的硬件和高级的操作系统支持。</li></ul></li><li><p>对等连接方式</p><p>对等连接（peer-to-peer，简写为P2P）是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。</p><p>对等连接方式从本质上看仍然是使用客户-服务器方式，只是对等连接中的每一台主机既是客户又同时是服务器。</p><p>对等连接工作方式可支持大量对等用户（如上百万个）同时工作。</p></li></ol><h3 id="1-3-2-互联网的核心部分"><a href="#1-3-2-互联网的核心部分" class="headerlink" title="1.3.2 互联网的核心部分"></a>1.3.2 互联网的核心部分</h3><p>在网络核心部分起特殊作用的是路由器（router），它是一种专用计算机（但不叫做主机）。路由器是实现分组交换（packet switching）的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</p><ol><li><p>电路交换的主要特点</p><p><strong>从通信资源的分配角度来看，交换（switching）就是按照某种方式动态地分配传输线路的资源。</strong>在使用电路交换通话之前，必须先拨号请求建立连接。当被叫用户听到交换机送来的振铃音并摘机后，从主叫端到被叫端就建立了一条连接，也就是一条专用的物理通路。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信时不会被其他用户占用。此后主叫和被叫双方就能互相通电话。通话完毕挂机后，交换机释放刚才使用的这条专用的物理通路（即把刚才占用的所有通信资源归还给电信网）。<strong>这种必须经过“建立连接（占用通信资源）→通话（一直占用通信资源）→释放连接（归还通信资源）”三个步骤的交换方式称为电路交换.</strong>如果用户在拨号呼叫时电信网的资源已不足以支持这次的呼叫，则主叫用户会听到忙音，表示电信网不接受用户的呼叫，用户必须挂机，等待一段时间后再重新拨号。</p><p><img src="image-20200423152330450.png" alt="电路交换的用户始终占用端到端的通信资源"></p><p><strong>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</strong></p></li><li><p>分组交换的主要特点</p><p>分组交换则采用存储转发技术。下图表示把一个报文划分为几个分组后再进行传送。</p><p><img src="image-20200423153736321.png" alt="以分组为基本单位在网络中传送"></p><p>通常我们把要发送的整块数据称为一个报文（message）。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段，例如，每个数据段为1024bit。在每一个数据段前面，加上一些由必要的控制信息组成的首部（header）后，就构成了一个分组（packet）。分组又称为“包”，而分组的首部也可称为“包头”。分组是在互联网中传送的数据单元。分组中的“首部”是非常重要的，正是由于分组的首部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</p><p>主机和计算机的不同功能:</p><ul><li><p><strong>主机</strong>是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。</p></li><li><p><strong>路由器</strong>是用来转发分组的，即进行分组交换的。路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。</p><p>各路由器之间必须经常交换彼此掌握的路由信息，以便创建和动态维护路由器中的转发表，使得转发表能够在整个网络拓扑发生变化时及时更新。</p></li></ul><p><strong>分组交换的特点:</strong></p><ol><li>传送数据之前不必先占用一条端到端的链路的通信资源,分组在哪段链路上传送才占用这段链路的通信资源</li><li>省去了建立连接和释放连接的开销，因而数据的传输效率更高</li><li>当网络中的某些结点或链路突然出现故障时，在各路由器中运行的路由选择协议（protocol）能够自动找到转发分组最合适的路径</li></ol><p><strong>为了提高分组交换网的可靠性，互联网的核心部分常采用网状拓扑结构</strong></p><p>综上,分组交换的优点有:</p><p><img src="image-20200424113110361.png" alt="分组交换的优点"></p></li></ol><p>三种交换方式在数据传送阶段的主要特点：</p><ul><li>电路交换——整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li>报文交换——整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li><li>分组交换——单个分组（这只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</li></ul><p><img src="image-20200424123225063.png" alt="三种交换的比较"></p><p>上图可知:</p><ul><li>大量传输数据的时候,一般传送时间远远大于建立连接时间,则电路交换的传输速率较快</li><li>报文交换和分组交换相对电路交换相比,在传送突发数据时可提高整个网络的信道利用率</li><li>分组交换比比报文交换的时延小,具有更好的灵活性</li></ul><h2 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h2><h3 id="1-5-1-计算机网络的定义"><a href="#1-5-1-计算机网络的定义" class="headerlink" title="1.5.1 计算机网络的定义"></a>1.5.1 计算机网络的定义</h3><p>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><p>根据这定义:</p><ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机。</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li></ul><h3 id="1-5-2-几种不同类别的计算机网络"><a href="#1-5-2-几种不同类别的计算机网络" class="headerlink" title="1.5.2 几种不同类别的计算机网络"></a>1.5.2 几种不同类别的计算机网络</h3><ol><li><p>按照网络的作用范围进行分类</p><p>|          | 广域网                            | 城域网                           | 局域网                                   | 个人区域网                                                   |<br>| ———— | ————————————————- | ———————————————— | ———————————————————— | —————————————————————————————— |<br>| 名称     | WAN（Wide Area Network）          | MAN（Metropolitan Area Network） | LAN（Local Area Network）                | PAN（Personal Area Network）                                 |<br>| 作用范围 | 几十到几千km                      | 5～50km                          | 1km左右                                  | 10m左右                                                      |<br>| 特点     | 互联网的核心部分,有较大的通信容量 | 将多个局域网进行互连             | 用微型计算机或工作站通过高速通信线路相连 | 把属于个人使用的电子设备（如便携式电脑等）用无线技术连接起来的网络 |</p></li><li><p>按照网络的使用者进行分类</p><ul><li>公用网（public network）</li><li>专用网（private network）</li></ul></li></ol><h2 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h2><h3 id="1-6-1-计算机网络的性能指标"><a href="#1-6-1-计算机网络的性能指标" class="headerlink" title="1.6.1 计算机网络的性能指标"></a>1.6.1 计算机网络的性能指标</h3><ul><li><p>速率: 速率的单位是bit/s（bps,比特每秒）</p></li><li><p>带宽:（bandwidth）:某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的“最高数据率”,单位bit/s，是“比特每秒”。</p></li><li><p>吞吐量（throughput）表示在单位时间内通过某个网络（或信道、接口）的实际的数据量。吞吐量受网络的带宽或网络的额定速率的限制</p></li><li><p>时延（delay或latency）是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p><p>时延分以下四个:</p><ul><li><p>发送时延:发送时延（transmission delay）是主机或路由器发送数据帧所需要的时间:</p><script type="math/tex; mode=display">发送时延=\frac{数据帧长度(bit)}{发送速率(bit/s)}</script></li><li><p>传播时延:传播时延（propagation delay）是电磁波在信道中传播一定的距离需要花费的时间。</p><script type="math/tex; mode=display">传播时延=\frac{信道长度(m)}{电磁波在信道上传播的速率(m/s)}</script></li><li><p>处理时延:主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等</p></li><li>排队时延:分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。</li></ul><p>由上可知:</p><script type="math/tex; mode=display">总时延=发送时延+传播时延+处理时延+排队时延</script><p><img src="image-20200424223149141.png" alt="几种地方产生的时延"></p></li><li><p>时延带宽积:</p><script type="math/tex; mode=display">时延带宽积=传播时延\times带宽</script><p><img src="image-20200424231857587.png" alt="链路像一条空心管道"></p></li><li><p>往返时间RTT:RTT（Round-Trip Time）</p></li><li><p>利用率:利用率有信道利用率和网络利用率两种</p><ul><li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</li><li>网络利用率则是全网络的信道利用率的加权平均值。</li></ul><p>信道利用率并非越高越好。这是因为，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。令$D_0$表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式来表示D，$D_0$和利用率U之间的关系:</p><script type="math/tex; mode=display">D =\frac{D_0}{1-U}</script><p>这里U是网络的利用率，数值在0到1之间,<strong>因此我们必须有这样的概念：信道或网络的利用率过高会产生</strong><br><strong>非常大的时延</strong></p><p><img src="image-20200425000955599.png" alt="时延与利用率的关系"></p></li></ul><h3 id="1-6-2-计算机网络的非性能特征"><a href="#1-6-2-计算机网络的非性能特征" class="headerlink" title="1.6.2 计算机网络的非性能特征"></a>1.6.2 计算机网络的非性能特征</h3><p>费用,质量,标准化,可靠性,可扩展性和可升级性,易于管理和维护</p><h2 id="1-7-计算机网络体系结构"><a href="#1-7-计算机网络体系结构" class="headerlink" title="1.7 计算机网络体系结构"></a>1.7 计算机网络体系结构</h2><h3 id="1-7-2-协议与划分层次"><a href="#1-7-2-协议与划分层次" class="headerlink" title="1.7.2 协议与划分层次"></a>1.7.2 协议与划分层次</h3><p>网络协议也可简称为协议。更进一步讲，网络协议主要由以下三个要素组成：<br>（1）语法，即数据与控制信息的结构或格式；<br>（2）语义，即需要发出何种控制信息，完成何种动作以及做出何种响应；<br>（3）同步，即事件实现顺序的详细说明。</p><p>分层可以带来很多好处。如：</p><ul><li>各层之间是独立的。</li><li>灵活性好。</li><li>结构上可分割开。</li><li>易于实现和维护。</li><li>能促进标准化工作。</li></ul><p>通常各层所要完成的功能主要有以下一些（可以只包括一种，也可以包括多种）：</p><ul><li>差错控制　使相应层次对等方的通信更加可靠。</li><li>流量控制　发送端的发送速率必须使接收端来得及接收，不要太快。</li><li>分段和重装　发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li><li>复用和分用　发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li><li>连接建立和释放　交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li></ul><p><strong>计算机网络的各层及其协议的集合就是网络的体系结构（architecture）。</strong></p><h3 id="1-7-3-具有五层协议的体系结构"><a href="#1-7-3-具有五层协议的体系结构" class="headerlink" title="1.7.3 具有五层协议的体系结构"></a>1.7.3 具有五层协议的体系结构</h3><p><img src="image-20200425124909386.png" alt="计算机网络体系结构"></p><ol><li><p>应用层（application layer）</p><p>应用层协议定义的是应用进程间通信和交互的规则</p><p>应用层交互的数据单元称为报文（message）</p><p>任务是通过应用进程间的交互来完成特定网络应用</p><p>域名系统DNS，HTTP协议，电子邮件的SMTP协议均是应用层的协议</p></li><li><p>运输层（transport layer）</p><p>运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务</p><p>运输层主要的协议是:</p><ul><li>传输控制协议TCP（Transmission Control Protocol）——提供面向连接的、可靠的数据传输服务，其数据传输的单位是<strong>报文段</strong>（segment）。</li><li>用户数据报协议UDP（User Datagram Protocol）——提供无连接的、尽最大努力（best-effort）的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户<strong>数据报</strong>。</li></ul></li><li><p>网络层（network layer）</p><p>网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。</p></li><li><p>数据链路层（data link layer）</p><p>数据链路层将网络层交下来的IP数据报组装成帧（framing），在两个相邻结点间的链路上传送帧（frame）。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</p><p>主要作用是:提取数据,上交网络层,差错检测</p></li><li><p>物理层（physical layer）</p><p>物理层要考虑用多大的电压代表“1”或“0”，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。</p><p><strong>传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。</strong></p></li></ol><p>下图是主机1的应用进程AP1向主机2的应用进程AP2传送数据的过程,$H<em>1到H_5$是加入的控制信息,物理层是数据流传送所以不需要控制信息.当到达路由器后,会从第一到第三层,根据首部$H</em>{2}$的的目的地址查找路由器中的转发表，找出转发分组的接口，然后往下传送到第2层，加上新的首部和尾部后，再到最下面的第1层</p><p><img src="image-20200425142700026.png" alt="数据在各层之间的传递过程"></p><h3 id="1-7-4-实体、协议、服务和服务访问点"><a href="#1-7-4-实体、协议、服务和服务访问点" class="headerlink" title="1.7.4 实体、协议、服务和服务访问点"></a>1.7.4 实体、协议、服务和服务访问点</h3><p>实体:表示任何可发送或接收信息的硬件或软件进程</p><p>协议:控制两个对等实体（或多个实体）进行通信的规则的集合</p><p>协议和服务的区别:</p><ul><li>协议的实现保证了能够向上一层提供服务</li><li>使用本层服务的实体只能看见服务而无法看见下面的协议,下面的协议对上面的实体是透明的</li><li>协议是“水平的”，即协议是控制对等实体之间通信的规则。但服务是“垂直的”，即服务是由下层向上层通过层间接口提供的</li></ul><p>第n层向上面的第n＋1层所提供的服务实际上已包括了在它以下各层所提供的服务。第n层的实体对第n＋1层的实体就相当于一个服务提供者</p><h3 id="1-7-5-TCP-IP的体系结构"><a href="#1-7-5-TCP-IP的体系结构" class="headerlink" title="1.7.5 TCP/IP的体系结构"></a>1.7.5 TCP/IP的体系结构</h3><p><img src="image-20200425173859283.png" alt="沙漏计时器形状的TCP/IP协议族示意"></p><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><ol><li><p>计算机网络（可简称为网络）把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络</p></li><li><p>以小写字母i开始的internet（互连网）是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。</p><p>以大写字母I开始的Internet（互联网）是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用TCP/IP协议族作为通信规则，且其前身是美国的ARPANET。Internet的推荐译名是“因特网”，但很少被使用。</p></li><li><p>互联网现在采用存储转发的分组交换技术，以及三层ISP结构。互联网按工作方式可划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</p></li><li><p>计算机通信是计算机中的进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户–服务器方式和对等连接方式（P2P方式）。客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</p></li><li><p>按作用范围的不同，计算机网络分为广域网WAN、城域网MAN、局域网LAN和个人区域网PAN。</p></li><li><p>计算机网络最常用的性能指标是：速率、带宽、吞吐量、时延（发送时延、传播时延、处理时延、排队时延）、时延带宽积、往返时间和信道（或网络）利用率。</p></li><li><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</p></li><li><p>五层协议的体系结构由应用层、运输层、网络层（或网际层）、数据链路层和物理层组成。运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 阅读摘要 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manim学习--Mobject类(一)</title>
      <link href="/2020/03/30/manim-xue-xi-mobject-lei/"/>
      <url>/2020/03/30/manim-xue-xi-mobject-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Mobject所派生的子类"><a href="#1-Mobject所派生的子类" class="headerlink" title="1. Mobject所派生的子类"></a>1. Mobject所派生的子类</h2><p><img src="Mobject-1586013786368.png" alt="Mobject"></p><h2 id="2-Mobject的主要变量与属性"><a href="#2-Mobject的主要变量与属性" class="headerlink" title="2. Mobject的主要变量与属性"></a>2. Mobject的主要变量与属性</h2><h3 id="2-1-CONFIG"><a href="#2-1-CONFIG" class="headerlink" title="2.1 CONFIG"></a>2.1 CONFIG</h3><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "color": WHITE,        "name": None,        "dim": 3,        "target": None,    }</code></pre><h3 id="2-2-init-函数"><a href="#2-2-init-函数" class="headerlink" title="2.2 __init__()函数:"></a>2.2 <code>__init__()</code>函数:</h3><ul><li><p><code>submobjects = []</code>:每个Mobject都有自己的submobjects列表,列表里面的每个元素也是Mobject,这样有利于对嵌套的Mobject进行整体操作,如对一群图形一起平移等等动画的实现</p></li><li><p><code>updaters = []</code>:一系列的更新函数组成,如:</p><pre class=" language-lang-python"><code class="language-lang-python"> def update_text(obj):            obj.next_to(dot,RIGHT,buff=SMALL_BUFF)</code></pre><p>就可以作为一个updater,有<code>add_updater()</code>方法进行添加:</p><pre class=" language-lang-python"><code class="language-lang-python"># author:TB,由于3b1b的函数有改进,本代码进行了修改class AddUpdater(Scene):    def construct(self):        dot = Dot()        text = TextMobject("Label").next_to(dot,RIGHT,buff=SMALL_BUFF)        self.add(dot,text)        # Update function 更新函数        def update_text(obj):            obj.next_to(dot,RIGHT,buff=SMALL_BUFF)        # Add update function to the objects        # 把更新函数加给对象        text.add_updater(update_text)        # 如果想简洁，lambda表达式如下：        # text.add_updater(lambda m: m.next_to(dot,RIGHT,buff=SMALL_BUFF))        # 此时下面的remove_updater(update_text)不能继续使用，需要改为clear_updaters        self.play(dot.shift,UP*2)        # Remove update function        text.remove_updater(update_text)        self.wait()</code></pre><p>效果如下:</p><p><img src="AddUpdater-1586013786369.gif" alt="AddUpdater"></p><p>详细见下面3.3.2的介绍</p></li><li><p><code>updating_suspended = False</code>:是否暂停更新</p></li><li><p><code>points = np.zeros((0, self.dim))</code>:坐标,默认为原点,维度由属性<code>dim</code>决定</p></li></ul><h3 id="2-3-其他函数里面产生的变量"><a href="#2-3-其他函数里面产生的变量" class="headerlink" title="2.3 其他函数里面产生的变量"></a>2.3 其他函数里面产生的变量</h3><ul><li><code>saved_state</code>:自己的一份备份,可以用来恢复之前的状态</li><li><code>array_attr</code>:初始为<code>["points"]</code>列表</li><li><code>z_index_group</code>:暂时不知道有什么用</li></ul><h3 id="2-4-Mobject的一些抽象概念"><a href="#2-4-Mobject的一些抽象概念" class="headerlink" title="2.4 Mobject的一些抽象概念"></a>2.4 Mobject的一些抽象概念</h3><ul><li><p>family:如果将Mobject看作父节点,submobjects列表中的Mobject看作子节点,则对每个Mobjects都会产生一棵树,这个树里面的所有节点成为这个Mobject的family</p><p>family没有真正的实体,但是Mobject内有一个函数叫<code>get_family()</code>可以返回这个概念:</p><pre class=" language-lang-python"><code class="language-lang-python">def get_family(self):        # 如果对map函数不理解,请自行查找Python map()函数        # 递归得到submobjects,代码非常简洁        sub_families = list(map(Mobject.get_family, self.submobjects))        # 使用chain的原因是可能每个submobject可能是不同的类型        all_mobjects = [self] + list(it.chain(*sub_families))        # 去重        return remove_list_redundancies(all_mobjects)</code></pre><p>Mobject的很多函数也用到了这个概念</p></li></ul><h3 id="2-5-Mobject的属性"><a href="#2-5-Mobject的属性" class="headerlink" title="2.5 Mobject的属性"></a>2.5 Mobject的属性</h3><ol><li><p>自身可迭代</p><p>假如有Mobject变量mob,则mob[0]是self本身,mob[1]以及更大的索引是subMobject</p></li><li><p>自身有长度</p><p>自身长度为submobject列表长度+1</p></li></ol><h2 id="3-Mobject的主要方法"><a href="#3-Mobject的主要方法" class="headerlink" title="3. Mobject的主要方法"></a>3. Mobject的主要方法</h2><h3 id="3-1-属性的处理"><a href="#3-1-属性的处理" class="headerlink" title="3.1 属性的处理"></a>3.1 属性的处理</h3><ol><li><p><code>reset_points()</code></p><p>self.points = np.zeros((0, self.dim))</p></li><li><p><code>add(*mobjects)</code></p><p>将自己的submobjects列表中加入mobjects</p><p><strong>注意:不能加入自己</strong></p></li><li><p><code>add_to_back(*mobjects)</code></p><p>将自己的submobjects列表末尾加入mobjects</p><p><strong>注意:如果加入的mobjects中有的在自己的列表中已经存在,则按照加入的mobjects顺序存放</strong></p></li><li><p><code>remove(*mobjects)</code></p><p>submobjects列表移除对应的mobjects</p><p><strong>注意:如果mobjects某些元素不在submobjects列表则不会有任何反应</strong></p></li><li></li></ol><h3 id="3-2-图像静态显示"><a href="#3-2-图像静态显示" class="headerlink" title="3.2 图像静态显示"></a>3.2 图像静态显示</h3><ol><li><p><code>get_image(camera=None)</code></p><p>根据传入的camera类对应的参数(如角度,距离等等)返回一个图像(以PIL.Image的格式)</p><p><strong>注意:应该用不到这个(如果不是自己开发代码)</strong></p></li><li><p><code>show(camera=None)</code></p><p>无动画根据传入的camera类对应的参数(如角度,距离等等)显示自己</p></li><li><p><code>save_image(name=None)</code></p><p>将自己图像保存到宏定义<code>VIDEO_DIR</code>位置,名字为<code>name</code>如果未传入名字,则默认名字为自己的str方法得到的数值</p></li><li><p><code>deepcopy()</code></p></li></ol><p>返回一个自己的副本,副本的改变与不会影响到自己</p><ol><li><code>copy()</code></li></ol><p>浅拷贝,与深拷贝对应</p><ol><li><code>generate_target(use_deepcopy=False)</code></li></ol><h3 id="3-3-更新-跟踪-函数"><a href="#3-3-更新-跟踪-函数" class="headerlink" title="3.3 更新(跟踪)函数"></a>3.3 更新(跟踪)函数</h3><ol><li><p>$ ^{^*}$<code>update(dt=0, recursive=True)</code></p><p><em>底层函数,一般制作的时候用不到,但是仍然列举出来以备不时之需</em></p><ul><li><p>参数含义</p><p><code>dt</code>:每帧运动速率是多少</p><p><code>recursive</code>:递归进行submobjects列表的Mobject的<code>update</code>函数</p></li><li><p>执行过程</p><p>如果updaters的某一项<code>update_function</code>列表里面有参数<code>dt</code>,则执行update_function(dt),否则执行update_function(),并根据recursive判断是否递归到submobjects列表中的每一项</p></li></ul></li><li><p><code>get_updaters()</code>:</p><p>得到updaters[]</p></li><li><p><code>get_family_updaters()</code>:</p><p>得到family的所有updaters</p></li><li><p><code>add_updater(update_function, index=None, call_updater=True)</code></p><ul><li><p>参数含义</p><p><code>update_function</code>:更新函数</p><p><code>index</code>:更新函数的索引</p><p><code>call_updater</code>:我也不知道这个有啥用(¦3[▓▓],3b1b的代码也没找到一个用过这个参数的</p><p><em>TODO:<code>call_updater</code>什么意思,欢迎留言</em></p></li><li><p>执行过程</p><p>将自己的<code>updaters</code>列表加入<code>update_function</code>,位置在<code>index</code>,插入方法同python列表的insert方法,并决定是否立即执行</p><p>例子:</p><pre class=" language-lang-python"><code class="language-lang-python">class UpdateFunctionWithDt(Scene):     def construct(self):         sun = Dot(color=RED).scale(3)         earthOrbit=Circle(color=WHITE).scale(2)         earth=Dot(color=BLUE).scale(2)         earth.move_to(earthOrbit.point_from_proportion(0))         self.earthOffset=0         moonOrbit= Circle(color=WHITE).move_to(earth)         moon =Dot(color=YELLOW)         moon.move_to(moonOrbit.point_from_proportion(0))         self.moonOffset=0         def update_earth(mob,dt):             rate=dt*0.1             mob.move_to(earthOrbit.point_from_proportion((self.earthOffset + rate)%1))             self.earthOffset += rate         def update_moonOrbit(mob):             mob.move_to(earth)         def update_moon(mob,dt):             rate=dt*0.2             mob.move_to(moonOrbit.point_from_proportion((self.moonOffset + rate)%1))             self.moonOffset += rate         earth.add_updater(update_earth)         moonOrbit.add_updater(update_moonOrbit)         moon.add_updater(update_moon)         self.add(earthOrbit,moonOrbit,sun,earth,moon)         self.wait(5)         self.wait()</code></pre><p>效果如下:</p><p><img src="UpdateFunctionWithDt-1586013786369.gif" alt="UpdateFunctionWithDt"></p><p>dt的决定速度:</p><pre class=" language-lang-python"><code class="language-lang-python">class WhatIsDt(Scene):    def construct(self):        sun = Dot(color=RED).scale(3)        earthOrbit=Circle(color=WHITE).scale(2)        earths = [Dot(color=i).scale(2) for i in[RED,BLUE]]        earths = VGroup(*earths)        earths.move_to(earthOrbit.point_from_proportion(0))        self.earthOffsets = [0]*2        texts = VGroup(*[Text("dt*0.%d"%i,size=0.5,font="Lucida Console") for i in [1,2]])        def update_earth_factory(index):            def update_earth(mob,dt):                rate = dt*0.1*(index+1)                mob.move_to(earthOrbit.point_from_proportion((self.earthOffsets[index] + rate)%1))                self.earthOffsets[index] += rate            return update_earth        def update_text_factory(index):            def update_text(mob):                mob.next_to(earths[index],LEFT,SMALL_BUFF)            return update_text        for i in [0,1]:            earths[i].add_updater(update_earth_factory(i))            texts[i].add_updater(update_text_factory(i))        self.add(earthOrbit,sun,earths,texts)        self.wait(5)</code></pre><p><img src="WhatIsDt-1586013786370.gif" alt="WhatIsDt"></p></li></ul></li><li><p><code>remove_updater(update_function)</code>:</p><p>很明显与<code>add_updater</code>相反</p></li><li><p><code>clear_updaters(recursive=True)</code>:</p><p>清除所有的<code>update_function</code>,如果<code>recursive</code>为<code>True</code>则submobjects列表的所有<code>update_function</code>清除</p><p><strong>存疑:<code>recursive</code>为<code>True</code>貌似如果subMobjects里面还套有subMobjects,则内层的不能被清除?</strong></p></li><li><p><code>match_updaters(mobject)</code>:</p><p>将mobject的updater全部复制给自己(自己的原来的updaters失效)</p></li><li><p><code>suspend_updating(recursive=True)</code>:</p><p>略</p></li><li><p><code>resume_updating(recursive=True)</code></p><p>略</p></li><li><p><code>get_time_based_updaters()</code>:</p><p>得到参数含有<code>dt</code>的updater</p></li><li><p><code>has_time_based_updater()</code>:</p><p>有参数含有<code>dt</code>的updater</p></li></ol><h3 id="3-4-变换函数"><a href="#3-4-变换函数" class="headerlink" title="3.4 变换函数"></a>3.4 变换函数</h3><ol><li><p><code>apply_to_family(func)</code>:</p><p>对每个家庭成员实行func函数</p></li><li><p><code>shift(*vectors)</code>:</p><p>平移,vector的维数为dim,如果输入多个vector则平移的终点为这几个vector的向量和</p><p>如<code>.shift(UP*2,LEFT)</code>和<code>shift(UP*2+LEFT)</code>是一个效果</p></li><li><p><code>scale(scale_factor, **kwargs)</code>:</p><ul><li><p>参数:</p><p><code>scale_factor</code>:缩放因子</p><p><code>**kwargs</code>:</p><p>默认行为是围绕mobject的中心进行缩放。参数about_edge可以是向量，指要围绕mobject的哪一侧进行缩放,否则，如果给about_point一个值，则相对于该点进行缩放。</p><ul><li><p><code>about_edge</code>:相对边</p><pre class=" language-lang-python"><code class="language-lang-python">class AddUpdater(Scene):    def construct(self):        circles = [Circle(arc_center = LEFT*i*2) for i in range(3)]        vg = VGroup(*circles)        line = Line(np.array([-10,vg.get_top()[1],0]),np.array([10,vg.get_top()[1],0]))        text = TextMobject("about\_edge")        text.next_to(line,UP,buff=SMALL_BUFF)        self.add(line,vg,text)        self.play(vg.scale,2,{"about_edge":UP})        self.wait()</code></pre><p><img src="about_edge-1586013786370.gif" alt="about_edge"></p><p>如果<code>about_edge</code>为方向的线性组合,则会按照对应的边进行阻隔,以UP+RIGHT为例子:</p><pre class=" language-lang-python"><code class="language-lang-python">class AddUpdater(Scene):    def construct(self):        circles = [Circle(arc_center = LEFT*i*2) for i in range(3)]        vg = VGroup(*circles)        line = Line(np.array([-10,vg.get_top()[1],0]),np.array([10,vg.get_top()[1],0]))        line1 = Line(np.array([vg.get_right()[0],-10,0]),np.array([vg.get_right()[0],10,0]))        text = TextMobject("about\_edge1")        text.next_to(line,UP,buff=SMALL_BUFF)        text1 = TextMobject("about\_edge2")        text1.next_to(line1,RIGHT,buff=SMALL_BUFF)        self.add(line,line1,vg,text,text1)        self.play(vg.scale,2,{"about_edge":np.array(UP+RIGHT)})        self.wait()</code></pre><p><img src="UP_RIGHT-1586013786370.gif" alt="UP_RIGHT"></p></li><li><p><code>about_point</code>:相对点</p><pre class=" language-lang-python"><code class="language-lang-python">class AddUpdater(Scene):    def construct(self):        circles = [Circle(arc_center = LEFT*i*2) for i in range(3)]        vg = VGroup(*circles)        dot = Dot(point=circles[0].get_center())        text = TextMobject("about\_point")        text.next_to(dot,DOWN,buff=SMALL_BUFF)        self.add(dot,vg,text)        self.play(vg.scale,2,{"about_point":dot.get_center()})        self.wait()</code></pre><p><img src="about_point-1586013786370.gif" alt="about_point"></p></li></ul></li><li><p>执行过程</p><p>放大或缩小指定的因子</p></li></ul></li><li><p><code>rotate(angle, axis=OUT, **kwargs)</code>:</p><p>学过初中物理就应该知道右手定则,在数学,物理中,旋转的方向就是右手定则中的(大拇指)方向</p><pre class=" language-lang-python"><code class="language-lang-python">class myRotateScene(ThreeDScene):    def construct(self):     dot = Dot()        text = TextMobject("about\_point",color=RED)        text.next_to(dot,DOWN,buff=SMALL_BUFF)        axes = ThreeDAxes()        self.add(dot,text,axes)        self.set_camera_orientation(theta=-PI/4,phi=PI/4)                   self.play(text.rotate,PI/2,{"axis":OUT})        self.wait()</code></pre><p><img src="Rotate-1586013786370.gif" alt="Rotate"></p><p>上图text的起始平面是X-Y平面,UP为y轴正方向,大家可以自行尝试更改axis方向(注意self.play函数不代表角度从0到PI/2的渐近变化所以只要看起始帧和终止帧)</p><p><code>**kwargs</code>还可以接受相对点<code>about_point</code>:</p><pre class=" language-lang-python"><code class="language-lang-python">class myRotateScene(ThreeDScene):    def construct(self):        dot = Dot()        text = TextMobject("about\_point",color=RED)        text.next_to(dot,DOWN,buff=SMALL_BUFF)        axes = ThreeDAxes()        self.add(dot,text,axes)        self.set_camera_orientation(theta=-PI/4,phi=PI/4)                   self.play(text.rotate,PI,{"axis":OUT,"about_point":dot.get_center()})        self.wait()</code></pre><p>这个相对点旋转其实是线性代数里面的旋转矩阵造成的结果,如果角度是180度,效果是关于这个点对称</p><p><img src="rotateAboutPoint-1586013786370.gif" alt="rotateAboutPoint"></p></li><li><p><code>flip(axis=UP, **kwargs)</code>:</p><p>翻转,其实就是<code>rotate</code>180度,其他参数同<code>rotate</code></p></li><li><p><code>stretch(factor, dim, **kwargs)</code>:</p><p>在对应的维度伸缩<code>factor</code>倍</p><p>这个函数与<code>scale</code>的用法一样,也会有<code>about_point</code>和<code>about_edge</code></p><pre class=" language-lang-python"><code class="language-lang-python">class Stretch(Scene):    def construct(self):        text = Text("stretch")        self.play(text.stretch,2,1)        self.wait(2)</code></pre></li><li><p><code>apply_function(function, **kwargs)</code>:</p><p>对所有family成员的点坐标都进行<code>function</code>处理,所以function必须是一个处理一个点的函数</p><p>例如对于二维图形:</p><pre class=" language-lang-python"><code class="language-lang-python">class myScene(Scene):    def func(self,point):        return point*2    def construct(self):        circle = Circle()        circle2 = Circle()        self.add(circle,circle2)          circle.apply_function(self.func)        self.play(Write(circle))        self.wait()</code></pre><p>默认的<code>about_point</code>为<code>ORIGIN</code>,可以看出来实现了<code>apply_function</code>的会大一倍</p><p><img src="applyFunc-1586013786370.gif" alt="applyFunc"></p></li><li><p><code>apply_function_to_position(function)</code>:</p><p>移动图像中心到function(self.get_center())</p><pre class=" language-lang-python"><code class="language-lang-python">class myWag(Scene):    def x2(self,x):        return x*2    def construct(self):        circle = Circle()        circle.move_to(RIGHT)        self.add(circle)        self.play(circle.apply_function_to_position,{"function":self.x2})        self.wait()</code></pre></li><li><p><code>apply_function_to_submobject_positions(function)</code>:</p><p>略</p></li><li><p><code>apply_matrix(matrix, **kwargs)</code>:</p><p><code>matrix</code>为变换矩阵,这个就是对Mobject点对应的向量乘以<code>matrix</code>变换矩阵,学过线性代数或者计算机视觉或者看过3b1b的线性代数的人应该不陌生</p></li><li><p><code>apply_complex_function(function, **kwargs)</code>:</p><p>同理于<code>apply_function(function, **kwargs)</code>,只不过这里的<code>function</code>接受一个平面复数,即<code>complex(x, y)</code></p></li><li><p><code>wag(direction=RIGHT, axis=DOWN, wag_factor=1.0)</code>:</p><p>分析源码得到如下处理步骤:</p><ol><li><p>对所有含有坐标属性家庭成员进行步骤2到5的操作</p></li><li><p>向axis对应维度投影,如axis=UP/DOWN则向y轴投影,即保留y值不变,得到对应维度的向量列表alphas</p></li><li><p>将向量列表alphas归一化到[0,1],归一方法如下:</p><script type="math/tex; mode=display">\vec{alphas'}_i = \frac{\vec{alphas}_i-min(\vec{alphas})}{max(\vec{alphas})-min(\vec{alphas})}</script></li><li><p>执行幂运算</p><script type="math/tex; mode=display">\vec{alphas}_i^{"}=(\vec{alphas'})^{wag\_factor}</script></li><li><p>每个点在direction方向平移$\vec{alphas}_i^{“}$</p></li></ol><p>例子:</p><p>factor=1</p><pre class=" language-lang-python"><code class="language-lang-python">class myWag(Scene):    def construct(self):        squares = [Square() for i in range(3)]        for i in range(-1,2):            squares[1+i].move_to(RIGHT*3*i)        self.add(*squares)         self.play(squares[0].wag,{"direction":UP,"axis":RIGHT,"wag_factor":0.1},                  squares[1].wag,{"direction":UP,"axis":RIGHT,"wag_factor":1},                  squares[2].wag,{"direction":UP,"axis":RIGHT,"wag_factor":2})        self.wait()</code></pre><p><img src="myWag1-1585643241928-1586013786370.gif" alt="myWag1"></p><p>从左到右factor依次为0.1,1,2,都是向上wag的,具体怎么理解大家可以自己理解,比较难以表述</p></li><li><p><code>reverse_points()</code>:</p><p>调换点的顺序:</p><pre class=" language-lang-python"><code class="language-lang-python">class myWag(Scene):    def construct(self):        circle = Circle().scale(2)        texts = [TextMobject("p"+str(i)).scale(0.5) for i in range(len(circle.points))]        def update_factory(index):            def update_func(mob):                mob.move_to(circle.points[index])            return update_func        for i in range(len(texts)):            texts[i].add_updater(update_factory(i))        self.add(circle,*texts)        self.wait(1)        self.play(circle.reverse_points)        self.wait(2)</code></pre><p><img src="ReversePoint-1586013786371.gif" alt="ReversePoint"></p><p>注意play函数不能很好表现reverse的现象,如果看顺序,上图顺序从逆时针变成了顺时针</p></li><li><p><code>repeat(count)</code>:</p><p>会出现重影的特效</p><p><img src="Repeat-1586013786371.gif" alt="Repeat"></p></li><li><p><code>apply_points_function_about_point(func, about_point=None, about_edge=None)</code>:</p><p>相对点或边对自己的所有点左边应用函数</p></li></ol><h3 id="3-5-位置函数"><a href="#3-5-位置函数" class="headerlink" title="3.5 位置函数"></a>3.5 位置函数</h3><ol><li><p><code>center()</code>:</p><p>此处center为动词:到中心</p><pre class=" language-lang-python"><code class="language-lang-python">class Repeat(Scene):    def construct(self):        square = Square()        dot=Dot()        self.add(square,dot)        self.play(square.shift,RIGHT)        self.play(square.shift,RIGHT)        self.play(square.shift,UP)        self.play(square.center)        self.wait()</code></pre><p><img src="Center-1586013786371.gif" alt="Center"></p></li><li><p><code>align_on_border(direction, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER)</code>:</p><p>在边界对齐,buff为和边界的距离</p><pre class=" language-lang-python"><code class="language-lang-python">class Align(Scene):    def construct(self):        square = Square()        self.play(square.align_on_border,LEFT+UP)        self.wait(2)</code></pre><p><img src="Align-1586013786371.gif" alt="Align"></p></li><li><p><code>to_corner(corner=LEFT + DOWN, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER)</code>:</p><p>到某一个角</p><p><img src="to-1586013786371.png" alt="to_corner author:Elteoremadebeethoven"></p></li><li><p><code>to_edge(edge=LEFT, buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER)</code>:</p><p>到某一边</p></li><li><p><code>next_to(mobject_or_point,direction=RIGHT, buff=DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,aligned_edge=ORIGIN,submobject_to_align=None,index_of_submobject_to_align=None, coor_mask=np.array([1, 1, 1]),)</code>:</p><p>参数分析:</p><ul><li><code>mobject_or_point</code>:Mobject或者一个点坐标</li><li><code>direction</code>:方向</li><li><code>buff</code>:相聚的距离</li><li><code>aligned_edge</code>:对齐的边</li><li><code>submobject_to_align</code>:对齐的子Mobject,此参数要求Mobject是一个列表性质的Mobject</li><li><code>index_of_submobject_to_align</code>:如果<code>submobject_to_align</code>不为空,则需要指定对应的是哪一个Mobject</li></ul></li></ol><ul><li><code>coor_mask</code>:掩膜,术语来自数字信号处理/数字图像处理,不懂可以自行搜索,在这里即为1的地方才进行next_to,如果为0,则对应的坐标不进行next_to变换</li></ul><p>执行过程:</p><p>   如果<code>mobject_or_point</code>是点则next_to的对象就是点,否则为由参数决定的Mobject的中心</p><ol><li><p><code>shift_onto_screen(**kwargs)</code>:</p></li><li><p><code>is_off_screen()</code>:</p><p>是否超出屏幕范围</p></li><li><p><code>rescale_to_fit(length, dim, stretch=False, **kwargs)</code>:</p><p>将某一个方向的长度拉伸至length,可以按照scale方式拉长或者stretch方式拉长</p><pre class=" language-lang-python"><code class="language-lang-python">class RescaleToFit(Scene):    def construct(self):        ellipse = Ellipse()        length = ellipse.length_over_dim(0)        self.play(ellipse.rescale_to_fit,length,1,{"stretch":True})        self.wait(2)</code></pre><p><img src="RescaleToFit-1586013786371.gif" alt="RescaleToFit"></p><ul><li><code>stretch_to_fit_width(width, **kwargs)</code></li><li><code>stretch_to_fit_height(height, **kwargs)</code></li><li><code>stretch_to_fit_depth(depth, **kwargs)</code></li><li><code>set_width(width, stretch=False, **kwargs)</code></li><li><code>set_height(height, stretch=False, **kwargs)</code></li><li><code>set_depth(depth, stretch=False, **kwargs)</code></li></ul></li><li><p><code>set_coord(value, dim, direction=ORIGIN)</code>:</p><p>将dim对应的坐标设置为value,direction表示设置什么的坐标,如direction为RIGHT则表示设置图像的最右端点的dim维度的坐标为value</p><ul><li><code>set_x(x, direction=ORIGIN)</code></li><li><code>set_y(y, direction=ORIGIN)</code></li><li><code>set_z(z, direction=ORIGIN)</code></li></ul></li><li><p><code>space_out_submobjects(factor=1.5, **kwargs)</code>:</p><p>自己scale factor倍,子mobject缩小1/factor倍</p></li><li><p><code>move_to(point_or_mobject, aligned_edge=ORIGIN,coor_mask=np.array([1, 1, 1]))</code>:</p><p>与next_to相近,不过区别是:next_to表示的是边界的距离，而不是中心距离</p><p><img src="move_next_to-1586013786372.png" alt="move_next_to author:Elteoremadebeethoven"></p></li><li><p><code>replace(mobject, dim_to_match=0, stretch=False)</code>:</p><p>将位置移动到mobject,并且大小做一些改变,具体看源码</p></li><li><p><code>surround(mobject,dim_to_match=0,stretch=False,buff=MED_SMALL_BUFF)</code>:</p><p>包围(默认情况下,等边长的正多边形规则物体效果很好,对于不等变长的形状最好启用stretch)</p><pre class=" language-lang-python"><code class="language-lang-python">class Surround(Scene):    def construct(self):        circle = Circle()        square = Square().shift(UP*2)        self.add(circle,square)        self.play(circle.surround,square)        self.wait(2)</code></pre><p><img src="Surround-1586013786372.gif" alt="Surround"></p></li><li><p><code>put_start_and_end_on(start, end)</code>:</p><p>将起点终点重置为start,end</p><pre class=" language-lang-python"><code class="language-lang-python">class PutStartAndEndOn(Scene):    def construct(self):        arc = Arc(PI/3)        texts = [TexMobject(i,color=RED) for i in ["startPoint","endPoint"]]        texts[0].add_updater(lambda x: x.move_to(arc.get_start()))        texts[1].add_updater(lambda x: x.move_to(arc.get_end()))        self.add(arc, *texts)        self.play(arc.put_start_and_end_on,ORIGIN,(UP+RIGHT)*2)        self.wait()</code></pre><p><img src="PutStartAndEndOn-1586013786372.gif" alt="PutStartAndEndOn"></p></li><li><p><code>add_background_rectangle(color=BLACK, opacity=0.75, **kwargs)</code>:</p><p>增加背景方块,此方块是可以随着Mobject变化而变化的</p><pre class=" language-lang-python"><code class="language-lang-python">class BackgroundRectangle(Scene):    def construct(self):        circle = Circle(color=RED)        circle.add_background_rectangle(color=BLUE,opacity=0.4)        self.add(circle)        self.play(circle.stretch,2,1)        self.wait()</code></pre><p><img src="BackgroundRectangle-1586013786372.gif" alt="BackgroundRectangle"></p></li><li><p><code>add_background_rectangle_to_submobjects(**kwargs)</code>:</p><p>略</p></li><li><p><code>add_background_rectangle_to_family_members_with_points(**kwargs)</code>:</p><p>略</p></li></ol><h3 id="3-6-颜色函数"><a href="#3-6-颜色函数" class="headerlink" title="3.6 颜色函数"></a>3.6 颜色函数</h3><ol><li><p><code>set_color(color=YELLOW_C, family=True)</code>:</p><p>设置颜色,family指家庭成员是否也跟着变色</p></li><li><p><code>set_color_by_gradient(*colors)</code>:</p><p>渐变色,可以是两个或多个颜色的列表</p><pre class=" language-lang-python"><code class="language-lang-python">class main(Scene):    def construct(self):        qed = TexMobject('This is a Text').scale(1.25)        qed.set_color_by_gradient(RED,YELLOW,GREEN,BLUE)        self.play(Write(qed))        self.wait(3)</code></pre><p><img src="image-20200403201147347-1586013786372.png" alt="gradientColor"></p></li><li><p><code>set_colors_by_radial_gradient(center=None, radius=1, inner_color=WHITE, outer_color=BLACK)</code>:</p><p>辐射状渐变颜色,半径为radius</p></li><li><p><code>set_submobject_colors_by_gradient(*colors)</code>:</p><p>给子Mobject设置渐变颜色</p></li><li><p><code>set_submobject_colors_by_radial_gradient(center=None, radius=1, inner_color=WHITE, outer_color=BLACK)</code>:</p><p>同理,略</p></li><li><p><code>fade_to(color, alpha, family=True)</code>:</p><p>褪色为某一个颜色,alpha为插值系数,alpha在[0,1]之间,越接近1,褪色越厉害</p><pre class=" language-lang-python"><code class="language-lang-python">class FadeTo(Scene):    def construct(self):        text = TexMobject("This is a Text")        self.add(text)        self.play(text.set_colors_by_radial_gradient,{"inner_color":WHITE,"outer_color":RED})        self.play(text.fade_to,BLUE,1)        self.wait()</code></pre><p><img src="FadeTo-1586013786373.gif" alt="FadeTo"></p></li><li><p><code>get_color()</code>:</p><p>返回颜色</p></li><li><p><code>fade(darkness=0.5, family=True)</code>:</p><p>褪色为黑色,darkness为灰度</p></li></ol><h3 id="3-7-恢复函数"><a href="#3-7-恢复函数" class="headerlink" title="3.7 恢复函数"></a>3.7 恢复函数</h3><ol><li><p><code>save_state(use_deepcopy=False)</code>:</p><p>保存状态,并确定是否使用深拷贝</p></li><li><p><code>restore()</code>:</p><p>恢复之前状态</p></li></ol><h3 id="3-8-其他的getter方法"><a href="#3-8-其他的getter方法" class="headerlink" title="3.8 其他的getter方法"></a>3.8 其他的getter方法</h3><ol><li><p><code>reduce_across_dimension(points_func, reduce_func, dim)</code>:</p></li><li><p><code>nonempty_submobjects()</code>:</p><p>返回Submobject的subSubMobject不为空的Submobject</p></li><li><p><code>get_merged_array(array_attr)</code>:</p><p>得到Mobject以及其子Mobject的array_attr属性的列表</p></li><li><p><code>get_all_points()</code>:</p><p>得到Mobject与其子Mobject属性所有的点</p></li><li><p><code>get_num_points()</code>:</p><p>得到自己的点的数量(不包含子Mobject)</p></li><li><p><code>get_extremum_along_dim(points=None, dim=0, key=0)</code>:</p><p>沿着dim方向(dim为0表示x方向,1表示y方向….),给出坐标的极值,key&lt;0表示得到最小值,key&gt;0表示得到最大值,key=0表示得到中值</p></li><li><p><code>get_critical_point(direction)</code>:</p><p>画一个框，框住mobject。 这样的盒子有9个“关键点”：4个角，4个边缘中心，中心。 这将返回其中之一。</p><p>direction什么方向就返回什么</p><p>对其进行封装有如下的函数:</p><ul><li><code>get_edge_center</code><ul><li><code>get_top</code></li><li><code>get_bottom</code></li><li><code>get_right</code></li><li><code>get_left</code></li><li><code>get_zenith</code></li><li><code>get_nadir</code></li></ul></li><li><code>get_corner</code></li><li><code>get_center</code></li></ul></li><li><p><code>get_boundary_point(direction)</code>:</p><p>得到某个方向的最远的点</p><pre class=" language-lang-python"><code class="language-lang-python">class FadeTo(Scene):    def construct(self):        square = Square()        circle = Circle().shift(2 * RIGHT + 1 * DOWN)        shapeGroup = VGroup(square,circle)        points = []        nums = 10        for i in range(nums):            points.append(shapeGroup.get_boundary_point(np.array((np.cos(2*PI*i/nums),np.sin(2*PI*i/nums),0))))        polygon = Polygon(*points,color=BLUE)        dots = [Dot(point=i) for i in points]        self.add(shapeGroup,*dots)        self.play(Write(polygon))        self.wait(2)</code></pre><p><img src="image-20200404172800256-1586013786373.png" alt="boundary_points"></p></li><li><p><code>length_over_dim(dim)</code>:</p><p>dim方向的长度</p><p>此方法封装的方法:</p><ul><li><code>get_width</code></li><li><code>get_height</code></li><li><code>get_depth</code></li></ul></li><li><p><code>get_coord(dim, direction=ORIGIN)</code>:</p><p>在dim方向得到direction对应的极值,直接使用意义不大</p><ul><li><code>get_x(direction=ORIGIN)</code></li><li><code>get_y(direction=ORIGIN)</code></li><li><code>get_z(direction=ORIGIN)</code></li></ul></li><li><p><code>get_start</code>,<code>get_end</code>,<code>get_start_and_end</code>:</p><p>得到点的起点终点,起点和终点</p></li><li><p><code>has_points</code>,<code>has_no_points</code>:</p><p>是否有点这属性</p></li></ol><h3 id="3-9-匹配函数"><a href="#3-9-匹配函数" class="headerlink" title="3.9 匹配函数"></a>3.9 匹配函数</h3><ol><li><p><code>match_color(mobject)</code>:</p><p>匹配mobject的颜色</p></li><li><p><code>match_dim_size(mobject, dim, **kwargs)</code>:</p><p>匹配dim方向的长度,<code>**kwargs</code>和<code>rescale_to_fit()</code>使用方法相同</p><ul><li><code>match_width</code></li><li><code>match_height</code></li><li><code>match_depth</code></li></ul></li><li><p><code>match_coord(mobject, dim, direction=ORIGIN)</code>:</p><p>按照get_coord()得到对应的Mobject坐标,然后设置</p><ul><li><code>match_x</code></li><li><code>match_y</code></li><li><code>match_z</code></li></ul></li></ol><h3 id="3-10-排列函数"><a href="#3-10-排列函数" class="headerlink" title="3.10 排列函数"></a>3.10 排列函数</h3><ol><li><p><code>arrange(direction=RIGHT, center=True, **kwargs)</code>:</p><p>submobject列表的全部变量进行排队,按照direction的方式排队,center决定了是否排完队跑到中心</p><p><code>**kwargs</code>参考next_to</p><pre class=" language-lang-python"><code class="language-lang-python">class Arrange(Scene):    def construct(self):        square = Square()        square.add(Dot(point=np.array([-1,-2,0])))        square.add(Square().move_to(np.array([3,0,0])))        square.add(Circle().move_to(np.array([5, 2, 0])))        self.add(square)        self.play(square.arrange,{"center":False})        self.wait(2)        self.play(square.arrange,{"direction":UP,"center":False})        self.wait(2)</code></pre><p><img src="Arrange-1586013786373.gif" alt="Arrange"></p></li><li><p><code>arrange_in_grid(n_rows=None, n_cols=None, **kwargs)</code>:</p><p>对submobject列表重拍列</p><p>如果默认无参数,重拍列至方阵,否则n_rows和n_cols最多选一个,排列为对应的行或列,如果都填,则排列为n_rows行</p><p><code>**kwargs</code>参考next_to函数</p><pre class=" language-lang-python"><code class="language-lang-python">class ArrangeInGrid(Scene):    def construct(self):        square = Square()        square.add(Circle().move_to(np.array([-1,-2,0])))        square.add(Circle().move_to(np.array([3,0,0])))        square.add(Circle().move_to(np.array([5, 2, 0])))        square.add(Circle().move_to(np.array([5, -3, 0])))        self.add(square)        self.play(square.arrange_in_grid)        self.wait(2)</code></pre><p><img src="ArrangeInGrid-1586013786373.gif" alt="ArrangeInGrid"></p></li><li><p><code>sort(point_to_num_func=lambda p: p[0], submob_func=None)</code>:</p><p>对点进行排序,这个一般意义不大,可以自己编写排序方法</p></li><li><p><code>shuffle(recursive=False)</code>:</p><p>打乱submobject的列表排序,以及是否递归进行</p></li></ol><h3 id="3-11-对齐函数"><a href="#3-11-对齐函数" class="headerlink" title="3.11 对齐函数"></a>3.11 对齐函数</h3><ol><li><p><code>align_to(mobject_or_point, direction=ORIGIN, alignment_vect=UP)</code>:</p><p>对齐,direction表示对齐的边是哪边</p><p>mob1.align_to（mob2，UP）垂直移动mob1，以便其顶部边缘与mob2的顶部边缘对齐。 mob1.align_to（mob2，alignment_vect = RIGHT）水平移动mob1，使其中心位于mob2中心的正上方/正下方</p><pre class=" language-lang-python"><code class="language-lang-python">class AlighTo(Scene):    def construct(self):        square = Square()        circle = Circle().shift(2 * RIGHT + 1 * DOWN).scale(2)        self.add(square,circle)        self.play(circle.align_to,square,RIGHT)        self.wait(2)</code></pre><p><img src="AlighTo-1586013786373.gif" alt="AlighTo"></p></li><li><p><code>add_n_more_submobjects(n)</code>:</p><p>加入n个submoject</p></li></ol><h3 id="3-12-抽象方法"><a href="#3-12-抽象方法" class="headerlink" title="3.12 抽象方法"></a>3.12 抽象方法</h3><ol><li><p><code>align_data(mobject)</code>:</p></li><li><p><code>align_points(mobject)</code>:</p></li><li><p><code>align_submobjects(mobject)</code>:</p><p>对齐submobjects</p></li><li><p><code>null_point_align(mobject)</code>:</p></li><li><p><code>get_point_mobject(center=None)</code></p></li><li><p><code>align_points_with_larger(larger_mobject)</code></p></li><li><p><code>interpolate_color(mobject1, mobject2, alpha)</code>:</p><p>颜色插值</p></li><li><p><code>interpolate(mobject1,mobject2,alpha, path_func=straight_path)</code>:</p><p>Mobject插值</p></li><li><p><code>become_partial(mobject, a, b)</code>:</p><p>以仅成为mobject一部分的方式设置点。 输入0 &lt;= a &lt;b &lt;= 1确定要成为mobject的哪一部分。</p></li><li><p><code>become(mobject, copy_submobjects=True)</code>:</p><p>变成另一个的样式</p><pre class=" language-lang-python"><code class="language-lang-python">class Become(Scene):    def construct(self):        square = Square()        square.submobjects.append(Circle().move_to(np.array([-1,-2,0])))        square.submobjects.append(Circle().move_to(np.array([3,0,0])))        square.submobjects.append(Circle().move_to(np.array([5, 2, 0])))        square.submobjects.append(Circle().move_to(np.array([5, -3, 0])))        text = Text("text")        self.add(square)        self.play(square.become,text)        self.play(text.shift,UP)        self.wait(2)</code></pre><p><img src="Become-1586013786373.gif" alt="Become"></p></li></ol><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h2><p>Mobject的用法还是很多的,空闲时间写了很多天才写完,希望自己能用熟练</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> manim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> manim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manim学习--Container类</title>
      <link href="/2020/03/30/manim-xue-xi-container-lei/"/>
      <url>/2020/03/30/manim-xue-xi-container-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Container的派生类"><a href="#1-Container的派生类" class="headerlink" title="1. Container的派生类"></a>1. Container的派生类</h2><p><img src="Container.png" alt="Container"></p><h2 id="2-container类的作用"><a href="#2-container类的作用" class="headerlink" title="2. container类的作用"></a>2. container类的作用</h2><p>代码注释有段话: 当前，这仅适用于Scene和Mobject.尽管如此，我们还是在这里抽象其功能，尽管纯粹是名义上的.目前，所有实现都必须由派生类处理。</p><p>上面的注释说明了3B1B正在规范代码,使代码的阅读者更好的读懂代码与自己创建代码分支</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>container类仅仅是一个抽象类,只有add和remove抽象方法,没有很大的实际用途,除非自己开发代码,不然不会用到这个类.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> manim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> manim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manim的主要绘图类</title>
      <link href="/2020/03/27/manim-de-zhu-yao-hui-tu-lei/"/>
      <url>/2020/03/27/manim-de-zhu-yao-hui-tu-lei/</url>
      
        <content type="html"><![CDATA[<p>manim的整体结构解析</p><h2 id="1-CONFIG是什么"><a href="#1-CONFIG是什么" class="headerlink" title="1. CONFIG是什么"></a>1. CONFIG是什么</h2><p>几乎任何的类都会有一个神奇的字典,叫<code>CONFIG</code>,这个字典的所有键值对都会被赋予给类的属性,原因是因为所有的绘图类都是继承自<strong>Container</strong>类(<em>位置:\manimlib\container\container.py</em>),这个类在初始化的时候执行代码如下:</p><pre class=" language-lang-python"><code class="language-lang-python">class Container(object):    def __init__(self, **kwargs):        digest_config(self, kwargs)</code></pre><p>而<em>digest_config</em>在<em>\manimlib\utils\config_ops.py</em>:</p><pre class=" language-lang-python"><code class="language-lang-python">def digest_config(obj, kwargs, caller_locals={}):    """    Sets init args and CONFIG values as local variables    The purpose of this function is to ensure that all    configuration of any object is inheritable, able to    be easily passed into instantiation, and is attached    as an attribute of the object.    将初始化参数和CONFIG值设置为局部变量    此功能的目的是确保所有任何对象的配置都是可继承的，能够易于传    递到实例化并附加作为对象的属性。    """    # Assemble list of CONFIGs from all super classes    # 将所有父类的CONFIG全部集中在static_configs    classes_in_hierarchy = [obj.__class__]    static_configs = []    while len(classes_in_hierarchy) > 0:        Class = classes_in_hierarchy.pop()        classes_in_hierarchy += Class.__bases__        if hasattr(Class, "CONFIG"):            static_configs.append(Class.CONFIG)    # Order matters a lot here, first dicts have higher priority    # 顺序很重要,字典的靠前的键值对有更高的优先级(即如果有相同的,覆盖后面的键值对)    # 优先级的处理是由merge_dicts_recursively函数处理的,具体自己读源代码    caller_locals = filtered_locals(caller_locals)    all_dicts = [kwargs, caller_locals, obj.__dict__]    all_dicts += static_configs    obj.__dict__ = merge_dicts_recursively(*reversed(all_dicts))</code></pre><p>上面的英文解释已经很清楚了,一句话概括这个函数:将CONFIG这个字典中的内容变成类的属性.<br>值得注意的是:<strong>这个字典的一些键的值可以继续为CONFIG字典</strong></p><h2 id="2-主要类图"><a href="#2-主要类图" class="headerlink" title="2. 主要类图"></a>2. 主要类图</h2><p>Container类图:</p><p><img src="Container.png" alt="Container类图"></p><p>Mobject类图:</p><p><img src="Mobject.png" alt="Mobject类图"></p><p>其中的VMobject类图:</p><p><img src="VMobject.png" alt="VMobject类图"></p><p>Scene类图:</p><p><img src="Scene.png" alt="Scene类图"></p><p>Camera类图:</p><p><img src="Camera.png" alt="Camera类图"></p><p>Animation类图:</p><p><img src="Animation.png" alt="Animation类图"></p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>时隔几个月,我又重新更新并看了一下manim的repo,这次我仅仅是粗略看了一下manim的结构,发现变化还是很明显的,相比几个月前的难以阅读,到现在几乎是很好阅读了.</p><p>我在此也对整个文件结构的所有类图内容扫描了一遍,发现整个代码里面几乎能想到的形式都有对应的类实现,有的类的继承实现甚至非常多余,因为就改了一两个参数,这几乎可以自己写,不过这manim本身目的就不是给公开使用,而是Grant Sanderson用来做视频的.</p><p>如果有时间我会对几个最基本的类进行解释,如果把最基本的类用法解释清楚接下来就可以很好的制作3b1b风格视频了.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> manim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> manim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机四级网络技术</title>
      <link href="/2020/03/26/ji-suan-ji-si-ji-wang-luo-ji-zhu/"/>
      <url>/2020/03/26/ji-suan-ji-si-ji-wang-luo-ji-zhu/</url>
      
        <content type="html"><![CDATA[<p>本文是对计算机四级知识点的整理摘要，覆盖大概90%的历年考试知识点，剩下的不多的计算题大家自行琢磨理解</p><h1 id="第一章-网络技术基础"><a href="#第一章-网络技术基础" class="headerlink" title="第一章 网络技术基础"></a>第一章 网络技术基础</h1><h3 id="1-1-2-计算机网络形成与ARPANET"><a href="#1-1-2-计算机网络形成与ARPANET" class="headerlink" title="1.1.2 计算机网络形成与ARPANET"></a>1.1.2 计算机网络形成与ARPANET</h3><p>美国国防高级研究计划局提出ARPANET研究计划</p><p>采取分组交换的思想，将ARPANET分为两个部分：<strong>通信子网与资源子网</strong></p><p>开始时，实验网络包含四个节点</p><p>在计算机网络发展的不同阶段，人们对计算机网络有不同的定义，这些定义主要分为三类：广义、资源共享与用户透明性。其中资源共享的定义符合当前计算机网络的基本特征，主要表现为三点：</p><p>（1）建立计算机网络的主要目的是<strong>实现计算机资源的共享</strong>；</p><p>（2）互联的计算机是分布在不同地理位置的多台独立的“自治计算机”，<strong>互联的计算机之间没有明确的主从关系</strong>。</p><p>（3）联网计算机之间的通信<strong>必须遵循共同的网络协议</strong>。</p><h3 id="1-2-2-计算机网络的分类"><a href="#1-2-2-计算机网络的分类" class="headerlink" title="1.2.2 计算机网络的分类"></a>1.2.2 计算机网络的分类</h3><div class="table-container"><table><thead><tr><th>0~10m</th><th>0~10m</th><th>10m~10km</th><th>50km~100km</th><th>10km~1000km</th></tr></thead><tbody><tr><td>个人区域网（WPAN）最有名的为蓝牙</td><td>个人局域网(PAN)</td><td>局域网(LAN)</td><td>城域网(MAN)</td><td>广域网(WAN)</td></tr><tr><td></td><td></td><td>10Mbps~100Gbps</td><td>45~150Mbps</td><td></td></tr><tr><td></td><td></td><td></td><td>FDDI,介质访问子层令牌环</td><td></td></tr><tr><td>IEEE 802.15</td><td></td><td></td><td>IEEE 802.6</td></tr></tbody></table></div><p>书中各种协议：</p><p><strong>IEEE 802又称为LMSC，致力于研究局域网和城域网的物理层和MAC层中定义的服务和协议，对应OSI网络参考模型的最低两层（数据链路层和物理层），它针对不同的传输介质定义不同的介质标准。</strong></p><p><strong>IEEE 802在介质访问控制（MAC）子层和物理层可以采用不同的协议，但是在逻辑链路控制（LLC）子层必须采用相同的协议，LLC子层与低层采用的传输介质，介质访问控制方法无关</strong></p><p><strong>IEEE 802.11</strong> 是无线局域网(WLAN)的介质访问控制协议以及物理层技术规范</p><p>IEEE 802.11标准采用的是层次结构模型，主要工作在OSI参考模型的最低两层：物理层和数据链路层。最初定义的三个物理层传输标准包括两个扩散频谱技术和一个红外传播规范。IEEE 802.11标准规定的MAC层是在一个共享媒体上支持多个用户共享资源，发送数据前需要进行<strong>冲突检测</strong>，访问控制支持<strong>无争用服务和争用服务两种</strong>方式。</p><div class="table-container"><table><thead><tr><th style="text-align:left">标准名称</th><th style="text-align:left">标准描述</th></tr></thead><tbody><tr><td style="text-align:left">802.11a</td><td style="text-align:left">5G Hz波段，速率54Mbps</td></tr><tr><td style="text-align:left">802.11b</td><td style="text-align:left">2.4G Hz波段，速率11Mbps</td></tr><tr><td style="text-align:left">802.11g</td><td style="text-align:left">2.4G Hz波段，速率54Mbps</td></tr><tr><td style="text-align:left">802.11n</td><td style="text-align:left">5G Hz波段，速率100Mbps</td></tr><tr><td style="text-align:left">802.11ac</td><td style="text-align:left">5G Hz波段，速率1Gbps</td></tr><tr><td style="text-align:left">802.11ad</td><td style="text-align:left">60G Hz波段，速率7Gbps</td></tr><tr><td style="text-align:left">802.11i</td><td style="text-align:left">增强无线通信安全的规范</td></tr><tr><td style="text-align:left">802.11e</td><td style="text-align:left">服务质量QoS</td></tr></tbody></table></div><p><strong>IEEE 802.1</strong>局域网体系结构，网络互联，以及网络管理与性能测试</p><p><strong>IEEE 802.11</strong> 是无线局域网(WLAN)的访问控制子层以及物理层技术规范</p><p><strong>IEEE 802.15</strong> 采用蓝牙技术（近距离）的无线个人网络技术规范</p><p><strong>IEEE802.16</strong> 定义<strong>宽带无线局域网</strong>介质访问 MAC 子层与物理层标准</p><p><strong>IEEE 802.2</strong>逻辑链路控制LLC子层功能与服务</p><p><strong>IEEE802.3</strong> 定义MAC层载波侦听多路访问 （CSMA/CD ） 介质访问控制子层与物理层标准</p><p><strong>IEEE802.4</strong> 定义了总线拓扑的令牌总线介质访问控制方法与相应的物理规范</p><p>无线局域网标准802.11的MAC和802.3协议的MAC不同，传统的Ethernet网帧的结构中有前导码和帧前定界符，而802.11标准中用帧控制单元代替。传统的Ethernet网的数据段长度是46B~1500B，而802.11帧中的数据段长度是0~2312B。传统的Ethernet网中帧的类型字段表示当前帧使用协议的类型，而802.11帧中类型字段用来表示当前帧是数据帧、管理帧或控制帧。这两种帧均工作在数据链路层，<strong>采用的地址是MAC地址。</strong></p><p>高速局域网技术：</p><div class="table-container"><table><thead><tr><th>标准</th><th>类型</th><th>速率</th></tr></thead><tbody><tr><td>IEEE802.3u</td><td>Fast Ethernet</td><td>100Mbps</td></tr><tr><td>IEEE802.3z</td><td>Gigabit Ethernet</td><td>1000Mbps</td></tr><tr><td>IEEE802.3ae</td><td>10 Gigabit Ethernet</td><td>10Gbps</td></tr><tr><td>IEEE802.3ba</td><td>40&amp;100 Gigabit Ethernet</td></tr></tbody></table></div><h3 id="1-2-3-计算机网络的拓扑结构"><a href="#1-2-3-计算机网络的拓扑结构" class="headerlink" title="1.2.3 计算机网络的拓扑结构"></a>1.2.3 计算机网络的拓扑结构</h3><ol><li><p>星型结构</p><p>结构简单易于实现便于管理</p><p>网络中心节点是全网性能与可靠性的瓶颈，中心节点的故障可能造成全网瘫痪</p></li><li><p>环形拓扑</p><p>结构简单，<strong>传输延时确定</strong></p><p>环中每个节点与连接点之间通信线路都会成为网络可靠性瓶颈。</p></li><li><p>总线型拓扑</p><p>当一个节点利用总线发送数据时，其他节点只能接收数据</p><p>当有两个或者多个节点同时发送数据时，都会出现冲突，造成传输失败</p><p>缺点：必须解决多节点访问总线的介质访问控制问题</p></li><li><p>树形拓扑</p><p>节点按层次连接，信息交换在上下节点之间进行，相邻以及同层节点之间通信通常不进行数据交换</p><p><strong>树型通常用来汇聚信息</strong></p></li><li><p>网状拓扑</p><p>连接任意<strong>没有规律</strong>，又称为无规则型拓扑</p><p><strong>可靠性高</strong>，<strong>广域网一般采用网状拓扑</strong></p><p><strong>结构复杂</strong>，必须采用路由选择算法，流量控制与拥塞控制</p></li></ol><h3 id="1-2-4-描述计算机网络传输特性的参数"><a href="#1-2-4-描述计算机网络传输特性的参数" class="headerlink" title="1.2.4 描述计算机网络传输特性的参数"></a>1.2.4 描述计算机网络传输特性的参数</h3><ol><li><p>数据传输速率的定义</p><ul><li><p>速率为：$S=\frac{1}{T}(bps)$其中T为发送1比特所需要的时间</p></li><li><p>对于二进制数据信号的最大数据传输速率$R<em>{max}$与通信信道带宽B(B=f,单位Hz)的关系可以写为：$R</em>{max}=2\times f(bps)$</p></li></ul></li><li><p>误码率的定义</p><p>误码率指二进制码元在数据传输系统中被传错的概率数值上近似等于：$P<em>{e}=\frac{N</em>{e}}{N}$,其中N为传输的二进制码元总数，$N_{e}$为被传错的码元数</p><p>注意：</p><ol><li>误码率是<strong>正常工作状态</strong>下的传输可靠性参数</li><li>对于实际的数据传输系统，不能笼统说误码率越低越好，因为<strong>误码率越低造价越高</strong></li><li>如果传输的不是二进制码元，<strong>折合成二进制码元计算</strong></li><li>由于差错有随机性，实际测量<strong>需要传输二进制码元数越大，才会越接近真实值</strong></li></ol></li></ol><h3 id="1-3-3-数据报交换与虚电路交换"><a href="#1-3-3-数据报交换与虚电路交换" class="headerlink" title="1.3.3 数据报交换与虚电路交换"></a>1.3.3 数据报交换与虚电路交换</h3><ol><li><p><strong>数据报方式</strong></p><p><strong>分组传输方式中，分组传输不需要在源主机与目的主机之间预先建立“线路连接”</strong></p><p>源主机发送的每个分组都可以独立选择一条传输路径，<strong>每个分组在通信子网中可能通过不同的路径到达目的主机</strong></p><p>数据报方式有以下几个特点：</p><ul><li>同一个报文不同分组可以通过<strong>不同路径</strong>通过通信子网</li><li>同一个报文的不同分组到达目的主机是可能会出现<strong>乱序，重复与丢失的现象</strong></li><li>数据传输方式的<strong>传输延时较大</strong>，<strong>适用于突发性通信，不适用于长报文，会话式通信</strong></li></ul></li><li><p><strong>虚电路方式</strong></p><p>发送分组前，发送方和接收方需要建立一条逻辑连接的虚电路</p><p>虚电路方式具有以下几个特点：</p><ul><li>在每次传输分组前，<strong>在源主机和目的主机之间建立一条虚电路</strong></li><li>所有分组都通过虚电路顺序传输，分组<strong>不必携带目的地址，源地址</strong>等信息，分组到达目的主机是<strong>不会出现乱序重复与丢失</strong></li><li>分组通过虚电路每个路由器时，路由器<strong>只需要进行差错检查，而不需要进行路由选择</strong></li><li>路由器可以<strong>与多个主机之间通信建立多条虚电路</strong></li></ul></li></ol><h2 id="1-4-网络体系结构与网络协议"><a href="#1-4-网络体系结构与网络协议" class="headerlink" title="1.4 网络体系结构与网络协议"></a>1.4 网络体系结构与网络协议</h2><h3 id="1-4-1-网络体系结构的概念"><a href="#1-4-1-网络体系结构的概念" class="headerlink" title="1.4.1 网络体系结构的概念"></a>1.4.1 网络体系结构的概念</h3><p>网络协议是由三个要素组成：</p><ol><li><p><strong>语法</strong>。语法是用户数据与控制信息的<strong>结构与格式</strong>，以及数据出现的<strong>顺序</strong>。</p></li><li><p><strong>语义</strong>。语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及<strong>完成的动作与做出什么样的响应</strong>。</p></li><li><p><strong>时序</strong>。时序是对事件<strong>发生顺序</strong>的详细说明。（也可称为“同步”）</p></li></ol><p>人们形象地把这三个要素描述为：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。</p><h3 id="1-4-2-ISO-OSI-参考模型"><a href="#1-4-2-ISO-OSI-参考模型" class="headerlink" title="1.4.2 ISO/OSI 参考模型"></a>1.4.2 ISO/OSI 参考模型</h3><p>TCP协议运行在传输层，IP在网络层，http在应用层</p><p><strong>同一个节点下层为上层提供服务，相邻层通过接口通信</strong></p><p>不同节点同等层之间通过通信协议通信</p><p>各层实现技术互不影响  </p><div class="table-container"><table><thead><tr><th>ISO/OSI 参考模型</th><th>功能</th><th>该层的设备与协议</th></tr></thead><tbody><tr><td><strong>物理层</strong></td><td><strong>物理连接，比特流传输，单位为比特流</strong></td><td>IEEE 802，中继器，网线，集线器</td></tr><tr><td><strong>数据链路层</strong></td><td><strong>建立数据链路连接，差错控制，流量控制</strong></td><td>网卡，二层交换机、网桥</td></tr><tr><td><strong>网络层</strong></td><td><strong>路由选择，流量控制，拥塞控制，网络互联</strong></td><td>路由器，RIP,OSPF，IP，ICMP，IGMP，包过滤路由器</td></tr><tr><td><strong>传输层</strong></td><td><strong>端到端连接与数据传输，单位为报文</strong></td><td>TCP,UDP，NAT</td></tr><tr><td><strong>会话层</strong></td><td><strong>会话主机之间的建立，管理和终止，数据交换</strong></td><td></td></tr><tr><td><strong>表示层</strong></td><td><strong>数据格式变换，加密解密，压缩恢复</strong></td><td></td></tr><tr><td><strong>应用层</strong></td><td><strong>通信过程控制</strong></td><td>Telnet,FTP,SNMP,HTTP，SIP，CMIP</td></tr></tbody></table></div><p><strong>调制解调器</strong>是一种硬件，它能把计算机的数字信号翻译成模拟信号。</p><p><strong>集线器</strong>的主要功能是对接收到的信号进行再生、整形、放大，以扩大网络的传输距离，同时把所有结点集中在以它为中心的结点上。</p><p><strong>中继器</strong>是网络物理层上面的连接设备，适用于完全相同的两类网络的互连，主要功能是通过对数据信号的重新发送或者转发，来扩大网络传输的距离。</p><p><strong>路由器</strong>是使用在网络层的互连设备，可以实现异构网络互联，是网络与网络之间连接的桥梁。</p><p>TCP（传输控制协议）协议是一种<strong>面向连接</strong>的、可靠的、<strong>基于IP的传输层协议</strong>。TCP使用三次握手协议建立连接，而终止一个连接要经过四次握手。RTT（Round Trip Time）表示从发送端到接收端的一去一回需要的时间，TCP在数据传输过程中会<strong>对RTT进行采样，采用自适应的RTT计算方法</strong>。TCP协议利用窗口机制进行流量控制，端口采用<strong>16位的二进制数</strong>表示。</p><h3 id="1-4-3-TCP-IP-参考模型"><a href="#1-4-3-TCP-IP-参考模型" class="headerlink" title="1.4.3 TCP/IP 参考模型"></a>1.4.3 TCP/IP 参考模型</h3><p>由IETF制定</p><p>独立于特定的网络硬件</p><div class="table-container"><table><thead><tr><th>TCP/IP 参考模型</th><th>功能</th><th>安全协议</th></tr></thead><tbody><tr><td><strong>主机-网络层</strong></td><td><strong>发送，接收IP分组</strong></td><td>PPTP,L2TP,L2F</td></tr><tr><td><strong>互联网络层/互联层</strong></td><td><strong>处理传输层的数据发送请求，处理接收分组，路由选择，流量控制，拥塞控制</strong></td><td>IPSec</td></tr><tr><td><strong>传输层</strong></td><td><strong>建立维护端到端连接，实现网络环境分布式进程通信</strong></td><td>SSH，SSL，SOCKS,TLS</td></tr><tr><td><strong>应用层</strong></td><td><strong>包括各种标准协议</strong></td><td>SET,PGP,S-HTTP,S/MIME</td></tr></tbody></table></div><h3 id="1-4-4-OSI参考模型与TCP-IP参考模型的比较"><a href="#1-4-4-OSI参考模型与TCP-IP参考模型的比较" class="headerlink" title="1.4.4 OSI参考模型与TCP/IP参考模型的比较"></a>1.4.4 OSI参考模型与TCP/IP参考模型的比较</h3><table><tbody><tr><td>            <p><strong>TCP/IP&nbsp;</strong></p>            </td>            <td>            <p><strong>OSI参考模型</strong></p>            </td>        </tr><tr><td rowspan="3">            <p>应用层</p>            </td>            <td>            <p>应用层</p>            </td>        </tr><tr><td>            <p>表示层</p>            </td>        </tr><tr><td>            <p>会话层</p>            </td>        </tr><tr><td>            <p>传输层</p>            </td>            <td>            <p>传输层</p>            </td>        </tr><tr><td>            <p>互联/网络互联层</p>            </td>            <td>            <p>网络层</p>            </td>        </tr><tr><td rowspan="2">            <p>主机-网络层</p>            </td>            <td>            <p>数据链路层</p>            </td>        </tr><tr><td>            <p>物理层</p>            </td>        </tr></tbody></table><h1 id="第二章-局域网基础"><a href="#第二章-局域网基础" class="headerlink" title="第二章 局域网基础"></a>第二章 局域网基础</h1><p>局域网从介质访问控制方式的角度可以分为<strong>共享介质局域网</strong>与<strong>交换局域网</strong>。</p><p><strong>共享介质局域网</strong>中所有的结点共享一条公共的传输介质，通过广播的方式发送数据帧，并采用CSMA/CD(带有冲突检测的载波侦听多路访问)方法解决冲突问题，连接在总线上的所有结点都能“收听”到数据。由于所有结点都可以利用总线发送数据，并且在网络中没有控制中心，隐藏冲突的发生将不可避免。</p><p><em>CSMA/CA(Carrier Sense Multiple Access with Collision Avoid<strong>,载波侦听多路访问／冲突避免</strong>)是无线局域网标准IEEE 802.11使用的一种介质访问控制方法，工作在MAC层。该方法要求每个结点在发送帧之前先侦听信道，如果空闲则可以发送帧，如果没有收到发回帧的确认ACK则表明该帧发送出现冲突，即发送失败，则在规定的帧间隔时间内不能再发送帧，只有超过了帧间隔时间才可以发送帧。常见的帧间间隔IFS有三种，短帧间间隔（SIFS）,点帧间间隔（PIFS），和分布帧间间隔（DIFS）,短帧间间隔用于分隔属于一次对话的各帧，MAC层支持无征用服务和征用服务两种访问方式，没有类似以太网的冲突检测机制，不能完全避免冲突的发生</em></p><h3 id="2-1-2-介质访问控制方法的比较"><a href="#2-1-2-介质访问控制方法的比较" class="headerlink" title="2.1.2 介质访问控制方法的比较"></a>2.1.2 介质访问控制方法的比较</h3><p>局域网按照介质访问控制方法分类：</p><ol><li><p><strong>采用带有冲突检测的载波侦听多路访问(Carrier Sense Multiple Access/Collision Detection,CSMA/CD)访问控制方法的总线形Ethernet，简称以太网</strong></p><p><strong>总线形，广播方式，两个及以上发送数据会发生冲突，随机型介质访问</strong></p><p>总线型局域网的主要特点：</p><p>（1）所有结点都通过网卡连接到作为公共介质的总线上。</p><p>（2）<strong>总线通常采用双绞线或同轴电缆作为传输介质。</strong></p><p>（3）所有的结点都可以发送或接收数据，<strong>但在一段时间内只允许一个结点通过总线发送数据（即但双工形式）</strong>。当一个结点通过总线以“广播”方式发送数据时，其他结点只能以“收听”方式接收数据。</p><p>（4）由于总线作为公共传输介质被多个结点共享，因此会出现冲突现象。</p></li><li><p>采用令牌控制的令牌总线形(Token Bus)局域网，简称“Token Bus”或“令牌总线网”</p><p><strong>总线形，取得令牌才能使用共享总线发送数据，令牌持有时间(Token Holding Time,THT)为10ms，控制访问数量实时性可以得到保证</strong></p></li><li><p>采用令牌控制的令牌环形(Token Ring)局域网，简称“Token Ring”或”令牌环网“</p><p><strong>环形，沿一个方向传输，发送数据间隔固定，提供有限服务，适用于重负载的应用领域</strong></p></li></ol><p>传输介质主要为同轴电缆，双绞线，光纤</p><p>采用共享介质发送接收数据帧</p><p>介质访问控制采用分布式控制方法，没有集中控制的主机</p><h2 id="2-2-共享介质局域网技术"><a href="#2-2-共享介质局域网技术" class="headerlink" title="2.2 共享介质局域网技术"></a>2.2 共享介质局域网技术</h2><h3 id="2-2-1-Ethernet工作原理"><a href="#2-2-1-Ethernet工作原理" class="headerlink" title="2.2.1 Ethernet工作原理"></a>2.2.1 Ethernet工作原理</h3><p>CSMA/CD：先听后发(先侦听是否空闲)，边听边发，冲突停止，<strong>延迟</strong>重发</p><h3 id="2-2-2-Ethernet帧结构"><a href="#2-2-2-Ethernet帧结构" class="headerlink" title="2.2.2 Ethernet帧结构"></a>2.2.2 Ethernet帧结构</h3><ol><li>Ethernet V2.0和IEEE802.3的Ethernet帧结构区别</li></ol><p><img src="计算机网络.assets/1232796-20171017084041287-1347335048.png" alt="img"></p><p>​    <strong>具体异同见书本</strong></p><p>​    主要字段：<strong>前导码字段，目的地址和源地址字段，类型字段，数据字段，帧校验字段</strong></p><ol><li><p>Ethernet帧结构分析</p><ol><li><p>前导码字段</p><p><strong>8B</strong>的10101010….101010比特序列组成，前导码的作用是实现收发双方的比特同步与帧同步。在接收后不需要保留，也不计入帧头的长度中</p></li><li><p>目的地址和源地址字段</p><p>目的地址和源地址分别表示帧的接收主机与发送主机的硬件地址，地址长度为6B，<strong>源地址必须是48b的MAC地址</strong>，目的地址可以是单播地址，多播地址或广播地址</p></li><li><p>类型字段</p><p>表示<strong>网络层</strong>使用的协议类型</p></li><li><p>数据字段</p><p>数据字段是网络层发送的数据部分，<strong>长度在46~1500B之间</strong>，<strong>因此Ethernet帧的最小长度为46~1500B+18B=64~1518B</strong></p></li><li><p>校验字段</p><p>采用CRC校验，<strong>32位，4B</strong></p></li></ol></li></ol><h3 id="2-2-3-Ethernet网卡与物理地址"><a href="#2-2-3-Ethernet网卡与物理地址" class="headerlink" title="2.2.3 Ethernet网卡与物理地址"></a>2.2.3 Ethernet网卡与物理地址</h3><ol><li><p>Ethernet 网卡与物理地址</p><p><strong>网卡包含发送与接收信号的收发器，曼彻斯特编码与解码器，Ethernet数据链路控制，组帧与拆帧软件，与主机的接口</strong></p></li><li><p>Etherne物理地址</p><p>48位的地称为EUI-48，允许分配的Ethernet物理地址应为$2^{47}$个，<strong>IEEE为每个网卡厂商分配Ethernet物理地址的前三位，后三位字节由厂商自行分配</strong>。当网卡厂商获得前三位后它可以生产的网卡数量为$2^{24}$块，表示方法为两个十六进制之间用一个连字符隔开，如02-01-00-2A-10-C3</p><p>48位全1的地址成为广播地址</p></li></ol><h3 id="2-2-4-Ethernet-组网方法"><a href="#2-2-4-Ethernet-组网方法" class="headerlink" title="2.2.4 Ethernet 组网方法"></a>2.2.4 Ethernet 组网方法</h3><ol><li><p>Ethernet物理层标准</p><p>| 标准               | 速率   | 基带传输 |            | 最大长度 |<br>| ————————— | ——— | ———— | ————— | ———— |<br>| IEEE802.3 10BASE-5 | 10Mbps | 是       | 粗同轴线缆 | 500m     |<br>| IEEE802.3 10BASE-2 | 10Mbps | 是       | 细同轴线缆 | 200m     |<br>| IEEE802.3 10BASE-T | 10Mbps | 是       | 双绞线     | ？       |</p><p>字段总结：</p><p>10:10Mbps </p><p>5:500m 2:200m</p><p>T:<em>双绞线（twisted pair，TP）</em></p></li></ol><h2 id="2-3-交换式局域网与虚拟局域网"><a href="#2-3-交换式局域网与虚拟局域网" class="headerlink" title="2.3 交换式局域网与虚拟局域网"></a>2.3 交换式局域网与虚拟局域网</h2><h3 id="2-3-1-交换式局域网技术"><a href="#2-3-1-交换式局域网技术" class="headerlink" title="2.3.1 交换式局域网技术"></a>2.3.1 交换式局域网技术</h3><p>交换式以太网的<strong>核心设备是以太网交换机</strong>，它从根本上改变了“共享介质”的工作方式，<strong>可以在多个端口之间建立多个并发连接</strong>，实现多结点之间数据的并发传输，从而可以增加网络带宽，改善局域网的性能与服务质量，避免数据传输冲突的发生。<strong>以太网交换机利用“端口/MAC地址映射表”进行数据帧交换</strong>。</p><h2 id="2-4-高速局域网技术发展"><a href="#2-4-高速局域网技术发展" class="headerlink" title="2.4 高速局域网技术发展"></a>2.4 高速局域网技术发展</h2><h3 id="2-4-1-Fast-Ethernet"><a href="#2-4-1-Fast-Ethernet" class="headerlink" title="2.4.1 Fast Ethernet"></a>2.4.1 Fast Ethernet</h3><p>保留传统的Ethernet帧格式</p><p>介质专用接口（Media Indepandent Interface,MII）将ＭＡＣ子层与物理层分开</p><div class="table-container"><table><thead><tr><th>标准</th><th>材料</th><th>双功</th></tr></thead><tbody><tr><td>100BASE-TX</td><td>两对5类非屏蔽双绞线（UTP）或两对1类屏蔽双绞线（STP）一对用于发送一对用于接收</td><td>全双工</td></tr><tr><td><strong>100BASE-T4</strong></td><td><strong>四对3类非屏蔽双绞线UTP，三对用于数据传输，1对用于冲突检测</strong></td><td><strong>半双工</strong></td></tr><tr><td>100BASE-FX</td><td>2芯单模或多模光纤</td><td>全双工</td></tr></tbody></table></div><p><em>光纤fiber</em></p><h3 id="2-4-2-Gigabit-Ethernet"><a href="#2-4-2-Gigabit-Ethernet" class="headerlink" title="2.4.2 Gigabit Ethernet"></a>2.4.2 Gigabit Ethernet</h3><p>保留传统的Ethernet帧格式</p><p>千兆介质专用接口（Gigabit Media Indepandent Interface,GMII）将MAC，子层与物理层分开</p><div class="table-container"><table><thead><tr><th>标准</th><th>材料</th><th>最大长度</th></tr></thead><tbody><tr><td>1000BASE-CX</td><td>两对屏蔽双绞线</td><td>25m</td></tr><tr><td>1000BASE-T</td><td>4对5类非屏蔽双绞线</td><td>100m</td></tr><tr><td>1000BASE-SX</td><td>多模光纤</td><td>550m</td></tr><tr><td>1000BASE-LX</td><td>单模光纤</td><td>5km</td></tr><tr><td>1000BASE-LH</td><td>单模光纤</td><td>10km</td></tr><tr><td>1000BASE-ZX</td><td>单模光纤</td><td>70km</td></tr></tbody></table></div><h3 id="2-4-3-10-Gigabit-Ethernet"><a href="#2-4-3-10-Gigabit-Ethernet" class="headerlink" title="2.4.3 10 Gigabit Ethernet"></a>2.4.3 10 Gigabit Ethernet</h3><p>保留传统的Ethernet帧格式</p><p>介质专用接口（10 Gigabit Media Indepandent Interface,10GMII）将MAC子层与物理层分开</p><p>不再采用传统的CSMA/CD协议，使10GbE的覆盖范围不受传统的Ethernet网的冲突窗口限制，传输距离仅仅由光纤通信系统的性能</p><div class="table-container"><table><thead><tr><th>标准</th><th>材料</th><th>最大长度</th></tr></thead><tbody><tr><td>10GBASE-SR</td><td>多模光纤</td><td>300m</td></tr><tr><td>10GBASE-LRM</td><td>多模光纤</td><td>220m</td></tr><tr><td>10GBASE-LX4</td><td>单模光纤</td><td>10km</td></tr><tr><td>10GBASE-LR</td><td>单模光纤</td><td>25km</td></tr><tr><td>10GBASE-ER</td><td>单模光纤</td><td>40km</td></tr><tr><td>10GBASE-ZR</td><td>单模光纤</td><td>80km</td></tr></tbody></table></div><p><strong>10 Gigabit Ethernet都是全双工，只支持光纤</strong></p><h3 id="2-5-6-IEEE-802-11帧结构"><a href="#2-5-6-IEEE-802-11帧结构" class="headerlink" title="2.5.6 IEEE 802.11帧结构"></a>2.5.6 IEEE 802.11帧结构</h3><ol><li><p>管理帧</p><p>定义了14种帧，如<strong>信标帧，探测帧，关联帧，认证帧</strong></p></li><li><p>控制帧</p><p>定义了9种帧，如<strong>RTS，CTS，ACK帧</strong></p></li><li><p>数据帧</p></li></ol><h2 id="2-5-无线局域网技术"><a href="#2-5-无线局域网技术" class="headerlink" title="2.5 无线局域网技术"></a>2.5 无线局域网技术</h2><h3 id="2-5-1-无线局域网的发展"><a href="#2-5-1-无线局域网的发展" class="headerlink" title="2.5.1 无线局域网的发展"></a>2.5.1 无线局域网的发展</h3><p>IEEE802.11 由IEEE为无线局域网制定的标准，是无线局域网<strong>介质访问控制</strong>方法</p><p>采用了<strong>层次结构模型</strong></p><p>物理层定义了以<strong>微波，激光与红外线</strong>等<strong>无线电波</strong>作为传输介质</p><p>MAC层主要功能是对无线环境进行访问控制，可以在多个接入点上提供漫游支持，同时提供数据验证与保密服务</p><p>MAC层支持无争用与争用服务两种访问方式</p><p>应用领域：<strong>传统局域网的扩充</strong>，建筑物之间互联，移动主机漫游访问，无线自组网</p><p>支持基于漫游访问(Nomadic Access)和无线访问接入点(Wireless Access Point,AP)访问模式，也可以通过对等P2P方式实现漫游</p><p>虚拟局域网（Virtual LAN，VLAN）是建立在局域网的基础上，以软件形式在局域网交换机上实现逻辑工作组的划分与管理，工作组中的结点不受物理位置的限制。</p><p>虚拟局域网的组网方法包括：用<strong>交换机端口</strong>定义虚拟局域网、用<strong>MAC地址</strong>定义虚拟局域网、用<strong>网络层地址</strong>定义虚拟局域网、基于<strong>广播组</strong>的虚拟局域网。<br>虚拟局域网的优点有：<strong>方便网络用户管理，减少网络管理开销、提供更好的安全性、改善网络服务质量</strong>。</p><h3 id="2-5-2-扩频无线局域网"><a href="#2-5-2-扩频无线局域网" class="headerlink" title="2.5.2 扩频无线局域网"></a>2.5.2 扩频无线局域网</h3><ol><li><p>扩频通信的概念</p><p>无线局域网主要采用两种扩频技术：<strong>跳频扩频与直接序列扩频</strong></p><p>IEEE 802.11规定：</p><p>跳频通信使用<strong>2.4GHZ的工业、科学与医药专用的ISM频段</strong>。</p><p>直接序列扩频的<strong>所有接收点使用相同的频段，发送端与接收端使用相同的伪随机码，使用2.4GHz的ISM频段，数据传输速率为1Mbps或2Mbps,发送前需要调制</strong>。</p></li></ol><h3 id="2-5-4-无线局域网拓扑结构"><a href="#2-5-4-无线局域网拓扑结构" class="headerlink" title="2.5.4 无线局域网拓扑结构"></a>2.5.4 无线局域网拓扑结构</h3><p>端站使用无线网卡，将计算机或嵌入设备接入WLAN，接入点AP按照无线接口标准使用无线链路与端站进行通信，接入控制器AC在WLAN与外部网络之间充当网关的作用，AAA服务器又称为RADIUS用户认证服务器，负责完成用户认证授权和计费功能，IEEE802.11认证有三种认证方式：基于IEEE802.1x的认证，基于PPPoE的认证和基于Web的认证</p><ol><li><p>独立基本服务集</p><p>Ad hoc 具有以下几个主要特点：<strong>自组织与自修复，无中心，多跳路由，动态拓扑,对等式，无线网络，无基站</strong></p></li></ol><h3 id="2-5-4-IEEE-802-11-帧结构"><a href="#2-5-4-IEEE-802-11-帧结构" class="headerlink" title="2.5.4 IEEE 802.11 帧结构"></a>2.5.4 IEEE 802.11 帧结构</h3><p>IEEE 802.11帧采用<strong>2字节（16b）</strong>作为帧控制字段，帧中目的地址和源地址使用MAC地址，数据字段最大长度是2312字节。帧校验字段长度为4字节，采用CRC校验，校验范围为<strong>MAC帧头与数据域</strong>。类型字段的类型标识数据帧、管理帧或控制帧。</p><p>IEEE802.11协议定义了三种帧结构：管理帧，控制帧，数据帧</p><ol><li><p>管理帧</p><p>定义了14种管理帧，例如信标帧，探测帧，关联帧，认证帧，用于无线主机与AP之间的连接</p></li><li><p>控制帧</p><p>定义了9种控制帧，对预约信道，对单播数据帧的确认，RTS，CTS,ACK都属于控制帧</p></li><li><p>数据帧</p><p>数据帧由三个部分组成：帧头，数据字段，帧尾，<strong>其中帧头长30B,数据字段长0~2312B,帧尾由2B的帧校验字段组成</strong></p></li></ol><p>无线局域网标准802.11的MAC和802.3协议的MAC不同，传统的Ethernet网帧的结构中有前导码和帧前定界符，而802.11标准中用帧控制单元代替。传统的Ethernet网的数据段长度是<strong>46B~1500B</strong>，而802.11帧中的数据段长度是<strong>0~2312B</strong>。传统的Ethernet网中帧的类型字段表示当前帧使用协议的类型，而802.11帧中类型字段用来表示当前帧是数据帧、管理帧或控制帧。<strong>这两种帧均工作在数据链路层，采用的地址是MAC地址</strong>。</p><h1 id="第三章-Internet基础"><a href="#第三章-Internet基础" class="headerlink" title="第三章 Internet基础"></a>第三章 Internet基础</h1><p>Internet的使用者不必关心Internet的内部结构；路由器是网络与网络之间连接的<strong>桥梁</strong>；主机是Internet中不可缺少的成员，它是<strong>信息资源和服务的载体</strong>。</p><h3 id="3-1-2-Internet的接入方式"><a href="#3-1-2-Internet的接入方式" class="headerlink" title="3.1.2 Internet的接入方式"></a>3.1.2 Internet的接入方式</h3><ol><li><p>通过电话线接入</p></li><li><p>利用ADSL接入</p><p>利用<strong>非对称数字用户线</strong></p><p><strong>使用比较复杂的调制解调技术</strong>，在<strong>普通电话线</strong>上进行高速数据传输</p><p>分上行和下行两个通道，下行通道数据传输远大于上行，<strong>上行16~640kbps，下行速率可达1.5~9Mbps</strong></p></li><li><p>使用HFC接入</p><p><strong>共享式传输</strong></p><p><strong>信号首先通过光纤传输到光纤节点然后通过同轴电缆传输到有线电视网用户</strong></p><p>混合光纤/同轴电缆线（Hybrid Fiber Coaxial，HFC），同ADSL为非对称连接，<strong>上行速率达到10Mbps,下行10~40Mbps</strong></p></li><li><p>通过数据通信线路接入</p></li></ol><h3 id="3-2-2-IP服务"><a href="#3-2-2-IP服务" class="headerlink" title="3.2.2 IP服务"></a>3.2.2 IP服务</h3><p>IP协议的互联层可以为其高层用户提供如下服务：</p><ol><li><strong>不可靠</strong>数据投递服务</li><li><strong>面向无连接</strong>的传输服务</li><li><strong>尽最大努力</strong>投递服务</li></ol><p>IP协议精确定义了<strong>IP数据报格式</strong>，并且<strong>对数据报寻址和路由、数据报分配和重组、差错控制和处理</strong>等做出了具体的规定。</p><h3 id="3-2-3-IP互联网的特点"><a href="#3-2-3-IP互联网的特点" class="headerlink" title="3.2.3 IP互联网的特点"></a>3.2.3 IP互联网的特点</h3><ul><li><strong>隐藏了底层物理网络的细节</strong>，向上为用户提供通用一致的网络服务</li><li>IP互联网<strong>不指定网络互联的拓扑结构</strong>，也<strong>不要求网络之间的全互联</strong></li><li>IP互联网<strong>能在物理网络之间转发数据</strong>，信息可以跨网传输</li><li>IP互联网中所有计算机使用<strong>统一的，全局的地址描述法</strong></li><li>IP互联网<strong>平等地对待</strong>互联网中的每一个网络，不管这个网络规模是大是小，速度是快是慢</li></ul><h2 id="3-4-IP数据报"><a href="#3-4-IP数据报" class="headerlink" title="3.4 IP数据报"></a>3.4 IP数据报</h2><p>IP数据报是IP协议单元使用的数据单元，它的格式可以<strong>分为报头区和数据区两大部分</strong>，其中数据区包括高层需要传输的数据，而报头区是为了正确传输高层数据而增加的控制信息。报头区主要包括：<strong>版本与协议类型域、长度域、服务类型域、生存周期域、头部校验和域、地址域、选项+填充域</strong>。其中<strong>报头长度域以32位的双字为单位</strong>；<strong>生存周期（Time to Live，TTL）域用于防止数据报在Internet中无休止地传递</strong>；<strong>头部校验和域用来保证IP数据报报头的完整性</strong>；<strong>选项域主要用于控制和测试两大目的</strong>。</p><h3 id="3-4-2-IP封装分片与重组"><a href="#3-4-2-IP封装分片与重组" class="headerlink" title="3.4.2 IP封装分片与重组"></a>3.4.2 IP封装分片与重组</h3><ol><li><p>MTU与分片</p><p>每种网络都规定了一个帧最多能携带的数据量，这一限制成为<strong>最大传输单元（Maximum Transmission Unit,MTU）</strong>因此一个IP数据报只有小于等于一个网络的MTU才能在这个网络进行传播</p><p>当一个数据报尺寸大于将发往的网络的MTU时，路由器会将IP数据报分成若干较小的部分，称为<strong>分片</strong>，然后再将每片独立地进行发送</p></li><li><p>重组</p><p>IP协议规定，<strong>只有最终的目的主机才可以对分片进行重组</strong></p><p>当转发一个IP数据报的时候，路由器不需要知道它是不是一个分片，其次路由器可以为每个分片独立选择路由，每个分片达到目的地所经过的路径可以不同</p></li><li><p>分片控制</p><p>在IP数据报中，<strong>标识，标志和片偏移</strong>三个字段与控制分片与重组有关</p><p>标识是主机赋予IP数据报的标识符，分片时该域必须不加修改地复制到新分片头的报头中</p><p>标志告诉主机该数据报是否已经分片，是否是最后一个分片</p><p>片偏移是本片数据在初始IP数据报数据区中的位置，<strong>位置偏移量以８个字节为单位</strong>，重组的分片顺序由片偏移提供</p></li></ol><p>分片后<strong>标识和目的地址一定和原数据报中字段相同</strong></p><h3 id="3-4-3-IP数据报选项"><a href="#3-4-3-IP数据报选项" class="headerlink" title="3.4.3 IP数据报选项"></a>3.4.3 IP数据报选项</h3><p>IP选项主要用于控制和测试</p><ol><li><p>源路由</p><p>指IP数据报穿越互联网所经过的路径是由源主机决定的，它区别于由主机或者路由器的IP层软件自行选路后得出的路径</p><p>源路由选项可以分为两类：一类是严格源路由选项，一类是松散路由选项</p><ul><li>严格源路由选项：规定经过的 每一个路由器，相邻的路由器之间不能有中间路由器</li><li>松散路由选项：给出必须经过的要点，不给出完备的路径</li></ul></li><li><p>记录路由</p><p>记录IP数据报从源主机到目的主机之间所经过的路径上的各个路由器的IP地址，记录路由功能可以由IP数据报的记录路由选项完成，利用它可以判断经过的路径</p></li><li><p>时间戳</p><p>记录下IP数据报经过每一个路由器当地时间，用于分析网络吞吐率，拥塞情况，负载情况</p></li></ol><h2 id="3-5-差错报文控制"><a href="#3-5-差错报文控制" class="headerlink" title="3.5 差错报文控制"></a>3.5 差错报文控制</h2><p>IP层使用的控制协议是互联网控制报文协议(Internet Control Message Protocol,ICMP),ICMP不仅用来传输控制报文，而且还用于传输差错报文</p><h3 id="3-5-1-ICMP-差错控制"><a href="#3-5-1-ICMP-差错控制" class="headerlink" title="3.5.1 ICMP 差错控制"></a>3.5.1 ICMP 差错控制</h3><p>ICMP差错报告采用路由器到源主机的模式，所有差错信息都需要想源主机报告。</p><p>特点：</p><ul><li>差错报告<strong>不享受特别优先权和可靠性</strong>，作为一般数据传输，完全可能丢失损坏或者抛弃。</li><li>ICMP差错报告数据中除了<strong>包含故障IP数据报报头</strong>外，还包含<strong>故障IP数据报数据区的前64bit数据</strong>。</li><li>ICMP差错报告是伴随着抛弃出错IP数据报而产生的。</li></ul><p>ICMP差错报告报文共有如下5种。<br>（1）<strong>终点不可达</strong>：分为网络不可达、主机不可达、协议不可达、端口不可达、需要分片但DF比特已置为1、源路由失败等六种情况。<br>（2）<strong>源站抑制</strong>：当路由器或主机由于拥塞而丢弃数据报时，就向<strong>源站</strong>发送源站抑制报文，使源站知道应当将数据报的<strong>发送速率放慢</strong>。<br>（3）<strong>时间超时</strong>：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向<strong>源站</strong>发送时间超时报文。当目的站在预先规定的时间内不能收到一个数据报的全部数据报片时，就<strong>将已收到的数据报片都丢弃</strong>，并向源站发送时间超时报文。<br>（4）<strong>参数问题</strong>：当路由器或目的主机收到的数据报的首部中的字段的值不正确时，就<strong>丢弃该数据报</strong>，并向<strong>源站</strong>发送参数问题报文。<br>（5）<strong>重定向报文</strong>：改变路由（<strong>重定向</strong>）路由器将改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器。ICMP重定向报文机制是为了<strong>保证主机拥有一个动态的、既小且优的路由表</strong>。</p><h2 id="3-6-路由器与路由选择"><a href="#3-6-路由器与路由选择" class="headerlink" title="3.6 路由器与路由选择"></a>3.6 路由器与路由选择</h2><h3 id="3-6-1-表驱动IP选路"><a href="#3-6-1-表驱动IP选路" class="headerlink" title="3.6.1 表驱动IP选路"></a>3.6.1 表驱动IP选路</h3><ol><li>路由表中的特殊路由<ol><li>默认路由：是一种特殊的静态路由，指的是当路由表中与包的目的地址之间没有匹配的表项时路由器能够做出的选择，默认路由会大大简化路由器的配置，减轻管理员的工作负担，提高网络性能。</li><li>特定主机路由：对单个主机指定一条特别的路径就是所谓的特定主机路由，可用于安全性，网络连通性调试及路由表正确性判断等目的</li></ol></li></ol><h3 id="3-6-3-RIP协议与向量-距离算法"><a href="#3-6-3-RIP协议与向量-距离算法" class="headerlink" title="3.6.3 RIP协议与向量-距离算法"></a>3.6.3 RIP协议与向量-距离算法</h3><ol><li><p>RIP协议</p><p>使用Bellman-Ford算法</p><p>RIP协议规定路由器<strong>每30秒</strong>交换一次路由信息</p><p>RIP协议严格准守向量-距离算法</p><p>规定路径超时时间为180秒，相当于6个RIP刷新周期</p></li><li><p>收敛慢的问题及对策</p><ul><li><strong>限制最大距离对策</strong></li><li><strong>水平分割对策</strong></li><li><strong>保持对策</strong></li><li><strong>带触发刷新的毒性逆转对策</strong></li></ul></li></ol><h3 id="3-6-4-OSPF协议与链路-状态算法"><a href="#3-6-4-OSPF协议与链路-状态算法" class="headerlink" title="3.6.4 OSPF协议与链路-状态算法"></a>3.6.4 OSPF协议与链路-状态算法</h3><p>使用最短路径优先算法,<strong>收敛速度比RIP快，计算复杂度比RIP高</strong></p><h3 id="3-6-5-部署和选择路由协议"><a href="#3-6-5-部署和选择路由协议" class="headerlink" title="3.6.5 部署和选择路由协议"></a>3.6.5 部署和选择路由协议</h3><ol><li><p>静态路由</p><p><strong>适用于在小型，单路径，静态的IP互联网环境下使用</strong></p><p>小公司，家庭办公室等小型机构建设的互联网可采用静态路由</p></li><li><p>RIP路由选择协议</p><p><strong>适合小型到中型，多路径，动态IP互联网环境</strong></p><p>中型企业，具有多个网络的大型分支办公室等</p></li><li><p>OSPF路有选择协议</p><p><strong>适合较大型到特大型，多路径，动态的IP互联网环境</strong></p><p>企业，校园，部队，机关等</p></li></ol><h3 id="3-7-1-IP组播的概念和特点"><a href="#3-7-1-IP组播的概念和特点" class="headerlink" title="3.7.1 IP组播的概念和特点"></a>3.7.1 IP组播的概念和特点</h3><ol><li>组播使用组地址。每个组播组拥有唯一的组播地址（<strong>D类地址</strong>）发送方不必知道有哪些成员，他自己不必是组成员，对组成员中主机的数目和位置没有限制</li><li>动态组成员。一个主机（接收方或发送方）可以参加某个特定的组，也可以任意时间退出该组。</li><li>底层硬件支持的组播。以太网本身具有组播的能力，以太网利用硬件进行组播。</li></ol><h3 id="3-7-2-组播技术基础"><a href="#3-7-2-组播技术基础" class="headerlink" title="3.7.2 组播技术基础"></a>3.7.2 组播技术基础</h3><ol><li><p>IP组播地址</p><p>D类地址为组播地址</p></li><li><p>组播的相关协议</p><p><strong>组管理协议：</strong>Internet组管理协议（Internet Group Management Protocol，<strong>IGMP</strong>）和Cisco专用的组管理协议（<strong>CGMP</strong>）。组播路由协议又分为<strong>域内组播路由协议</strong>以及<strong>域间组播路由协议</strong>两类。</p><ul><li>域内组播协议：组播路由算法构造组播分发树，路由器中建立组播路由状态，根据这些状态进行组播数据包转发</li><li>域间组播路由协议：在各自治系统（Autonomous System，AS）间发布具有组播能力的路由信息以及组播源信息，使组播信息能在域间进行转发</li></ul><p><strong>组播路由协议</strong>： 域内组播路由协议包括MOSPF，CBT，PIM-SM、PIM-DM、DVMRP等协议，域内的组播协议又分为密集，与稀疏模式的协议。</p><ul><li><p>DVMRP，PIM-DM，MOSPF属于密集模式</p></li><li><p>CBT，PIM-SM属于稀疏模式。</p></li></ul><p>在域内，主要使用PIM-SM，PIM-DM，DVMRP协议。</p></li></ol><p>组播路由协议是IP组播协议中最核心的功能，组播路由不同于单播路由，他是由源地址，组地址，入接口和出接口列表4部分组成</p><h3 id="3-8-1-IPv4协议的局限性"><a href="#3-8-1-IPv4协议的局限性" class="headerlink" title="3.8.1 IPv4协议的局限性"></a>3.8.1 IPv4协议的局限性</h3><ol><li>地址空间的局限性</li><li>IP协议的性能问题</li><li>IP协议的安全问题</li><li>自动配置问题</li><li>服务质量（QoS）保证问题</li></ol><h3 id="3-8-2-IPv6地址"><a href="#3-8-2-IPv6地址" class="headerlink" title="3.8.2 IPv6地址"></a>3.8.2 IPv6地址</h3><ol><li><p>IPv6地址类型</p><ol><li><p>特殊地址</p><p><strong>全零地址：表示地址不存在</strong></p><p><strong>回送地址：::1</strong></p><p>IPv4兼容的IPv6地址</p><p>映射到IPv4的IPv6地址</p></li></ol></li></ol><h2 id="3-10-NAT的基本工作原理"><a href="#3-10-NAT的基本工作原理" class="headerlink" title="3.10 NAT的基本工作原理"></a>3.10 NAT的基本工作原理</h2><h3 id="3-10-2-NAT的主要技术类型"><a href="#3-10-2-NAT的主要技术类型" class="headerlink" title="3.10.2 NAT的主要技术类型"></a>3.10.2 NAT的主要技术类型</h3><p>主要类型有三种：<strong>静态路由NAT，动态NAT,网络地址端口转换NAPT</strong></p><ol><li><p>静态路由NAT</p><p>网络管理员需要在NAT设备中设置NAT地址映射表，该表确定了一个内部IP地址与一个全局IP地址的对应关系，NAT地址映射表中的内部地址与全局地址一一对应</p></li><li><p>动态NAT</p><p>全局IP地址构成NAT池，当主机通信结束，NAT设备将回收全局IP地址，并删除地址映射表中对应的映射项，以便其他内部主机访问外部网络时使用</p></li><li><p>网络地址端口转换NAPT</p><p>最常使用的NAT类型，利用TCP/UDP的端口号区分NAT地址映射表中的转换条目，可以使内部网络中的多个主机共享一个全局IP地址同时访问外部网络。</p></li></ol><h1 id="第四章-Internet-基本服务"><a href="#第四章-Internet-基本服务" class="headerlink" title="第四章 Internet 基本服务"></a>第四章 Internet 基本服务</h1><h3 id="4-1-1-客户机-服务器模型"><a href="#4-1-1-客户机-服务器模型" class="headerlink" title="4.1.1 客户机/服务器模型"></a>4.1.1 客户机/服务器模型</h3><p>服务器的分类：<strong>重复服务器，并发服务器</strong></p><h2 id="4-2-域名系统"><a href="#4-2-域名系统" class="headerlink" title="4.2 域名系统"></a>4.2 域名系统</h2><p>地址解析系统由一组既独立又协作的域名服务器组成，<strong>域名服务器是解析系统的核心</strong>。域名解析的DNS在实现上也采用<strong>层次化模式</strong>，并与分级结构的域名空间相对应。域名解析方式有<strong>递归解析和迭代解析</strong>两种类型。域名解析每次从根服务器进行解析很可能会造成根域名服务器因负荷太重而超载。为了提高解析效率，<strong>域名解析可以从本地域名服务器开始解析或者采用域名服务器的高速缓冲技术来提高解析效率</strong></p><h3 id="4-2-2-域名解析"><a href="#4-2-2-域名解析" class="headerlink" title="4.2.2 域名解析"></a>4.2.2 域名解析</h3><ol><li><p>TCP/IP域名服务器与解析过程</p><p>域名解析采用自顶向下的算法，从根服务器到叶服务器</p><p>但是如果没每个均是从根到叶会使到达根服务器的信息流量随互联网规模增大而增大，所以每个解析均从根服务器开始并不是一个很好的解决方案</p><p>域名解析方法有两种：第一种叫递归解析，第二种叫反复解析</p><p><strong>递归解析：域名服务器系统一次性完成全部名字-地址转换</strong></p><p><strong>反复解析：每次请求一个服务器，不行再请求别的服务器</strong></p></li><li><p>提高域名解析效率</p><ol><li><strong>解析从本地域名服务器开始</strong></li><li><strong>域名服务器的高速缓冲技术</strong></li><li><strong>主机上的高速缓冲技术</strong></li></ol></li></ol><ul><li>如果解析器收到一条“非授权的”服务器响应，<strong>那么解析器可以认为该响应提供的信息可能不准确</strong></li><li>解析器收到一个“非权威性”的映射时，<strong>解析器可以认为响应服务器不是该域名的授权管理者</strong></li></ul><h3 id="4-2-3-对象类型与资源记录"><a href="#4-2-3-对象类型与资源记录" class="headerlink" title="4.2.3 对象类型与资源记录"></a>4.2.3 对象类型与资源记录</h3><div class="table-container"><table><thead><tr><th>类型</th><th>意义</th><th>内容</th></tr></thead><tbody><tr><td>SOA（Start Of Authority）</td><td>授权开始</td><td>标识一个资源记录集合的开始</td></tr><tr><td>A(address)</td><td>主机地址</td><td>32位二进制IP地址</td></tr><tr><td>MX(mail exchanger)</td><td>邮件交换机</td><td>邮件服务器名及优先级</td></tr><tr><td>NS(name server)</td><td>域名服务器</td><td>域的授权名字服务器名</td></tr><tr><td>CNAME(canonical name)</td><td>别名</td><td>别名的规范名字</td></tr><tr><td>PTR(pointer)</td><td>指针</td><td>对应于IP地址的主机名</td></tr><tr><td>HINFO(host info)</td><td>主机描述</td><td>ASCII字符串，CPU和OS描述</td></tr><tr><td>TXT</td><td>文本</td><td>ASCII字符串，不解释</td></tr></tbody></table></div><h2 id="4-3-远程登录服务"><a href="#4-3-远程登录服务" class="headerlink" title="4.3 远程登录服务"></a>4.3 远程登录服务</h2><p><strong>Telnet协议是TCP/IP协议</strong>一部分，精确定义本地客户机与远程服务器之间的交互过程</p><p>远程登录允许<strong>任意类型</strong>的计算机之间进行通信</p><p>使用Telnet主要目的是使本地主机成为远程主机的仿真终端</p><h3 id="4-3-1-远程登录协议"><a href="#4-3-1-远程登录协议" class="headerlink" title="4.3.1 远程登录协议"></a>4.3.1 远程登录协议</h3><p>远程登录协议Telnet是TCP/IP协议族中的重要协议，为了解决系统的差异性，Telnet协议引入<strong>网络虚拟终端（Network Virtual Terminal，NVT）提供一种标准的键盘定义</strong>，用来屏蔽不同的计算机系统对键盘输入的差异性</p><h2 id="4-4-FTP服务"><a href="#4-4-FTP服务" class="headerlink" title="4.4 FTP服务"></a>4.4 FTP服务</h2><p>FTP（File Transfer Protocol）文件传输协议，主要用于internet上的文件双向传输，采用客户机/服务器模式</p><h3 id="4-4-1-FTP客户机-服务器模型"><a href="#4-4-1-FTP客户机-服务器模型" class="headerlink" title="4.4.1 FTP客户机/服务器模型"></a>4.4.1 FTP客户机/服务器模型</h3><p>FTP客户机与服务器要建立双向链接，一个是控制连接（端口号21）一个是数据连接（端口号20）</p><ul><li><p>控制连接用于维持会话，负责在客户机与服务器之间传送FTP命令和响应</p><p>控制连接以通常的客户机/服务器方式建立，服务器以被动方式在TCP的21端口打开等待客户机连接，客户机则以主动方式在一个TCP随机端口打开</p></li><li><p>数据连接用于访问数据。<strong>建立方式有主动模式和被动模式</strong></p></li></ul><h3 id="4-4-2-FTP命令和响应"><a href="#4-4-2-FTP命令和响应" class="headerlink" title="4.4.2 FTP命令和响应"></a>4.4.2 FTP命令和响应</h3><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>USER</td><td>认证用户名</td></tr><tr><td>PASS</td><td>认证密码</td></tr><tr><td>PORT n1,n2,n3,n4,n5,n6</td><td>客户机IP地址（n1,n2,n3,n4）和端口号（n5*256+n6）</td></tr><tr><td>PASV</td><td>进入被动模式</td></tr><tr><td>LIST filelist</td><td>如果指定了文件或目录，返回其信息；否则返回当前工作目录的信息</td></tr><tr><td>TYPE type(ascii/binary)</td><td>设定传输模式（ASCII/BINARY) 文本使用ASCII，图像使用二进制</td></tr><tr><td>REST marker</td><td>传输文件的起始点</td></tr><tr><td>RERT filename</td><td>检索一个文件</td></tr><tr><td>STOR filename</td><td>存储一个文件</td></tr><tr><td>QUIT</td><td>从服务器注销</td></tr></tbody></table></div><h3 id="4-4-3-文件格式"><a href="#4-4-3-文件格式" class="headerlink" title="4.4.3 文件格式"></a>4.4.3 文件格式</h3><p>FTP协议支持两种<strong>文件传输方式</strong>：<strong>文本文件传输和二进制文件传输</strong></p><p>FTP<strong>数据连接建立模式</strong>有两种：<strong>主动模式与被动模式</strong></p><h2 id="4-5-电子邮件系统"><a href="#4-5-电子邮件系统" class="headerlink" title="4.5 电子邮件系统"></a>4.5 电子邮件系统</h2><h3 id="4-5-1-电子邮件系统的基本知识"><a href="#4-5-1-电子邮件系统的基本知识" class="headerlink" title="4.5.1 电子邮件系统的基本知识"></a>4.5.1 电子邮件系统的基本知识</h3><ol><li><p>电子邮件系统</p><p>电子邮件系统采用客户机/服务器工作模式。</p></li><li><p>TCP/IP互联网上电子邮件传输过程</p><p>在TCP/IP互联网中，邮件之间采用<strong>简单邮件传输协议（Simple Mail Transfer Protocol,STMP）</strong>相互传输邮件。</p><p>电子邮件应用程序<strong>使用STMP向邮件服务器发送邮件</strong>，使用<strong>POP3（Post Office Protocol）协议或者IMAP（Interactive Mail Access Protocol）协议从邮件服务器邮箱中读取邮件</strong></p></li><li><p>电子邮件地址</p><p>TCP/IP互联网上电子邮件地址一般为：</p><p>local-part@domain-name</p><p>domain-name是邮件服务器域名，而local-part则表示邮件服务器上的用户名邮箱</p></li></ol><h3 id="4-5-2-电子邮件传递协议"><a href="#4-5-2-电子邮件传递协议" class="headerlink" title="4.5.2 电子邮件传递协议"></a>4.5.2 电子邮件传递协议</h3><ol><li><p>简单的邮件传输协议SMTP</p><p>SMTP邮件传输采用客户机/服务器模式，邮件接收程序作为SMTP服务器在TCP的25端口守候</p><p>SMTP邮件传递过程可以分为三个阶段：<strong>连接建立阶段，邮件传送阶段，连接关闭阶段</strong>。</p><p>SMTP的最大特点就是简单和直观，它<strong>不规定邮件的接收程序如何存储邮件，也不规定邮件发送程序多长时间发送一次邮件</strong>，它<strong>只规定发送程序和接收程序之间的命令</strong>，SMTP邮件传输采用<strong>客户机/服务器</strong>模式，在TCP/IP互联网中，邮件服务器之间使用简单邮件传输协议SMTP相互传递电子邮件，也就是说SMTP协议使用传输层的TCP服务，<strong>SMTP响应字符串以3位十进制数字开始</strong></p><p>SMTP常用命令：</p></li></ol><div class="table-container"><table><thead><tr><th>HELO&lt;主机域名&gt;</th><th>开始会话</th></tr></thead><tbody><tr><td>MAIL FROM&lt;发送者的电子邮件地址&gt;</td><td>开始一个邮递处理，指出邮件发送者</td></tr><tr><td>RCPT TO&lt;接收者的电子邮件地址&gt;</td><td>标识单个的邮件接收人；可有多个 RCPT TO；常在 MAIL 命令后面</td></tr><tr><td>DATA</td><td>DATA命令后的数据作为邮件内容处理，直到出现 CR LF CR LF 结束</td></tr><tr><td>NOOP</td><td>无操作，服务器应响应 OK</td></tr><tr><td>RSET</td><td>中止当前邮件处理</td></tr><tr><td>QUIT</td><td>结束会话</td></tr></tbody></table></div><ol><li><p>邮局协议POP3</p><p>POP3本身也采用客户机/服务器模式，当用户需要下载邮件时候，POP客户机首先向POP服务器的TCP守候端口110发送建立连接请求</p><p>POP3邮件传递过程可以分为三个阶段：<strong>认证阶段、事务处理阶段、更新阶段</strong></p><p>| USER             | username 认证用户名                       |<br>| ———————— | ————————————————————- |<br>| PASS             | password 认证密码认证，认证通过则状态转换 |<br>| STAT             | 查询报文总数与长度                        |<br>| LIST[&lt;邮件编号&gt;] | 处理 server 返回指定邮件的大小等          |<br>| RETR&lt;邮件编号&gt;   | 请求服务器发送指定编号的邮件              |<br>| DELE&lt;邮件编号&gt;   | 对指定编号的邮件做删除处理                |<br>| RSET             | 复位操作，清除所有删除标记                |<br>| NOOP             | 无操作                                    |<br>| QUIT             | 删除那些标记成删除的邮件，关闭连接        |</p></li></ol><h3 id="4-5-3-电子邮件的报文格式"><a href="#4-5-3-电子邮件的报文格式" class="headerlink" title="4.5.3 电子邮件的报文格式"></a>4.5.3 电子邮件的报文格式</h3><p>RFC822和多用途Internet邮件扩展协议(Multipurpose Internet Mail Extensions,MIME)对邮件报文格式作出了具体的规定</p><ol><li><p>RFC822</p><p>对邮件的最大限制是邮件体为７位ASCII文本，而且SMTP中又规定传输邮件时将８位字节高位清０</p></li><li><p>多用途Internet邮件扩展协议MIME</p><p><strong>使用Base64编码主要目的是将二进制码转换为ASCII码</strong></p></li></ol><h3 id="4-6-2-系统的传输协议"><a href="#4-6-2-系统的传输协议" class="headerlink" title="4.6.2 系统的传输协议"></a>4.6.2 系统的传输协议</h3><p><strong>超文本传输协议HTTP是Web客户机与Web服务器之间的传输协议，TCP上，是一种面向对象的协议。HTTP精确定义了请求报文和响应报文的格式</strong></p><p>HTTP协议是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。HTTP协议是基于TCP的协议。HTTP协议的请求消息为<strong>一个请求行、请求头、空行和具体的请求内容</strong>。客户端向服务器发送一个请求，服务器以一个状态行作为响应，响应的内容包括：消息协议的版本、成功或者错误编码、服务器信息、实体元信息以及必要的实体内容。结果代码（状态码），<strong>用三个数字表示</strong>。</p><ul><li>请求报文包含一个请求行和若干报头行</li><li>应答报文包含一个状态行和若干报头行，并可能在空行后面有报文体</li></ul><p>Web站点中储存的通常是结构化文档，Web浏览器应能解析HTML文档，Web站点应实现HTTP协议</p><h1 id="第五章-新型网络应用"><a href="#第五章-新型网络应用" class="headerlink" title="第五章 新型网络应用"></a>第五章 新型网络应用</h1><h2 id="5-1-即时通信系统"><a href="#5-1-即时通信系统" class="headerlink" title="5.1 即时通信系统"></a>5.1 即时通信系统</h2><p><strong>以色列Mirabils公司推出了世界上第一款即时通信软件ICQ</strong>（I Seek You网络寻呼机）宣告了“<strong>即时通信（Instant Messsaging，IM）</strong>”这一概念的诞生</p><p>即时通信系统是一种基于Internet的通信服务，可以提供<strong>近实时的信息交换</strong>和<strong>用户状态跟踪</strong></p><h3 id="5-1-1-即时通信系统模型"><a href="#5-1-1-即时通信系统模型" class="headerlink" title="5.1.1 即时通信系统模型"></a>5.1.1 即时通信系统模型</h3><p>IETF批准的<strong>RFC2778</strong>给出了一个抽象的呈现与<strong>即时消息系统模型</strong>，<strong>描述了即时通信系统的功能</strong>，<strong>勾勒了即时通信系统的模型框架</strong></p><p>在RFC2778中，即时消息系统被定义为“允许用户相互订阅并获取彼此状态变更信息，以使用用户间互相收发短信息”</p><h3 id="5-1-2-即时通信系统主要通信模式"><a href="#5-1-2-即时通信系统主要通信模式" class="headerlink" title="5.1.2 即时通信系统主要通信模式"></a>5.1.2 即时通信系统主要通信模式</h3><p><strong>一种是用户/服务器模式，另外一种是用户/用户模式</strong></p><ol><li><p>用户/服务器模式</p><p><strong>文本消息</strong>一般采用此模式，TCP协议</p><p>即时消息服务器一般采用固定服务端口被动地与用户通信</p></li><li><p>用户/用户模式</p><p><strong>文件传输</strong>一般采用此模式</p></li></ol><h3 id="5-1-3-即时通信系统的通信协议"><a href="#5-1-3-即时通信系统的通信协议" class="headerlink" title="5.1.3 即时通信系统的通信协议"></a>5.1.3 即时通信系统的通信协议</h3><p><strong>MSN使用的是MSNP协议，ICQ,AOL使用的是OSCAR协议，QQ采用自己的私有协议(UDP为主,辅以TCP)</strong></p><p>即时通信开放的协议主要代表有两个：<strong>基于SIP协议框架的SIMPLE</strong>（SIP for Instant Messaging and Presence Leverage Extension）协议簇，一个是<strong>基于JABBER协议框架的XMPP</strong>（eXtensible Messaging and Presence Protocol）协议簇</p><p>一个即时通信系统包括两个服务：<strong>呈现服务，即时消息服务</strong></p><ol><li><p>SIP协议</p><p>SIP（Session Initiation Protocol）<strong>会话初始化协议</strong></p><p>所谓一个会话指的是用户之间的一次数据交换过程</p><p>SIP<strong>主要是为了IP网络设计的，可以运行于TCP，UDP,SCTP等各种传输层协议之上</strong></p><p><strong>SIP是一种在IP网络上实现实时通信的应用层的控制（信令）协议</strong></p><p>SIP消息可以分为两类，<strong>请求消息和响应消息</strong></p><p>SIP消息由<strong>一个起始行，消息头，一个标志消息头结束的空行，消息体组成</strong></p><p><strong>起始行分为请求行和状态行</strong></p><p>SIP协议虽然主要是为IP网络设计的，但它并<strong>不关心和依赖特定承载网络</strong>。SIP注册服务器用于接收和处理用户端的注册请求，完成用户地址的注册。在通话初始，需要发送方发送INVITE信息，而<strong>接收方不需要发送INVITE</strong>信息。在信息的传送过程中，可能会<strong>经历多个代理服务器</strong>才会完成信息发送。</p><p>| 请求方法 | 功能                                                         |<br>| ———— | —————————————————————————————— |<br>| INVITE   | 邀请用户或者服务器参加一个会话                               |<br>| ACK      | UA向服务器证实它已经对INVITE请求的最终响应。ACK只和INVITE一起使用 |<br>| OPTIONS  | 请求关于服务器能力的信息。如果服务器认为它能与用户联系，则可用一个能力集响应OPTIONS请求 |<br>| BYE      | 用户终止一次会话，既可由主叫UA发送，也可由被叫UA发送         |<br>| CANCEL   | 取消一个挂起的呼叫                                           |<br>| REGISTER | 向定位服务器注册UA的相关信息                                 |</p><p>BYE:是一种请求消息，请求消息包含请求行，消息头，空行，和消息体。</p></li><li><p>SIMPLE协议</p><p><strong>由IETF制定</strong>，SIMPLE协议通过<strong>对SIP协议进行扩展</strong>，使其支持<strong>即时消息服务</strong></p></li><li><p>XMPP</p><p>XMPP是一种基于XML的即时通信协议，IEFT在4个RFC文档中对该协议进行了定义，其中RFC3920，RFC3922，RFC3923分别对XMPP协议的核心构架，即时通讯方法，XMPP与CPIM的映射，安全性保证等内容进行了定义,使用XMPP的有<strong>Google Talk,Jive Messager</strong></p><p><strong>XMPP实体地址</strong>叫做<strong>JID（Jabber标识）</strong>，它由域标识符、结点标识符、资源标识符三部分组成。形如：node@domain/resource</p><p><strong>系统构架沿用了E-mail系统的构架</strong></p><ul><li><p>XMPP系统构架</p><p>主要由3种实体组成：XMPP客户，XMPP服务器，XMPP网关</p></li><li><p>XMPP系统特点</p><p><strong>用户/服务器中转模式</strong></p><p><strong>分布式网络</strong></p><p><strong>简单客户机端</strong></p></li></ul></li></ol><p>QQ用户登录过程如下：<br>（1）客户端每次登陆时会访问记录上次登陆服务器的地址的记录文件，如果成功则不会重发DNS请求。<br>（2）在QQ通信中，用户必须先登录后才可以进行互相发送信息等。<br>（3）<strong>每次登陆</strong>时QQ客户机会向<strong>服务器获取一个会话密钥</strong>。</p><p>（4）实现成功登录前可能连接多个登录服务器</p><h2 id="5-2-P2P文件共享"><a href="#5-2-P2P文件共享" class="headerlink" title="5.2 P2P文件共享"></a>5.2 P2P文件共享</h2><p>文件共享技术有多种实现方式：<strong>FTP文件共享，NFS网络文件系统共享，Windows共享文件夹，以及P2P文件共享</strong></p><p>P2P网络的主要结构类型分为<strong>集中式，分布式非结构化，分布式结构化和混合式</strong></p><h3 id="5-2-1-P2P文件共享历史"><a href="#5-2-1-P2P文件共享历史" class="headerlink" title="5.2.1 P2P文件共享历史"></a>5.2.1 P2P文件共享历史</h3><p>P2P文件共享起源于<strong>1999年的音乐分享网站Napster</strong>，<strong>集中式对等网络结构</strong></p><ul><li>在<strong>中心服务器端</strong>存放希望共享的文件描述信息</li><li>文件依然存放在用户的本地主机</li></ul><p>2000年3月，另一种P2P文件共享应用<strong>GnutElla</strong>问世，最初<strong>采用分布式非结构化对等网络结构</strong></p><ul><li><p>分布式非结构化P2P网络采用<strong>随机图的组织方式形成一个松散网络</strong>，支持复杂查询</p></li><li><p>优点是配置简单，不需要服务器支持，在规模小时候具有很高的查询效率</p></li><li><p>缺点是<strong>采用TTL，洪泛，随机漫步或者有选择转发算法</strong>，基于广播进行查找，网络拓扑直径不可控，可扩展性较差</p></li></ul><p>2000年9月，<strong>eDonkey2000</strong>出现，继承了GnutElla的共享文件系统优点，并<strong>为文件增加了哈希（hash）信息</strong></p><p>2001年夏，<strong>由MIT开发</strong>的开源BT（BitTorrent 比特洪流）出现，引发互联网文件共享的革命：最初需要中心服务器存放用户信息，该服务器成为Tracker服务器，BT系统要求文件发布者制作一个成为种子的文件（.torrent文件）下载者通过发布者提供的<strong>种子文件链接到Tracker的服务器</strong>，获取其他下载者的IP地址和端口号，下载者得到信息后，可以与其他下载者互连，互连的下载者可以通过种子文件确认已经拥有的文件块，并相互交换各自的没有的文件块，当下载完毕后，<strong>用户自动转换为“做种”模式</strong>，负责上传其他用户所需要的文件块，在整个过程中，<strong>Tracker仅负责提供下载该文件的用户列表</strong>，用户数越多下载速度越快，在后续版本中加入了DHT的支持，以实现无Tracker服务器文件传输</p><p>使用了<strong>分布式结构化拓扑的P2P网络</strong>：<strong>Pastry,Tapestry,Chord,CAN</strong></p><p>分布式结构化拓扑的P2P网络基于<strong>DHT</strong>(分布式散列表)的分布式发现和路由算法。避免了中心服务器，不需要基于广播进行查找，<strong>支持精确关键词匹配查询</strong></p><p>混合式P2P网络：</p><p>索引结点保存可以利用的搜索结点信息、搜集状态信息以及尽力维护网络的结构，一个结点既可以是搜索结点也可以是索引结点。索引结点不会直接连接到有版权的资料，只是搜索所需资料相关的地址，至于用户到底连接下载了什么内容与它无关。</p><h3 id="5-2-2-P2P文件共享的理论基础"><a href="#5-2-2-P2P文件共享的理论基础" class="headerlink" title="5.2.2 P2P文件共享的理论基础"></a>5.2.2 P2P文件共享的理论基础</h3><p><strong>小世界假设，六度分隔理论</strong></p><p>2001年秋，哥伦比亚大学<strong>瓦特斯</strong>通过电子邮件领导验证</p><h3 id="5-2-3-P2P文件共享示例"><a href="#5-2-3-P2P文件共享示例" class="headerlink" title="5.2.3 P2P文件共享示例"></a>5.2.3 P2P文件共享示例</h3><p>Maze:支持<strong>在线资源搜索和文件目录视图</strong>，可以<strong>多点下载</strong>和<strong>断点续传</strong>，采用Maze<strong>积点</strong>和Maze<strong>星级</strong>技术。支持<strong>即时通信BBS</strong>；支持<strong>跨防火墙</strong>的文件共享与下载；支持<strong>在线资源搜索</strong>和<strong>文件目录视图</strong>；支持积点的资源交换体系；采用社交网络的网络链接关系。Maze属于混合型P2P系统，整个系统除了多个Peer外，还包括集中式的<strong>用户管理服务器</strong>、<strong>目录收集服务器</strong>、<strong>检索服务器</strong>、<strong>心跳服务器</strong>和<strong>种子服务器</strong>。为了实现结点的发现与通信策略，采用<strong>分布式认证机制</strong>。混合P2P结构，采用URL表示文件位置，用XML方式检索接口</p><h2 id="5-3-IPTV"><a href="#5-3-IPTV" class="headerlink" title="5.3 IPTV"></a>5.3 IPTV</h2><h3 id="5-3-1-IPTV系统"><a href="#5-3-1-IPTV系统" class="headerlink" title="5.3.1 IPTV系统"></a>5.3.1 IPTV系统</h3><ol><li><p>视频点播</p><p>视频点播(Video On Demond,VOD)也被称为交互式电视点播系统。</p><p>VOD的服务类型分三种，一种是就近式点播电视(Near Video On Demand,NVOD),一种是真实点播电视(True Video On demand,TVOD),还有一种是交互式点播电视(Interactive Video On Demand,IVOD)</p><ul><li>NVOD:每个视频流间隔一定时间就发送同样的内容，用户选择距最近的某个时间起点进行收看。</li><li>TVOD:支持即点即放，当用户提出请求时，视频服务器立即传送用户所需的视频内容。每个视频流只为一个用户服务</li><li>IVOD:不仅支持即点即放，而且还可以让用户对视频流进行交互式控制，实现播放倒回快进等功能</li></ul></li></ol><h3 id="5-3-2-IPTV关键技术"><a href="#5-3-2-IPTV关键技术" class="headerlink" title="5.3.2 IPTV关键技术"></a>5.3.2 IPTV关键技术</h3><ol><li><p>媒体内容分发技术</p><p>媒体内容分发网络(Media Content Delivery Network,MCDN)技术是IPTV大规模应用的重要保障</p><ul><li>内容发布：将<strong>内容发布或投递</strong>到距离用户<strong>最近的</strong>远程服务点</li><li>内容路由：整体性的网络<strong>负载均衡技术</strong>，利用<strong>应用层</strong>的技术，保证<strong>用户得到最近内容源</strong>的响应</li><li>内容交换：利用<strong>应用层</strong>交换，流分裂，重定向及宽带媒体分发策略等技术，智能地<strong>平衡负载流量</strong></li><li>性能管理：获取网络部件的状态信息，另外测量内容发布的端到端性能，<strong>保证网络处于最佳运行状态</strong></li><li>IP承载网：利用IP网络技术，为IPTV应用<strong>提供可靠的IP网络平台</strong></li></ul></li><li><p>数字版权管理技术</p><ul><li>数据加密</li><li>版权保护</li><li>数字水印</li></ul></li><li><p>IPTV运营支撑管理系统</p></li></ol><h2 id="5-4-VoIP"><a href="#5-4-VoIP" class="headerlink" title="5.4 VoIP"></a>5.4 VoIP</h2><p>VoIP（Voice over IP）俗称IP电话（Internet Protocol Phone）。IP电话系统有4个基本组件：终端设备、网关、多点控制单元和网守。终端设备（Terminal）是一个IP电话客户终端，可以是软件。网关是通过IP网络提供语音通信的关键设备，是IP网络和PSTN（Public Switched Telephone Network，公用电话交换网简称电话网）网络之间的接口设备，从网络的角度看，它就是一个H.323设备。多点控制单元MCU（Multipoint Control Unit）的功能在于利用IP网络实现多点通信。网守（Gatekeeper）主要负责用户的注册和管理等。</p><h3 id="5-4-2-VoIP系统组成"><a href="#5-4-2-VoIP系统组成" class="headerlink" title="5.4.2 VoIP系统组成"></a>5.4.2 VoIP系统组成</h3><ol><li><p>IP电话网关，是IP网络和电话网络之间的桥梁</p><p>基本功能：<strong>号码查询，建立通信连接（信号调制），路由寻址</strong></p></li><li><p>网守</p><p>网守是一个中央控制实体，在VoIP系统中起管理作用。</p><p>网守是VoIP系统中的<strong>消息控制中心</strong>，可以进行<strong>呼叫控制，地址解析，呼叫授权，身份验证，集中账务和计费管理</strong>，<strong>存留呼叫详细记录</strong>等操作。</p><p>网守还可以像实时网管一样<strong>监控网络，平衡负载，管理带宽以及提供与现有系统的接口</strong>。</p></li></ol><h3 id="5-4-4-VoIP实例"><a href="#5-4-4-VoIP实例" class="headerlink" title="5.4.4 VoIP实例"></a>5.4.4 VoIP实例</h3><p>Skype是著名Kazaa软件创始人Niklas推出的一款Internet即时语音通信软件</p><ol><li>基本概念<ul><li>SkypeClient:SC,SKype系统客户机</li><li>SuperNode:SN，动态生成，作用像Internet中的核心路由器，每个SC根据其内存，带宽以及上线时间为因素，都有可能被选为SN</li><li>其他见书本</li></ul></li><li>超级结点（SN）的作用就像是因特网中的核心路由器，负责客户端的连接。好友列表（Buddy List）经过了数字化签名和加密处理，不是明文存储。<strong>Skype采用了256 bit的AES加密算法，以及混合式网络拓扑</strong>。</li></ol><h2 id="5-5-网络搜索技术"><a href="#5-5-网络搜索技术" class="headerlink" title="5.5 网络搜索技术"></a>5.5 网络搜索技术</h2><h3 id="5-5-2-搜索引擎的主要内容"><a href="#5-5-2-搜索引擎的主要内容" class="headerlink" title="5.5.2 搜索引擎的主要内容"></a>5.5.2 搜索引擎的主要内容</h3><p><strong>搜索器，索引器，检索器，用户接口</strong></p><h1 id="第六章-网络管理与网络安全"><a href="#第六章-网络管理与网络安全" class="headerlink" title="第六章 网络管理与网络安全"></a>第六章 网络管理与网络安全</h1><h2 id="6-1-网络管理技术"><a href="#6-1-网络管理技术" class="headerlink" title="6.1 网络管理技术"></a>6.1 网络管理技术</h2><h3 id="6-1-1-网络管理的概念"><a href="#6-1-1-网络管理的概念" class="headerlink" title="6.1.1 网络管理的概念"></a>6.1.1 网络管理的概念</h3><p>通常涉及：网络提供，网络维护，网络管理</p><p>ISO定义网管模型包括４个部分：<strong>组织模型，信息模型，通信模型与功能模型</strong></p><p>组织模型:描述网管系统的组成部分和结构</p><p>信息模型：网管系统的对象命名和结构</p><p>通信模型：网管系统使用的网管协议</p><p>功能模型：网管系统的主要功能</p><p><strong>网络管理模式通常为集中式网络管理或管理者－网管代理模型</strong></p><h3 id="6-1-2-网络管理功能域"><a href="#6-1-2-网络管理功能域" class="headerlink" title="6.1.2 网络管理功能域"></a>6.1.2 网络管理功能域</h3><p>网络管理功能域定义的是主要的网管功能，并将这些功能划分为５个部分：<strong>配置管理，故障管理，性能管理，安全管理与记账管理</strong></p><p>配置管理：中长期，网络增容，设备更新，新技术应用，新业务开通，新用户加入，业务撤销，用户迁移</p><p>故障管理：<strong>发现与排除故障，保证网络资源无障碍无错误运营</strong>，包括障碍管理，故障恢复，预防故障，故障管理包括检测隔离纠正故障</p><p>性能管理：测试性能指标，包括吞吐率，利用率，响应时间，传输延时等，性能管理可以分为两个部分：<strong>性能监控和网络控制</strong>，性能监控收集网络状态信息，网络控制值为改善性能采用的措施</p><p>安全管理：<strong>控制与维护对网络资源的访问权限，安全服务设施的建立控制与删除</strong>，信息分发，事件通知，网络操作记录维护</p><p>计费管理：控制监控网络操作的费用与代价，还进行网络资源利用率的统计和网络的成本效益的核算</p><h3 id="6-1-3-网络管理系统"><a href="#6-1-3-网络管理系统" class="headerlink" title="6.1.3 网络管理系统"></a>6.1.3 网络管理系统</h3><p>网络管理系统(Network Management System,NMS)通常称为网管系统，是用来实现网管功能的软件或硬件系统。</p><p><strong>管理对象</strong>是经过抽象的网络元素，对应于网络中具体可以操作的数据，例如网络设备的工作参数，网络性能的统计参数等。<strong>管理对象相关信息储存在MIB中，每个网管系统都需要MIB的支持</strong></p><p>网络管理涉及到网络中的各种资源，可分为两大类：硬件资源和软件资源。<br>硬件资源是指物理介质、计算机设备和网络互联资源。物理介质通常是物理层设备、如网卡、双绞线等；计算机设备包括打印机和存储设备及其他计算机外围设备；常用的网络互联设备有中继器、网桥、路由器、网关等。软件资源主要包括操作系统、应用软件和通信软件。</p><p><strong>管理协议</strong>负责在网络工作站与网络设备的管理进程之间通信，传输信息包括发送的操作命令与返回的操作结果。</p><p>网管系统通常分为两类：网元管理系统(Element Management System,EMS)只负责管理单独的网络元素（网络设备）。另一种是通用的网络管理系统(Network Management System,NMS)负责管理整个网络而不是单个设备，通常用于掌握整个网络的工作状态，作为作为底层的网络平台服务于EMS.</p><h3 id="6-1-4-网络管理协议"><a href="#6-1-4-网络管理协议" class="headerlink" title="6.1.4 网络管理协议"></a>6.1.4 网络管理协议</h3><ol><li><p>SNMP协议</p><p><strong>Internet工程任务组(Internet Engineering Task Force,IETF)是很多互联网标准的制定者，制定了简单网络管理协议(Simple Network Management Protocol,SNMP)</strong>是一种面向Internet的网管协议，针对的管理对象是各种网络设备</p><p>1987年IETF制作了简单网关协议(Simple Gateway Monitoring Protocol,SGMP)，<strong>SNMP协议在SGMP的基础上建立起来的。</strong></p><p>第一个版本设计简单，易于实现，<strong>第二个版本增加了操作类型与支持多层传输层协议，第三个版本提供了安全与改进的框架结构。</strong></p><p>由于开始的SNMP没有考虑安全问题，SNMPv2开始在提供安全性<strong>(安全性不是重点内容)</strong>和更有效的传递管理信息方面加以改进，具体包括提供验证、加密和时间同步机制。SNMPv3的重点是安全、可管理的体系结构和远程配置。</p><p>SNMP是一种<strong>应用层的协议</strong>，采用客户机/主机的形式</p><p>SNMP在传输层采用支持无线连接服务的<strong>UDP</strong>协议。网络设备的管理信息可以分为很多类型，并<strong>保存在MIB的管理对象中</strong>。SNMP协议采用<strong>轮询监控方式</strong>，管理器定时想代理请求获得管理信息，并根据返回信息判断是否发生异常。</p><p>MIB（管理信息库）是一个数据库，它代表了某个设备或服务的一套可管理对象。由SNMP管理的<strong>每台主机必须有一个MIB</strong>，它描述了该主机上的可管理对象。所有的MIB必须用精确的组织结构定义。SNMP管理器在与其他代理连接时，通过MIB中的信息，来识别该代理上的信息是如何组织的。</p><p>SNMP从被管理设备中收集数据有两种方法：<strong>一种是轮询（polling）方法，另一种是基于中断（interrupt-based）的方法</strong></p><p>管理器和代理是一对多关系</p><p>RMON提供补充功能</p></li><li><p>CMIP协议</p><p><strong>ISO制定</strong>的通用管理信息服务(Common Management Information Service,CMIS)与通用管理信息协议(Common Management Information Protocol,CMIP)</p><p>CMIP是一种<strong>应用层的协议</strong></p><p>CMIP<strong>建立在OSI模型基础上</strong></p><p>在<strong>传输层采用支持有连接服务的协议</strong>，例如OSI模型定义的TP3协议，CMIP系统<strong>传输信息之前需要预先建立连接。</strong></p><p>采用委托监控机制</p></li></ol><h2 id="6-2-网络安全的概念"><a href="#6-2-网络安全的概念" class="headerlink" title="6.2 网络安全的概念"></a>6.2 网络安全的概念</h2><h3 id="6-2-2-网络安全服务与法律法规"><a href="#6-2-2-网络安全服务与法律法规" class="headerlink" title="6.2.2 网络安全服务与法律法规"></a>6.2.2 网络安全服务与法律法规</h3><ol><li><p>网络安全服务应该提供以下基本保障：</p><ol><li>可用性：尽管可能存在突发事件（自然灾害，突然断电，事故等）情况下，网络仍然可以正常运转，用户可以使用各种网络服务</li><li>机密性：保证网络中的数据不馁非法截获或非授权访问，保护敏感数据和涉及个人隐私信息的安全</li><li>完整性：保证数据完整，没有被修改，插入或删除</li><li>不可否认性：确认通信参与者的身份真实性，防止对已发送或接受的信息否认的现象出现</li><li>可控性：控制与限定网络用户对主机系统，网络服务与网络信息资源的访问和使用，防止非授权用户读取写入删除数据</li></ol></li><li><p>网络安全的法律法规：</p><p><strong>美国政府定制</strong>的可信用计算机系统评估准则(TC-SEC-NCSC)将计算机系统安全等级分为４类７个等级，即D,C1,C2,B1,B2,B3与A1,<strong>Ｄ级系统安全级别最低，A1级系统的安全要求最高</strong></p><p>D:非安全保护类，C:自主保护类型，B:强制型安全保护类，A1:相对B在安全审计，安全测试，配置管理等方面提出更高要求</p><p>D1是最小的保护级别。主要特征是保护措施很少，没有安全功能。</p><p>C1是有选择的安全保护。主要特征是有选择的存取控制，用户与数据分离，数据保护以用户组为单位。<br>C2是受控的访问控制。主要特征是存取控制以用户为单位，广泛的审计。<br>B1是标记安全保护。除了C2级的安全要求外，增加安全策略模型，数据标号（安全和属性），托管访问控制等。<br>B2是结构化安全保护。设计系统时必须有一个合理的总体设计方案，面向安全的体系结构，遵循最小授权原则，具有较好的抗渗透能力，访问控制应对所有的主体和客体进行保护，对系统进行隐蔽通道分析。<br>B3是安全域机制保护。安全内核，高抗渗透能力。<br>A1可验证安全设计。形式化的最高级描述和验证，形式化的隐秘通道分析，非形式化的代码一致性证明。</p><p>在我国，以《计算机信息系统安全保护等级划分准侧》为标准。</p><p>ITSEC欧洲信息安全评估标准</p></li></ol><h3 id="6-2-4-网络攻击的主要类型"><a href="#6-2-4-网络攻击的主要类型" class="headerlink" title="6.2.4 网络攻击的主要类型"></a>6.2.4 网络攻击的主要类型</h3><p><strong>主动攻击：拒绝服务攻击（DoS），分布式拒绝服务(DDoS)，信息篡改，资源使用，欺骗（如源路由攻击），伪装（如邮件炸弹），重放等攻击方法</strong></p><p><strong>服务攻击(与主动攻击不是并列关系)：针对某特定网络服务攻击，如针对Email，FTP，HTTP等服务攻击，如对Telnet的23号端口，对HTTP的80端口，邮件炸弹等</strong></p><ol><li><p>DoS与DDoS</p><ol><li><p>DoS的分类与特征</p><p>拒绝服务攻击(Denial of Service,DoS)利用合理的理由通过发送一定数量，一定序列的报文，使网络服务器中充斥大量要求回复的信息，消耗网络带宽或系统资源，导致服务器不能正常工作，甚至瘫痪。</p></li><li><p>DDoS攻击的特征</p><p>典型的DDoS攻击采用三层结构：攻击控制层，攻击服务层，攻击执行层。</p><p>真正的攻击者处于攻击控制层的位置，为了防止被跟踪和追查，攻击者首先通过漏洞扫描方式选择安全性较差的计算机作为被控制对象（即攻击服务器）,向攻击服务器传播恶意攻击程序，通过攻击服务器去发展下一级的攻击执行器，攻击执行器也称为“傀儡机”。在向攻击服务器发出攻击命令后，攻击控制台立即车里，不参加之后的攻击行动。</p><p>特点：</p><ol><li>被攻击的主机上可能有大量等待应答的TCP连接</li><li>网络中充斥着大量无用网络数据包，并且数据包的源地址是伪造的</li><li>大量无用数据包造成网络拥塞，使得网络工作不正常，甚至瘫痪</li><li>被攻击的主机可能在攻击发起之后短短几秒后就处于瘫痪状态</li><li>攻击服务器和傀儡机都是在不知情下参与的，真正攻击者早已消失</li></ol></li><li><p>僵尸网络特征</p><p>控制者出于恶意目的，传播僵尸病毒，控制大量主机，通过一对多的命令与控制信道主城网络，实施DDoS攻击，僵尸网络是一种典型的植入威胁攻击</p></li></ol></li></ol><h2 id="6-3-加密与认证技术"><a href="#6-3-加密与认证技术" class="headerlink" title="6.3 加密与认证技术"></a>6.3 加密与认证技术</h2><p><strong>唯密文攻击</strong>指的是在仅知已加密文字的情况下进行穷举攻击。</p><p><strong>已知明文攻击</strong>指攻击者掌握了某段明文和对应密文，推断加密方式，从而破解后段密文的攻击方式。</p><p><strong>选择明文攻击</strong>是指攻击者不仅已知加密算法和密文，而且还能够通过某种方式让发送者在发送的信息中插入一段由他选择的信息。</p><p><strong>选择密文攻击</strong>的密码分析者事先任意搜集一定数量的密文，让这些密文透过被攻击的加密算法解密，透过未知的密钥获得解密后的明文。</p><h3 id="6-3-2-对称密码体系"><a href="#6-3-2-对称密码体系" class="headerlink" title="6.3.2 对称密码体系"></a>6.3.2 对称密码体系</h3><ol><li><p>典型的对称加密算法</p><p>数据加密标准(Data Encrytion Stardard,DES)是最典型的<strong>对称加密算法</strong>，<strong>由IBM公司提出，经ISO认定的国际标准</strong>。DES每次处理一个<strong>64位的明文分组</strong>，并且每次生成一个64位的密文分组。</p><p>DES有<strong>56位密钥长度</strong>。<strong>基于置换和代换技术</strong>，基于<strong>整数有限域离散对数难题</strong>，和RSA安全性差不多。DES算法加密过程中每轮操作都有置换和代换，<strong>每轮置换函数相同</strong></p><p>高级加密算法(Advanced Encrytion Stardard,AES)是后来出现的一种<strong>对称加密算法</strong>，<strong>由NIST制定</strong>，AES将数据分为固定大小的分组，以分组为单位进行加密或解密。<strong>AES算法安全性能不低于3DES，同时具有良好的执行性能，运行速度比3DES速度快。密钥长度为128、192和256位，分组长度为128位。</strong></p><p>其他对称加密算法包括:IDEA,Blowfish,RC2,RC4,RC5,CAST等</p><p>Blowfish算法是有Bruce Schneider设计的算法，是一个可变密钥长度的分组算法，分组长度为64位，Blowfish算法所有的运算都是32位字的加法和异或，仅有的另一个运算时每轮的四个查表。</p><p>背包加密算法是一种公钥加密算法，该算法中背包的物品总重量是公开的，所有可能的物品也是公开的，但是背包中的物品却是保密的，它是一个NP难度问题。目前大多数一次背包体制均被破译了，一次背包已不安全了</p></li></ol><h3 id="6-3-3-非对称密码体系"><a href="#6-3-3-非对称密码体系" class="headerlink" title="6.3.3 非对称密码体系"></a>6.3.3 非对称密码体系</h3><ol><li><p>典型的非对称加密算法</p><p>RSA是一种典型的公钥加密算法，它在网络安全领域得到广泛应用，RSA算法的安全性建立在大素数分解极其困难的基础之上。是由Ron Rivest,Adi Shamir,Leonard Adleman设计的一种算法。</p><p>其他非对称加密算法主要包括DSS,ElGamal与Diffie-Hellman等</p><p>ElGamal:基于公钥秘钥体制和椭圆曲线加密体系，属于非对称加密，加密过程中，生成的密文长度是明文的两倍，基于离散对数，常用于数字签名。</p><p>数据加密标准DES属于堆成加密算法，DSA与ElGamal属于公钥加密</p></li></ol><h3 id="6-3-4-公钥基础设施"><a href="#6-3-4-公钥基础设施" class="headerlink" title="6.3.4 公钥基础设施"></a>6.3.4 公钥基础设施</h3><ol><li><strong>公钥基础设施(Public Key Infrastructure,PKI)是利用公钥加密和数字签名技术建立的安全服务基础设施，以保证网络环境中的数据的秘密性完整性和不可抵赖性。</strong></li></ol><h3 id="6-3-5-数字签名技术"><a href="#6-3-5-数字签名技术" class="headerlink" title="6.3.5 数字签名技术"></a>6.3.5 数字签名技术</h3><p>数字签名是笔迹签名的模拟，<strong>公钥密码体制和私钥密码体制都可以用于数字签名</strong>，验证时需要使用相同的散列函数，并且<strong>通过比较消息摘要是否匹配</strong>来验证签名的正确性。</p><ol><li><p>数字签名的工作原理</p><ol><li><p>目前广泛使用的数字签名算法是消息摘要(Message Digest,MD5)</p><p>MD5没有对数据进行加密或者修改，<strong>可对任意长度的数据生成128位散列值，没有对数据加密或者修改，只是生成一个用于判断完整性与真实性的散列值</strong></p></li></ol></li></ol><h2 id="6-4-网络安全协议"><a href="#6-4-网络安全协议" class="headerlink" title="6.4 网络安全协议"></a>6.4 网络安全协议</h2><h3 id="6-4-1-网络安全协议的概念"><a href="#6-4-1-网络安全协议的概念" class="headerlink" title="6.4.1 网络安全协议的概念"></a>6.4.1 网络安全协议的概念</h3><p><strong>在主机－网络层（数据链路层对应它的一部分）中，主要的安全协议包括PPTP,L2TP与L2F等</strong></p><p><strong>在互联层（或网络层）中，最主要的安全机制是IPSec的两个组成协议，即认证头部(AH)与封装安全有效载荷（ESP）</strong></p><p><strong>在传输层中，主要的安全协议包括SSL,SSH,TLS与SOCKS等。</strong></p><p>https是以安全为目标的HTTP通道，简单讲是HTTP安全版，即HTTP+SSL，HTTPS安全基础是SSL。如果用户想在Web上使用SSL协议URL必须使用https开头</p><p>SSL最初由Netscape公司定制，SSL以及其继任者TLS，是为了为网络通信提供安全以及数据完整性的一种安全协议，TLS与SSL在传输层对网络进行加密，用于保障网络数据传输安全，利用数据加密技术，，确保数据在网络传输过程中不被截取与窃听，所有主要浏览器和Web服务器支持SSL，可以通过安装SSL证书激活SSL协议。</p><p><strong>在应用层中针对不同的网络服务或应用的安全机制比较多，例如PGP,SET,用于增强Web安全的S-HTTP,用于保障邮件安全的S/MIME,用于电子商务安全交易的SET等</strong></p><h3 id="6-4-2-网络安全与IPSec"><a href="#6-4-2-网络安全与IPSec" class="headerlink" title="6.4.2 网络安全与IPSec"></a>6.4.2 网络安全与IPSec</h3><ol><li><p>IPSec安全体系结构</p><p>IPSec主要包含３个组成部分，<strong>认证头(Authentication Header,AH)，封装安全负载(Encapsulating Security Payload,ESP)与密钥管理协议</strong></p><p>IPSec工作模式分两种，<strong>隧道模式和传输模式</strong></p></li><li><p>AH协议的工作原理</p><p>可工作在隧道模式与传输模式</p></li><li><p>ESP协议工作原理</p><p>可工作在隧道模式与传输模式</p></li></ol><p>浏览器安全性：</p><ol><li><strong>将Web站点放入可信站点区可以保证信息传输的机密性</strong></li><li><strong>在浏览器中添加证书可以验证Web站点的真实性</strong></li><li><strong>索要Web站点的证书可以表明浏览器的身份</strong></li><li><strong>使用SSL技术可以防止病毒的传播</strong></li></ol><h3 id="6-4-4-应用层安全与PGP-SET"><a href="#6-4-4-应用层安全与PGP-SET" class="headerlink" title="6.4.4 应用层安全与PGP,SET"></a>6.4.4 应用层安全与PGP,SET</h3><ol><li><p>PGP</p><p>PGP（Pretty Good Privacy，相当好的私密性）是一个安全电子邮件加密软件，它主要由5种服务组成：<strong>鉴别、机密性、压缩、电子邮件的兼容性和分段</strong>，<strong>支持多语种安装平台</strong>。数字签名使用DSS/SHA或RSA/SHA算法，<strong>报文加密采用CAST或IDEA，或使用Diffie-Hellman的3DES或RSA算法。</strong><br>PGP也提供了公共密钥认证机制，但是这个机制完全不同于通用的认证中心（CA）。PGP公共密钥通过委托网站进行认证，它也可以通过互联网上的PGP公共密钥服务器发布。</p></li></ol><p>包括<strong>电子邮件的加密，身份验证，数字签名</strong>等安全功能。</p><p>   在PGP协议中需要两个不同的加密过程：<strong>明文加密与对称密钥的加密</strong></p><p>   PGP2数字签名能够保证邮件的完整性，身份认证与不可抵赖性，数据加密可以保证邮件内容的机密性</p><h2 id="6-5-防火墙技术"><a href="#6-5-防火墙技术" class="headerlink" title="6.5 防火墙技术"></a>6.5 防火墙技术</h2><h3 id="6-5-1-防火墙概念"><a href="#6-5-1-防火墙概念" class="headerlink" title="6.5.1 防火墙概念"></a>6.5.1 防火墙概念</h3><p>防火墙的基本部件是：包过滤路由器，应用级网关</p><p>通常应用于内部网络与外部网络之间</p><p>可通过软硬件实现</p><h3 id="6-5-2-包过滤路由器"><a href="#6-5-2-包过滤路由器" class="headerlink" title="6.5.2 包过滤路由器"></a>6.5.2 包过滤路由器</h3><p>包过滤路由器作用于网络层上</p><p>检查每个分组的源地址，目的地址，决定该分组是否应该转发。</p><p>包过滤路由器会检查TCP报头的端口号和字节，通常基于部分或全部报头内容，例如对TCP报头信息，可以是源地址，目的地址，协议类型，IP选项，源端口号，目的端口号，TCP,ACK等标识</p><h3 id="6-5-3-应用级网关"><a href="#6-5-3-应用级网关" class="headerlink" title="6.5.3 应用级网关"></a>6.5.3 应用级网关</h3><p>应用代理是应用级网关的另一种形式</p><h1 id="题目心得："><a href="#题目心得：" class="headerlink" title="题目心得："></a>题目心得：</h1><ol><li><p>51题左右：</p><p>关键词：“ping不通”</p><p>首先判断是否在一个子网，如果不在一个子网则是因为不在一个子网。如果在一个子网，如果题目说不是一个VLAN则选不在一个VLAN，ping不通与操作系统无关</p></li><li><p>有限广播地址：255.255.255.255</p><p>直接广播地址：网络号+一个全“1”的主机号</p></li><li><p>混合P2P网络包含节点种类：用户节点，搜索节点，索引结点</p></li><li><p><strong>ISO制定了：CMIP，CMIS，OSI参考模型</strong></p><p><strong>IETF：TCP/IP 参考模型，RFC2778，SIMPLE协议，SNMP协议,IPSec，SIP</strong></p></li><li><p><strong>为了保护自己的计算机免受非安全软件的危害，浏览器通常采用的方法是将Internet世界划分为不同的区域（如Internet区域、本地Internet区域、可信站点区域、受限站点区域）</strong></p></li><li><p><strong>为了避免他人假冒自己，用户可以在浏览器安装自己的数字证书</strong></p><p><strong>将Web站点放入可信站点区可以保证信息传输的机密性</strong></p><p><strong>在浏览器中添加证书可以验证Web站点的真实性</strong></p><p><strong>索要Web站点的证书可以表明浏览器的身份，验证站点的真实性</strong></p><p><strong>使用SSL技术可以防止病毒的传播，避免第三方偷看</strong></p><p><strong>使用Base64编码主要目的是将二进制码转换为ASCII码</strong></p></li><li><p>Web服务采用客户机/服务器工作模式</p><p>Web服务以超文本方式组织网络多媒体信息</p><p>Web<strong>服务器需要实现HTTP协议</strong></p><p>用户访问Web服务器可以使用图形界面</p><p>Web浏览器的解释单元<strong>负责解析从服务器发送回来的数据</strong></p><p>浏览器组成为：<strong>控制单元，客户单元，解释单元</strong></p></li><li><p>广域网的研究重点是核心交换技术</p></li><li><p>共享介质以太网核心是<strong>集线器</strong>，支持全双工</p></li><li><p>局域网交换机核心核心技术包括端口/MAC地址映射</p></li><li><p>54题附近：</p><p>从使用者来看，Internet是一个资源网</p><p>从设计者来看，Internet是计算机互联网络的实例/IP互联网</p><p>Internet利用路由器实现异构网络互联</p><p>Internet主要组成部分包括四个部分：通信线路，路由器，主机和信息资源。</p></li><li><p>个人区域网（WPAN,Wireless Personal）</p><p>个人局域网(PAN,Personal)  </p><p>局域网(LAN,local)  </p><p>城域网(MAN,metropolitian)  </p><p><strong>广域网(WAN,wide)</strong> </p><p><strong>无线自组网（WAN,Wireless ad hoc network）</strong></p><p>无线局域网(WLAN,Wireless Local)</p><p>无线网状网(WMN,wireless mesh network)</p></li><li><p>VLAN技术：</p><p>虚拟局域网是<strong>建立在交换式技术的基础上</strong>，以软件方式实现逻辑工作组的划分与管理，工作组中的结点不受物理位置的限制。常见的组网方式包括：<strong>用交换机端口定义虚拟局域网、用MAC地址定义虚拟局域网、用网络层(IP)地址定义虚拟局域网、基于广播组的虚拟局域网。</strong></p></li><li><p>信息存储安全措施至少要包括三类：（1）社会的法律政策、企业的规章制度及网络安全教育；（2）技术方面的措施，如防火墙技术、防病毒、信息加密、身份确认以及授权即设置访问权限等；（3）审计与管理措施，包括技术与社会措施。主要有实时监控、提供安全策略改变的能力以及对安全系统实施漏洞检查等。</p></li><li><p>欧洲原子核研究委员会（CERN）的 Tim Berners-Lee 开发了一个协议，用来解决复杂进化系统中的信息丢失问题，并提出一个基于分布式超文本系统的解决方法，Web 因此诞生。Web服务采用客户机/服务器工作模式，Web服务以超文本方式组织网络多媒体信息，<strong>Web服务器需要实现HTTP协议</strong>，存储了用户共享的信息，用户访问Web服务器可以使用图形界面，Web浏览器的解释单元负责解析从服务器发送回来的数据。</p></li><li><p>UNIX操作系统，是一个多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统。Unix从第三版内核开始使用C语言。Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。</p></li><li><p><strong>ASN.1</strong>抽象语法标记（Abstract Syntax Notation One） ASN.1是一种 ISO/ITU-T 标准，描述了一种对数据进行表示、编码、传输和解码的数据格式，ISO 协议套中的应用层协议使用了 ASN.1 来描述它们所传输的 PDU，这些协议包括：用于传输电子邮件的 X.400、用于目录服务的 X.500、用于 VoIP 的 H.323 和 SNMP（简单网络管理协议）。ASN.1 取得成功的一个主要原因是它与几个标准化编码规则相关，如基本编码规则（BER） -X.209 、规范编码规则（CER）、识别名编码规则（DER）、压缩编码规则（PER）和 XML编码规则（XER）。<br><strong>Unicode</strong>（统一码、万国码、单一码）是一种在计算机上使用的字符编码。Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。<br><strong>Base64</strong>是网络上最常见的用于传输8Bit字节代码的编码方式之一，可用于在HTTP环境下传递较长的标识信息。Base64 也会经常用作一个简单的“加密”来保护某些数据，而真正的加密通常都比较繁琐。Mozilla Thunderbird和Evolution用Base64来保密电子邮件密码<br><strong>Quoted-printable</strong>是使用可打印的ASCII字符 (如字母、数字与”=”)表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据。这被定义为MIME content transfer encoding，用于e-mail。</p><p>邮件编码常用后两者</p></li><li><p>HTML是一种标记语言、用于描述文档结构，是Web世界的共同语言，浏览器应能解释符合HTML标准的页面且多个符合HTML标准的页面可相互链接。</p></li><li><p>LAMP（Linux- Apache-MySQL-PHP）网站架构是目前国际流行的Web框架，该框架包括：Linux操作系统，Apache网络服务器，MySQL数据库，Perl、PHP或者Python编程语言，所有组成产品均是开源软件，是国际上成熟的架构框架。该架构起源于Linux平台，由于是开源软件，建设成本很低。</p></li><li><p>Ethernet交换机转发帧可以采用直接交换方式、存储转发交换方式或者改进的直接交换方式。通常采用端口号/MAC地址映射表，支持虚拟局域网服务。</p></li><li><p>POP3邮件传递过程可以分为三个阶段：认证阶段、事务处理阶段、更新阶段</p><p>SMTP邮件传递过程可以分为三个阶段：连接建立阶段，邮件传送阶段，连接关闭阶段</p></li><li><p>NetBIOS是由IBM开发，工作于网络层驱动接口和传输层驱动接口之间，支持254个并发通信话路，名字服务可以采用UDP协议。</p></li><li><p>跳频扩频通信（Frequence Hopping Spread Spectum），英文缩写为FHSS，直接序列扩频（Direct Sequence Spread Spectrum），英文缩写为DSSS，点协调功能（Point Coordition Function），英文缩写为PCF，分布式协调功能（Distributed Coordition Function），英文缩写为DCF，虚拟监听（Virtual Carrier Sense），英文缩写为VCS</p></li><li><p>消息认证就是使意定的接收者能够检验收到的消息是否真实的方法，又称为<strong>完整性校验</strong>。信息的完整性认证方法的基本途径有两条：<strong>采用消息认证码（MAC）、采用篡改检测码（MDC）</strong>。消息认证方法很多，如认证信息的来源时可以采用通信双方事先约定各自发送消息所使用的通行字的方法，<strong>不需要使用公钥</strong>。密钥分发中心（KDC）是一个独立的可信网络实体，它可以为用户提供不同的对称密钥，<strong>当不采用公钥算法进行消息认证时，并不需要使用KDC，</strong></p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机四级 </tag>
            
            <tag> 知识点整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>manimTutorial</title>
      <link href="/2020/03/26/manimtutorial/"/>
      <url>/2020/03/26/manimtutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="manim基础教程"><a href="#manim基础教程" class="headerlink" title="manim基础教程"></a>manim基础教程</h1><p>注意：  </p><ol><li><p>本文参考YouTube主Theorem of Beethoven的视频与代码然后自己继续研究得到的，有些图片是ta视频截图得到的，可以说是他的教程文字化后的汉化版，根据GitHub主页，他来自墨西哥国立自治大学，感谢外国大佬的力量，除了自己写的部分的代码，有些代码来自TA的视频与GitHub，其人<a href="https://github.com/Elteoremadebeethoven" target="_blank" rel="noopener">GitHub主页</a>，大家有条件可以支持一下他的YouTube<br>其教程也被搬运到B站:</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;box-shadow: 10px 10px 5px #888888;">       <iframe src="//player.bilibili.com/player.html?aid=64023740&amp;bvid=BV1W4411Z7Zt&amp;cid=158849334&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;border-radius: 8px;">       </iframe>   </div></li><li><p>本人将于2019年9月2日开学，到时候可能忙于学业，不能做到跟进视频更新教程，其实目前教程已经大概涵盖70%的东西，到后面主要是自己读源代码自己分析，python基础很重要，有时间我还是会尽量更新的  </p></li><li>此教程虽在开源社区，但是请勿未经我允许转载，希望大家能共同维护个人劳动成果与开源精神</li><li>如果文档有错误或漏洞，或者有问题，欢迎在issue中提出，大家一起讨论，共同创建良好的学习环境</li></ol><h2 id="1-文件的执行"><a href="#1-文件的执行" class="headerlink" title="1. 文件的执行"></a>1. 文件的执行</h2><p><strong>命令行执行：python -m manim \path\to\yourfile.py [className] [-params]</strong></p><p><em>usage: manim.py [-h] [-p] [-w] [-s] [-l] [-m] [—high_quality] [-g] [-i] [-f]</em><br>                <em>[-t] [-q] [-a] [-o FILE_NAME] [-n START_AT_ANIMATION_NUMBER]</em><br>                <em>[-r RESOLUTION] [-c COLOR] [—sound] [—leave_progress_bars]</em><br>                <em>[—media_dir MEDIA_DIR]</em><br>                <em>[—video_dir VIDEO_DIR | —video_output_dir VIDEO_OUTPUT_DIR]</em><br>                <em>[—tex_dir TEX_DIR] [—livestream] [—to-twitch]</em><br>                <em>[—with-key TWITCH_KEY]</em><br>                <em>[file] [scene_names [scene_names …]]</em></p><p><em>positional arguments:</em><br>  <em>file                  path to file holding the python code for the scene</em><br>  <em>scene_names           Name of the Scene class you want to see</em></p><p><em>optional arguments:</em><br>  <em>-h, —help            show this help message and exit</em><br>  <em>-p, —preview         Automatically open the saved file once its done</em><br>  <em>-w, —write_to_movie  Render the scene as a movie file</em><br>  <em>-s, —save_last_frame</em>  <em>Save the last frame</em><br>  <em>-l, —low_quality     Render at a low quality (for faster rendering)</em><br>  <em>-m, —medium_quality  Render at a medium quality</em><br>  <em>—high_quality        Render at a high quality</em><br>  <em>-g, —save_pngs       Save each frame as a png</em><br>  <em>-i, —save_as_gif     Save the video as gif</em><br>  <em>-f, —show_file_in_finder</em> <em>Show the output file in finder</em><br>  <em>-t, —transparent     Render to a movie file with an alpha channel</em><br>  <em>-q, —quiet</em><br>  <em>-a, —write_all       Write all the scenes from a file</em><br>  <em>-o FILE_NAME, —file_name FILE_NAME</em>  <em>Specify the name of the output file, ifit should be</em><br>                        <em>different from the scene class name</em><br>  <em>-n START_AT_ANIMATION_NUMBER, —start_at_animation_number     START_AT_ANIMATION_NUMBER</em><br>                        <em>Start rendering not from the first animation,   butfrom another, specified by its index. If you passin two comma separated values, e.g. “3,6”, it will end the rendering at the second value</em><br>  <em>-r RESOLUTION, —resolution RESOLUTION</em> <em>Resolution, passed as “height,width”</em><br>  <em>-c COLOR, —color COLOR</em>  <em>Background color</em><br>  <em>—sound               Play a success/failure sound</em><br>  <em>—leave_progress_bars</em> <em>Leave progress bars displayed in terminal</em><br>  <em>—media_dir MEDIA_DIR</em> <em>directory to write media</em><br>  <em>—video_dir VIDEO_DIR</em> <em>directory to write file tree for video</em><br>  <em>—video_output_dir VIDEO_OUTPUT_DIR</em>  <em>directory to write video</em><br>  <em>—tex_dir TEX_DIR     directory to write tex</em><br>  <em>—livestream          Run in streaming mode</em><br>  <em>—to-twitch           Stream to twitch</em><br>  <em>—with-key TWITCH_KEY     Stream key for twitch</em>  </p><h3 id="1-1-保存为视频并立即播放"><a href="#1-1-保存为视频并立即播放" class="headerlink" title="1.1 保存为视频并立即播放"></a>1.1 <strong>保存为视频并立即播放</strong></h3><p>参数-p</p><p>如果有多个绘图类会出现列表让你选择</p><p>也可以直接指定类名(示例为Example类)生成对应的类名的视频</p><ul><li><p>fps = 15,宽854，高480：</p><pre class=" language-lang-bash"><code class="language-lang-bash">python -m manim \path\to\yourfile.py Example -pl</code></pre></li><li><p>fps = 30,宽1280，高720：</p><pre class=" language-lang-bash"><code class="language-lang-bash">python -m manim \path\to\yourfile.py Example -pm</code></pre></li><li><p>fps = 60,宽2560，高1440：</p><pre class=" language-lang-bash"><code class="language-lang-bash">python -m manim \path\to\yourfile.py Example -p</code></pre></li></ul><h3 id="1-2-保留帧"><a href="#1-2-保留帧" class="headerlink" title="1.2 保留帧"></a>1.2 <strong>保留帧</strong></h3><p>-s保留最后一帧</p><p>当有多个类的时候会出现选择项让你选择保留哪几个绘图类的最后一帧</p><ul><li><p>保留最后一帧并立即查看：</p><pre class=" language-lang-bash"><code class="language-lang-bash">python -m manim \path\to\yourfile.py Example -ps</code></pre></li><li><p>保留全部绘图类为视频：</p><pre class=" language-lang-bash"><code class="language-lang-bash">python -m manim \path\to\yourfile.py Example -alpython -m manim \path\to\yourfile.py Example -ampython -m manim \path\to\yourfile.py Example -a</code></pre></li><li><p>保留全部绘图类最后一帧：</p><pre class=" language-lang-bash"><code class="language-lang-bash">python -m manim \path\to\yourfile.py Example -as</code></pre></li></ul><h3 id="1-3-视频尺寸"><a href="#1-3-视频尺寸" class="headerlink" title="1.3 视频尺寸"></a>1.3 <strong>视频尺寸</strong></h3><p>-r HEIGHT WIDTH</p><ul><li><p>高度500 宽度600</p><pre class=" language-lang-bash"><code class="language-lang-bash">python -m manim \path\to\yourfile.py Example -plr 500 600</code></pre></li><li><p>默认为16/9因此默认可以仅设置高度不需要设置宽度</p><p>高度为500的视频：</p><pre class=" language-lang-bash"><code class="language-lang-bash">python -m manim \path\to\yourfile.py Example -plr 500</code></pre></li></ul><h3 id="1-4-视频通道"><a href="#1-4-视频通道" class="headerlink" title="1.4 视频通道"></a>1.4 <strong>视频通道</strong></h3><p>-t, —transparent         alpha通道，扩展名为mov</p><h3 id="1-5-保留进度显示条"><a href="#1-5-保留进度显示条" class="headerlink" title="1.5 保留进度显示条"></a>1.5 <strong>保留进度显示条</strong></h3><p>  —leave_progress_bars：</p><pre><code>python -m manim \path\to\yourfile.py Example -pl --leave_progress_barsMedia will be written to ./media\. You can change this behavior with the --media_dir flag.Animation 0: WriteTextMobject, etc.: 100%|##############################################################################################| 15/15 [00:00&lt;00:00, 32.48it/s] File ready at \path\to\video.mp4Played 2 animations</code></pre><h3 id="1-6-从某一个动画状态（animation）开始存为视频"><a href="#1-6-从某一个动画状态（animation）开始存为视频" class="headerlink" title="1.6 从某一个动画状态（animation）开始存为视频"></a>1.6 从某一个动画状态（animation）开始存为视频</h3><p> -n START_AT_ANIMATION_NUMBER, —start_at_animation_number START_AT_ANIMATION_NUMBER</p><p>不是从第一个动画开始渲染，而是从索引指定的另一个动画开始渲染。 如果您传入两个逗号分隔值，例如 “3,6”，它将以第二个值渲染</p><pre class=" language-lang-python"><code class="language-lang-python">class ShowGraph(Scene):     def construct(self):         print("dot = Dot()")        dot = Dot()        self.wait(2)        print("dot.to_edge(UL)")        dot.to_edge(UL)        self.play(FadeIn(dot))        self.wait(2)        print("text = TextMobject(\"text\")")        text = TextMobject("text")        self.wait(2)        print("text.to_corner(UP)")        text.to_corner(UP)        self.play(Write(text))        self.wait(2)</code></pre><p>不加起始渲染运行如下：</p><pre class=" language-lang-bash"><code class="language-lang-bash">PS E:\programing-engineering\manim-tutorial\manim> python -m manim .\1_text_format.py ShowGraph -pl --leave_progress_bars      Media will be written to ./media\. You can change this behavior with the --media_dir flag.dot = Dot()dot.to_edge(UL)Animation 1: FadeInDot: 100%|###########################################################################################################| 15/15 [00:00<00:00, 64.27it/s] text = TextMobject("text")text.to_corner(UP)Animation 4: WriteTextMobject: 100%|####################################################################################################| 15/15 [00:00<00:00, 39.79it/s] File ready at E:\programing-engineering\manim-tutorial\manim\media\videos\1_text_format\480p15\ShowGraph.mp4Played 6 animations</code></pre><p>增加起始渲染：</p><p>从刚才的没有渲染的输出可以看出animation 1是dot.to_edge(UL)后的FadeInDot动画，所以如果-n 2则从animation 2开始，所以开始dot就已经显示在屏幕上面了</p><pre class=" language-lang-bash"><code class="language-lang-bash">PS E:\programing-engineering\manim-tutorial\manim> python -m manim .\1_text_format.py ShowGraph -pl -n 2  --leave_progress_barsMedia will be written to ./media\. You can change this behavior with the --media_dir flag.dot = Dot()dot.to_edge(UL)Animation 1: FadeInDot: 100%|###########################################################################################################| 15/15 [00:00<00:00, 84.02it/s] text = TextMobject("text")text.to_corner(UP)Animation 4: WriteTextMobject: 100%|####################################################################################################| 15/15 [00:00<00:00, 58.52it/s] File ready at E:\programing-engineering\manim-tutorial\manim\media\videos\1_text_format\480p15\ShowGraph.mp4Played 6 animations</code></pre><p><img src="1565761708445.png" alt="1565761708445"></p><p>其他的参数不一一介绍，自行查看英文说明</p><h3 id="1-7-默认显示进度条"><a href="#1-7-默认显示进度条" class="headerlink" title="1.7 默认显示进度条"></a>1.7 默认显示进度条</h3><p>默认设置在manimlib/config.py，manimlib/extract_secne.py与manimlib/scene.py里进行定义，可以修改该文件进行修改默认配置,注意因为修改源码所以要小心</p><p>例如：在上面的三个文件里：</p><p>将里面所有的“—leave_progress_bars”和“leave_progress_bars”修改为“—remove_progress_bars”与“remove__progress_bars”,同时将</p><p><img src="1567668580431.png" alt="1567668580431"></p><p>此处的action改成不显示</p><p>这样如果加上—remove_progress_bars就不会显示进度条了，而默认是显示进度条的</p><h3 id="1-8-改变视频存放位置"><a href="#1-8-改变视频存放位置" class="headerlink" title="1.8 改变视频存放位置"></a>1.8 改变视频存放位置</h3><p>改变<em>manimlib/constants.py</em>中的：</p><pre class=" language-lang-python"><code class="language-lang-python">if not os.path.isdir(MEDIA_DIR):    MEDIA_DIR = "./media"</code></pre><p> 改<code>./media</code>为你想要存放的位置</p><h3 id="1-9-存为gif"><a href="#1-9-存为gif" class="headerlink" title="1.9 存为gif"></a>1.9 存为gif</h3><p>You can use <code>python -m manim animation.py name_scene -im</code> to render gif medium quality, or <code>python -m manim animation.py name_scene -gm</code> to render all frames as images, the images are saved in a folder</p><h2 id="2-显示操作"><a href="#2-显示操作" class="headerlink" title="2. 显示操作"></a>2. 显示操作</h2><h3 id="2-1-基本步骤（以TextMobject为例）"><a href="#2-1-基本步骤（以TextMobject为例）" class="headerlink" title="2.1 基本步骤（以TextMobject为例）"></a>2.1 基本步骤（以TextMobject为例）</h3><pre class=" language-lang-python"><code class="language-lang-python">from manimlib.imports import *class WriteText(Scene):     def construct(self):         text = TextMobject("A Text")        text.to_edge(UP)        text.move_to(1*UP+0.1*RIGHT)          //以play为例        self.play(SomeWriteMethod(text),run_time = seconds)        self.wait(seconds)        self.remove(text)</code></pre><h3 id="2-5-位置相关的函数"><a href="#2-5-位置相关的函数" class="headerlink" title="2.5 位置相关的函数"></a>2.5 位置相关的函数</h3><h4 id="2-5-1to-edge-和to-corner"><a href="#2-5-1to-edge-和to-corner" class="headerlink" title="2.5.1to_edge()和to_corner()"></a><strong>2.5.1</strong>to_edge()和to_corner()</h4><p><strong>someObject.to_edge(DIRECTION的线性组合,buff = number)</strong></p><p><strong>someObject.to_corner(DIRECTION的四个组合方向,buff = number)</strong></p><p>to_edge参数可以是<strong>任意方向</strong>(方向有哪些见附录中方向常数列表)以及它们的线性组合，如<strong>0.1*RIGHT+0.2*UP</strong>，buff 两者的边缘的距离</p><p>to_corner仅接受组合方向<strong>UR，UL，DR，DL</strong></p><p><img src="1565752494266.png" alt="1565752494266"></p><ul><li>如果没有to_edge和to_center默认为中间（<strong>ORIGIN</strong>）</li><li><strong>someObject.to_edge(UP+RIGHT)</strong>完全等效于<strong>someObject.to_corner(UR)</strong>,其余四个方向同理</li></ul><h4 id="2-5-2-move-to"><a href="#2-5-2-move-to" class="headerlink" title="2.5.2 move_to()"></a>2.5.2 move_to()</h4><p><strong>someObject.move_to(DIRECTION的线性组合 or numpy的向量)</strong></p><p>在当前位置移动到对应的位置</p><p>参数可以是<strong>UP，DOWN，LEFT，RIGHT等</strong>的倍数，可以非整数，单位宽度大概是4倍默认字体的行高，<strong>下面只要跟这八个个固定值有关的均是如此</strong></p><pre class=" language-lang-python"><code class="language-lang-python">someObject.move_to(UP+2*RIGHT)</code></pre><p>参数也可以是numpy向量：</p><pre class=" language-lang-python"><code class="language-lang-python">vec = np.array([1,2,0])someObject.move_to(vec)</code></pre><p>因为图案的位置向量可以由get_center得到，所以可以如下操作：</p><pre class=" language-lang-python"><code class="language-lang-python">someObject.move_to(someObject2.get_center()+2*RIGHT)</code></pre><p>参数还可以是另外一个图案，表示的位置是该图案的几何中心：</p><pre class=" language-lang-python"><code class="language-lang-python">someObject.move_to(someObject2)</code></pre><h4 id="2-5-3-next-to"><a href="#2-5-3-next-to" class="headerlink" title="2.5.3 next_to()"></a>2.5.3 next_to()</h4><p><strong>someObject1.next_to(someObject2,DIRECTION,buff=number)</strong> </p><p>someObject1对于someObject2的相对位置</p><p>与move_to的区别在于，next_to表示的是边界的距离，而不是中心距离</p><p><img src="1565755487243.png" alt="1565755487243"></p><p>如：text1.next_to(text2,LEFT,buff=2) ：</p><p><img src="1565702556749.png" alt="1565702556749"></p><h4 id="2-5-4-shift"><a href="#2-5-4-shift" class="headerlink" title="2.5.4 shift()"></a>2.5.4 shift()</h4><p><strong>someObject.shift(DIRECTION*number)：</strong></p><p>自己垂直方向平移</p><h4 id="2-5-5-rotate"><a href="#2-5-5-rotate" class="headerlink" title="2.5.5 rotate()"></a>2.5.5 rotate()</h4><p><strong>someObject.rotate(PI*number或者number，point)：</strong> </p><p>逆时针旋转</p><p>如果相对图案为空，则自旋</p><p>如：</p><pre class=" language-lang-python"><code class="language-lang-python">class RotateObject(Scene):    def construct(self):        textM = TextMobject("Text")        textC = TextMobject("Reference text")        textM.shift(UP)        textM.rotate(PI/4)         self.play(Write(textM),Write(textC))        self.wait(2)</code></pre><p><img src="1565702942360.png" alt="1565702942360"></p><p>否则相对 相对图案旋转：</p><pre class=" language-lang-python"><code class="language-lang-python">class RotateObject(Scene):    def construct(self):        textM = TextMobject("Text")        textC = TextMobject("Reference text")        textM.rotate(PI/4,textC)         self.play(Write(textM),Write(textC))        self.wait(2)</code></pre><h4 id="2-5-6-flip"><a href="#2-5-6-flip" class="headerlink" title="2.5.6 flip()"></a>2.5.6 flip()</h4><p><strong>someObject.flip(DIRECTION)：</strong></p><p>按照矢量量方向翻转180度，遵循右手定则。</p><p>如text.flip(UP)：</p><p><img src="1565703056789.png" alt="1565703056789"></p><h3 id="2-6-播放动画"><a href="#2-6-播放动画" class="headerlink" title="2.6 播放动画"></a>2.6 播放动画</h3><h4 id="2-6-1-play"><a href="#2-6-1-play" class="headerlink" title="2.6.1 play()"></a>2.6.1 <strong>play</strong>()</h4><p>动画效果，可以是多个text，这个函数是多线程的，所以不会阻塞就会进入下一行操作</p><p><em>（如果下一个操作是remove掉text而没有使用wait函数进行等待，最终效果会变成立即销毁text即没有显示text，下面的add也同理）</em></p><ol><li><p><strong>play(SomePlayMethod(someObject),run_time = seconds)：</strong>播放某种动画方法</p><p>如果希望并行同时播放多个动画，仅仅是python语法问题，给出如下例子模板：</p><pre class=" language-lang-python"><code class="language-lang-python">class concurrent(Scene):    def construct(self):        dot1 = Dot()        dot2 = Dot()        dot2.shift(UP)        dot3 = Dot()        dot3.shift(DOWN)        # 单个动画的演示        self.play(Write(dot1))        # 多个动画演示        self.play(*[            Transform(i.copy(),j) for i,j in zip([dot1,dot1],[dot2,dot3])            ])# 故意使用i,j是为了显示zip的使用        self.wait()</code></pre></li><li><p><strong>play(someObjectX.functionX,functionParamX,</strong></p><p>​     <strong>someObjectX.functionX,functionParamX,</strong></p><p><strong>……</strong></p><p><strong>run_time=seconds):同时改变某种或多种属性</strong></p><pre class=" language-lang-python"><code class="language-lang-python">class ChangeColorAndSizeAnimation(Scene):    def construct(self):        text = TextMobject("Text")        text.scale(2)        text.shift(LEFT*2)        self.play(Write(text))        self.wait()        self.play(                text.shift, RIGHT*2,                text.scale, 2,                text.set_color, RED,                run_time=2,            )        self.wait()</code></pre></li></ol><h5 id="2-6-1-1-显示动画函数SomePlayMethods"><a href="#2-6-1-1-显示动画函数SomePlayMethods" class="headerlink" title="2.6.1.1 显示动画函数SomePlayMethods"></a>2.6.1.1 显示动画函数SomePlayMethods</h5><p>动画函数，主要包含下列几个：</p><ul><li><p><em>\manimlib\animation\fading.py</em>：渐变效果 </p><p><strong>FadeXXX(someObject)</strong></p><ul><li>包含FadeIn，FadeInFromDown，FadeOutAndShiftDown，FadeInFromPoint，FadeInFromLarge等等</li><li>解释：fade in/out 渐入/出；shift down 垂直下降</li></ul></li><li><p><em>\manimlib\animation\creation.py</em>：书写效果</p><p><strong>ShowCreation(someObject)</strong></p><ul><li>无法清楚表达，具体可以自行尝试看效果</li></ul><p><strong>UnCreate(someObject)</strong></p><ul><li>倒放ShowCreation动画效果</li></ul><p><strong>DrawBorderThenFill(someObject)</strong></p><ul><li>画出边界然后填充</li></ul><p><strong>Write(someObject)</strong></p><ul><li>继承自DrawBorderThenFill，增加从左往右逐渐显示的效果</li></ul></li><li><p><em>\manimlib\animation\transform.py</em>从一个渐变成另一个</p><ul><li><strong>Transform(someObject1,someObject2)</strong></li><li><strong>ReplacementTransform(someObject1,someObject2)</strong></li></ul><p>两者的异同：</p><p><strong>共同点：</strong>显示特效相同</p><p><strong>不同点：</strong> <strong>Transform</strong>显示在画布上的object永远是someObject1</p><p>伪代码：</p><pre class=" language-lang-python"><code class="language-lang-python">Transform(someObject1,someObject2):    show someObject1 on screen    show the transform course of someObject1 to someObject2    someObject1 = someObject2    show updated someObject1 on screen</code></pre><p>​                <strong>ReplacementTransform</strong>显示在画布上的从someObject1变成了someObject2</p><p>伪代码：</p><pre class=" language-lang-python"><code class="language-lang-python">ReplacementTransform(someObject1,someObject2):    show someObject1 on screen    show the transform course of someObject1 to someObject2    someObject1 = someObject2    show someObject2 on screen    # 不同点在此    remove someObject1 from screen # 不是从内存删除，仅仅不可见</code></pre><p>用两段代码来看看效果：</p><pre class=" language-lang-python"><code class="language-lang-python">class TextArray(Scene):    def construct(self):        text = TextMobject("tex1","text2","text3")        text[0].shift(2*LEFT)        text[0].set_color(RED)        text[1].shift(LEFT)        text[1].set_color(BLUE)        self.play(Write(text[0]))        self.wait(2)        # 显示的还是text[0]只是text[0]值变成了text[1]        self.play(Transform(text[0],text[1]))        # 此时没有让text[0]消失，但让text[1]显现并转换为text[2]        # 最终text[0]的值为初始text[1]的值，text[1]的值为初始text[2]的值        self.play(Transform(text[1],text[2]))        # 最终屏幕上显示的是text[0]和text[1]        self.wait(3)</code></pre><p><img src="1565773952504.png" alt="1565773952504"></p><p><img src="1565773963920.png" alt="1565773963920"></p><p><img src="1565773975419.png" alt="1565773975419"></p><p>将上面的替换成ReplacementTransform：</p><pre class=" language-lang-python"><code class="language-lang-python">class TextArray(Scene):    def construct(self):        text = TextMobject("tex1","text2","text3")        text[0].shift(2*LEFT)        text[0].set_color(RED)        text[1].shift(LEFT)        text[1].set_color(BLUE)        self.play(Write(text[0]))        self.wait(2)        # 显示的是text[1]但是text[0]值也变成了text[1]，text[0]消失        self.play(ReplacementTransform(text[0],text[1]))        # 显示text[2],text[1]值也变成了text[2]，text[1]消失        # 最终text[0]的值为初始text[1]的值，text[1]的值为初始text[2]的值        self.play(ReplacementTransform(text[1],text[2]))        # 最终显示的是text[2]        self.wait(3)</code></pre><p>最后一幅图不一样：</p><p><img src="1565774075040.png" alt="1565774075040"></p><p><strong>如果希望不要改变someObject1的值可以使用：someObject1.copy()进行深度拷贝</strong></p><p>someObject1.copy()执行的伪代码：</p><pre class=" language-lang-python"><code class="language-lang-python">someObject1.copy():    new object    object.allValue = self.allValue    return object</code></pre></li><li><p><strong>MoveToTarget(someObject):</strong></p><p>仅对自身产生变化</p><p>比较简单，用示例代码即可以看懂：</p><pre class=" language-lang-python"><code class="language-lang-python">class ChangeColorAndSizeAnimation(Scene):    def construct(self):         text = TextMobject("Text")         self.play(Write(text))         text.generate_target()         text.target = TextMobject("Target")         text.target.set_color(RED)         text.target.scale(2)         text.target.shift(LEFT)         self.play(MoveToTarget(text),run_time = 2)         self.wait()</code></pre></li><li><p><em>\manimlib\animation\growing.py</em></p><ul><li><p><strong>GrowFromXXX(someObject)</strong></p><p>GrowFromCenter,GrowFromPoint,GrowFromEdge,GrowArrow等等</p></li></ul></li><li><p><em>manimlib\animation\update.py</em></p><ul><li><p><strong>UpdateFromFunc(obj,update_function)</strong></p><p>同步播放,很好理解，见例子：</p><p>更多同步并发的播放见<strong>2.9</strong></p><pre class=" language-lang-python"><code class="language-lang-python">class Updater(Scene):    def construct(self):        dot = Dot()        text = TextMobject("Label")\               .next_to(dot,RIGHT,buff=SMALL_BUFF)        self.add(dot,text)        def update_text(obj):            obj.next_to(dot,RIGHT,buff=SMALL_BUFF)        # Only works in play        self.play(                dot.shift,UP*2,                UpdateFromFunc(text,update_text)            )        self.wait()</code></pre></li></ul></li></ul><h5 id="2-6-1-2-run-time"><a href="#2-6-1-2-run-time" class="headerlink" title="2.6.1.2 run_time"></a>2.6.1.2 run_time</h5><p>动画从开始到结束所用的时间，决定了<strong>动画的快慢</strong>（动画write的快慢是固定的不由runtime决定，但是到达了runtime又没有后面的wait，write会被截断），而非动画播放完了继续等待到run_time指定的时间，注意如果runtime太短可能导致动画write</p><h4 id="2-6-1-3-rate-func"><a href="#2-6-1-3-rate-func" class="headerlink" title="2.6.1.3 rate_func"></a>2.6.1.3 rate_func</h4><p>直译为速度函数，即内定的动画函数</p><p>分为三个值：<strong>there_and_back来回，linear一去不复返，smooth平滑</strong>（速度先为0，然后加快，到了中间减速最后到达终点为0）</p><p>例：</p><pre class=" language-lang-python"><code class="language-lang-python"> self.play(                triangle.shift,RIGHT*2,                rate_func=smooth, # Change this with: linear,smooth                run_time=5            )</code></pre><h4 id="2-6-2-add"><a href="#2-6-2-add" class="headerlink" title="2.6.2 add()"></a>2.6.2 add()</h4><p><strong>add(someObject1,someObject2,…)</strong></p><p>无动画添加文字，可以是多个text</p><h4 id="2-6-3-wait"><a href="#2-6-3-wait" class="headerlink" title="2.6.3 wait()"></a>2.6.3 wait()</h4><p><strong>wait(int seconds)：</strong></p><p>等待动画停留时间，如果没有参数则默认等待到将动画播放完为止</p><h4 id="2-6-4-remove"><a href="#2-6-4-remove" class="headerlink" title="2.6.4 remove()"></a>2.6.4 remove()</h4><p><strong>remove(someObject1,someObject2,…)：</strong></p><p>移除text，可以是多个text，注意FadeOut类的动画虽然自带消失效果但是该变量还是会停留在内存中</p><h3 id="2-7-设置颜色"><a href="#2-7-设置颜色" class="headerlink" title="2.7 设置颜色"></a>2.7 设置颜色</h3><p><strong>someObject.set_color(COLOR)</strong></p><p>COLOR有哪些见附录的颜色一栏，COLOR本质上是一个字符串所以可以自定义字符串传入：</p><p><strong>someObject.set_color(string)</strong></p><p>如：</p><pre class=" language-lang-python"><code class="language-lang-python">someObject.set_color("#0000FF")</code></pre><h3 id="2-8-缩放大小"><a href="#2-8-缩放大小" class="headerlink" title="2.8 缩放大小"></a>2.8 缩放大小</h3><p><strong>someObject.scale(number)</strong></p><pre class=" language-lang-python"><code class="language-lang-python">class TextArray(Scene):    def construct(self):        dot1 = Dot()        dot1.scale(3)        dot1.shift(UP)        dot2 = Dot()        self.add(dot1,dot2)        self.wait(3)</code></pre><p><img src="1565769895077.png" alt="1565769895077"></p><h3 id="2-9-同步播放动画"><a href="#2-9-同步播放动画" class="headerlink" title="2.9 同步播放动画"></a>2.9 同步播放动画</h3><p>TODO：<strong>暂时没有时间理解源码</strong></p><p>让某一个物体（mobject）跟随另一个物体的移动而并行移动（使用其他移动方式，路径）</p><p><em>manimlib\mobject\mobject.py</em></p><ul><li><p><strong>add_updater(update_function, index=None, call_updater=True)</strong></p><ul><li>update_function：更新函数，函数传入一个object对象，函数内部有一系列对该对象和已知的对象进行的一系列操作，可以是lambda表达式</li></ul><p>例子：让一个点在“label”文字右边，随着文字的移动，始终保持在其右侧</p></li></ul><pre class=" language-lang-python"><code class="language-lang-python"># author:TBclass AddUpdater1(Scene):    def construct(self):        dot = Dot()        text = TextMobject("Label")\               .next_to(dot,RIGHT,buff=SMALL_BUFF)        self.add(dot,text)        # Update function 更新函数        def update_text(obj):            obj.next_to(dot,RIGHT,buff=SMALL_BUFF)        # Add update function to the objects        # 把更新函数加给对象        text.add_updater(update_text)        # 如果想简洁，lambda表达式如下：        # text.add_updater(lambda m: m.next_to(dot,RIGHT,buff=SMALL_BUFF))        # 此时下面的remove_updater(update_text)不能继续使用，需要改为clear_updaters        # Add the object again 重新加入text        # 注意这个步骤不能少，否则看不到！！！        # 即使之前加入过，现在还是要重新加入        self.add(text)        self.play(dot.shift,UP*2)        # Remove update function        text.remove_updater(update_text)        self.wait()</code></pre><ul><li><p><strong>remove_updater(update_function)</strong>取消并行播放函数</p></li><li><p><strong>clear_updaters(recursive=True)</strong>取消所有的并行播放函数</p></li><li><p><strong>UpdateFromFunc(Animation)</strong></p><p>见<strong>2.6.1.1</strong>,注意这个函数仅在play函数中生效，play结束后就不会继续同步</p></li></ul><p>更多例子（有时间再补充）：<a href="https://github.com/Elteoremadebeethoven/AnimationsWithManim/blob/master/English/update_successions/update_successions.py" target="_blank" rel="noopener">TB的更新函数页面</a></p><h2 id="3-text数组"><a href="#3-text数组" class="headerlink" title="3. text数组"></a>3. text数组</h2><p>在2中所有的显示方法几乎都可以对数组成立，</p><p>如文字串：</p><pre class=" language-lang-python"><code class="language-lang-python">class TextArray(Scene):    def construct(self):        text = TextMobject("A","B","C","D","E","F")        text[0].set_color(RED)        text[1].set_color(ORANGE)        text[2].set_color(YELLOW)        text[3].set_color(GREEN)        text[4].set_color(BLUE) #Hexadecimal color        self.play(Write(text))        self.wait(2)</code></pre><p><img src="1565768302203.png" alt="1565768302203"></p><p>还可以拼接为LaTeX串(此处不能用TextMobject代替，否则报错)：</p><pre class=" language-lang-python"><code class="language-lang-python">class TexArray(Scene):    def construct(self):        text = TexMobject("A","{B","\\over","C}","D","E")        text[0].set_color(RED)        text[1].set_color(ORANGE)        text[2].set_color(YELLOW)        text[3].set_color(GREEN)        text[4].set_color(BLUE)        text[5].set_color(BLUE)        self.play(Write(text))        self.wait(2)</code></pre><p><img src="1565769578088.png" alt="1565769578088"></p><p>对于数组可以直接如同对单个object操作,如：</p><pre class=" language-lang-python"><code class="language-lang-python"> text.shift(UP)</code></pre><p><strong>注意：</strong></p><p><strong>text = TextMobject(string）是一维数组</strong></p><p><strong>当text = TextMobject(string1，string2，….)中所有的string均为字母的时候，text为二维数组但是每一个子数组大小仅为1</strong></p><p><strong>如果有任意一个string是多个字母则text是二维数组</strong></p><h2 id="4-基础动画类-Scene"><a href="#4-基础动画类-Scene" class="headerlink" title="4. 基础动画类 Scene"></a>4. 基础动画类 Scene</h2><p>所有的动画均是scene类的子类产生的，因此scene的功能比较少，主要是对一些基础的属性进行配置</p><p><strong><em>\manimlib\scene\scene.py</em></strong></p><p>变量的值得初始定义见下：</p><pre class=" language-lang-python"><code class="language-lang-python"># \manimlib\scene\scene.pyCONFIG = {        "camera_class": Camera,        "camera_config": {},        "file_writer_config": {},        "skip_animations": False,        "always_update_mobjects": False,        "random_seed": 0,        "start_at_animation_number": None,        "end_at_animation_number": None,        "leave_progress_bars": False,    }</code></pre><p>其中<strong>camera_config</strong>是对视频的处理，由<strong>camera类</strong>完成:    </p><p><strong><em>\manimlib\camera\camera.py</em></strong></p><pre class=" language-lang-python"><code class="language-lang-python"># \manimlib\camera\camera.pyCONFIG = {# 背景颜色        "background_image": None,# 视频的高宽与帧率        "pixel_height": DEFAULT_PIXEL_HEIGHT,        "pixel_width": DEFAULT_PIXEL_WIDTH,        "frame_rate": DEFAULT_FRAME_RATE,# Note: frame height and width will be resized to match# the pixel aspect ratio# FRAME_HEIGHT = 8.0# FRAME_WIDTH = FRAME_HEIGHT * DEFAULT_PIXEL_WIDTH /                         DEFAULT_PIXEL_HEIGHT        "frame_height": FRAME_HEIGHT,        "frame_width": FRAME_WIDTH,# 默认方向        "frame_center": ORIGIN,# 背景颜色        "background_color": BLACK,        "background_opacity": 1,# Points in vectorized mobjects with norm greater# than this value will be rescaled.        "max_allowable_norm": FRAME_WIDTH,        "image_mode": "RGBA",        "n_channels": 4,        "pixel_array_dtype": 'uint8',# z_buff_func is only used if the flag above is set to True.# round z coordinate to nearest hundredth when comparring        "z_buff_func": lambda m: np.round(m.get_center()[2], 2),        "cairo_line_width_multiple": 0.01,    }</code></pre><p>所有的动画都是继承自Scene,所以动画的某些特定的属性可以通过CONFIG修改：</p><p>例子：</p><p>插入背景图片</p><pre class=" language-lang-python"><code class="language-lang-python">class TextLike1DArrays(Scene):    CONFIG={        "camera_config": {            "background_image": r"1.png",        },    }    def construct(self):        self.add(TextMobject("Text").set_color(RED))        self.wait()</code></pre><p><img src="1565833717545.png" alt="1565833717545"></p><h2 id="5-二维坐标类-GraphScene"><a href="#5-二维坐标类-GraphScene" class="headerlink" title="5. 二维坐标类 GraphScene"></a>5. 二维坐标类 GraphScene</h2><p><strong>\manimlib\scene\graph_scene.py</strong></p><p>继承自Scene类，用来绘制坐标</p><p>属性如下：</p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "x_min": -1,        "x_max": 10,        "x_axis_width": 9,        "x_tick_frequency": 1,        "x_leftmost_tick": None,  # Change if different from x_min        "x_labeled_nums": None,        "x_axis_label": "$x$",        "y_min": -1,        "y_max": 10,        "y_axis_height": 6,        "y_tick_frequency": 1,        "y_bottom_tick": None,  # Change if different from y_min        "y_labeled_nums": None,        "y_axis_label": "$y$",        "axes_color": GREY,        "graph_origin": 2.5 * DOWN + 4 * LEFT,        "exclude_zero_label": True,        "default_graph_colors": [BLUE, GREEN, YELLOW],        "default_derivative_color": GREEN,        "default_input_color": YELLOW,        "default_riemann_start_color": BLUE,        "default_riemann_end_color": GREEN,        "area_opacity": 0.8,        "num_rects": 50,    }</code></pre><p>一般流程是：</p><pre class=" language-lang-python"><code class="language-lang-python">class Graph2D(GraphScene):    def x_2(self, x):        return x**2    def construct(self):        self.setup_axes(animate=True)        graph = self.get_graph(self.x_2,color = GREEN,x_min = 2,x_max = 4)        self.play(ShowCreation(graph),run_time = 2)        self.wait()</code></pre><p><img src="1565835900946.png" alt="1565835900946"></p><h3 id="5-1-setup-axes"><a href="#5-1-setup-axes" class="headerlink" title="5.1 setup_axes()"></a>5.1 setup_axes()</h3><p><strong>setup_axes(animate=Bool)：</strong></p><p>默认没有动画效果，setup_axes(animate=True)则会显示动画 </p><h3 id="5-2-get-graph"><a href="#5-2-get-graph" class="headerlink" title="5.2 get_graph()"></a>5.2 get_graph()</h3><p><strong>get_graph(func, color=None,x_min=None,x_max=None, **kwargs)</strong></p><p>得到坐标系的句柄，并设置值</p><h3 id="5-3-coords-to-point"><a href="#5-3-coords-to-point" class="headerlink" title="5.3 coords_to_point()"></a>5.3 coords_to_point()</h3><p><strong>coords_to_point(x, y)</strong></p><p>坐标变成对应的帧中的点</p><h3 id="5-4-point-to-coords"><a href="#5-4-point-to-coords" class="headerlink" title="5.4 point_to_coords()"></a>5.4 point_to_coords()</h3><p><strong>point_to_coords(point)</strong></p><p>帧中的点转换为坐标，返回x,y组成的元组</p><h3 id="5-5-get-graph-label"><a href="#5-5-get-graph-label" class="headerlink" title="5.5 get_graph_label()"></a>5.5 get_graph_label()</h3><p><strong>get_graph_label(graph,label=”f(x)”, x_val=None,direction=RIGHT, buff=MED_SMALL_BUFF, color=None)</strong></p><p>graph：从graph中获得坐标标签</p><p>label默认为“f(x)”,可以改成自己想要的函数</p><p>x_val：x的取值范围</p><p>buff：距离边界的距离</p><p>color：颜色</p><h3 id="5-6-get-vertical-line-to-graph"><a href="#5-6-get-vertical-line-to-graph" class="headerlink" title="5.6 get_vertical_line_to_graph()"></a>5.6 get_vertical_line_to_graph()</h3><p><strong>get_vertical_line_to_graph(x, graph,line_class=Line,**line_kwargs)</strong></p><p>得到竖直线，起点为(x,0)终点为(x,f(x))</p><p>返回line_class类型的图像</p><h3 id="5-7-get-vertical-lines-to-graph"><a href="#5-7-get-vertical-lines-to-graph" class="headerlink" title="5.7 get_vertical_lines_to_graph()"></a>5.7 get_vertical_lines_to_graph()</h3><p><strong>get_vertical_lines_to_graph( graph,x_min=None,x_max=None, num_lines=20, **kwargs)</strong></p><p>同时得到画多条竖直线</p><p>返回line_class类型的VGroup</p><h3 id="5-8-改变坐标标签的颜色"><a href="#5-8-改变坐标标签的颜色" class="headerlink" title="5.8 改变坐标标签的颜色"></a>5.8 改变坐标标签的颜色</h3><blockquote><p><a href="https://github.com/Elteoremadebeethoven/AnimationsWithManim/blob/master/English/6a_plots_2D/change_label_colors.md#change-labels-colors-in-graphscene" target="_blank" rel="noopener">https://github.com/Elteoremadebeethoven/AnimationsWithManim/blob/master/English/6a_plots_2D/change_label_colors.md#change-labels-colors-in-graphscene</a></p><p>Change labels colors in <code>GraphScene</code></p><p>Add this to the <code>CONFIG</code> dictionary:在CONFIG中加入：</p><pre><code> "x_label_color":RED, "y_label_color":BLUE</code></pre><p>In the <code>setup_axes</code> method change the lines：在源码的setup_axes中的两句：</p><pre><code>         x_label = TextMobject(self.x_axis_label)         # and         y_label = TextMobject(self.y_axis_label)</code></pre><p>with改为</p><pre><code>         x_label = TextMobject(self.x_axis_label,color=self.x_label_color)         # and         y_label = TextMobject(self.x_axis_label,color=self.y_label_color)</code></pre></blockquote><p>效果：</p><p><img src="ChanceColorLabels.png" alt="img"></p><h2 id="6-文本类-TextMobject"><a href="#6-文本类-TextMobject" class="headerlink" title="6. 文本类 TextMobject"></a>6. 文本类 TextMobject</h2><ol><li><p><strong>TextMobject(string)：</strong>传入一个字符串</p><p>字符串可以是普通字符串或LaTeX格式或两者混合：</p><pre class=" language-lang-python"><code class="language-lang-python">TextMobject("This is a regular text")</code></pre><pre class=" language-lang-python"><code class="language-lang-python">TextMobject("\\displaystyle\\frac{x}{y}") # displaystyle使字体能显示正常大小</code></pre><p>两者混合则需要使用“$$”或者“$”包括：</p><pre class=" language-lang-python"><code class="language-lang-python">TextMobject("""            This is a regular text,            $\\displaystyle\\frac{x}{y}$,            $$x^2+y^2=a^2$$            """)</code></pre><p><img src="1565700699069.png" alt="1565700699069"></p><p>自然地，可以用LaTeX调整字体大小：</p><pre class=" language-lang-python"><code class="language-lang-python"> class SizeTextOnLaTeX(Scene):    def construct(self):        textHuge = TextMobject("{\\Huge Huge Text 012.\\#!?} Text")        texthuge = TextMobject("{\\huge huge Text 012.\\#!?} Text")        textLARGE = TextMobject("{\\LARGE LARGE Text 012.\\#!?} Text")        textLarge = TextMobject("{\\Large Large Text 012.\\#!?} Text")        textlarge = TextMobject("{\\large large Text 012.\\#!?} Text")        textNormal = TextMobject("{\\normalsize normal Text 012.\\#!?} Text")        textsmall = TextMobject("{\\small small Text 012.\\#!?} Texto normal")        textfootnotesize = TextMobject("{\\footnotesize footnotesize Text 012.\\#!?} Text")        textscriptsize = TextMobject("{\\scriptsize scriptsize Text 012.\\#!?} Text")        texttiny = TextMobject("{\\tiny tiny Texto 012.\\#!?} Text normal")        textHuge.to_edge(UP)        texthuge.next_to(textHuge,DOWN,buff=0.1)        textLARGE.next_to(texthuge,DOWN,buff=0.1)        textLarge.next_to(textLARGE,DOWN,buff=0.1)        textlarge.next_to(textLarge,DOWN,buff=0.1)        textNormal.next_to(textlarge,DOWN,buff=0.1)        textsmall.next_to(textNormal,DOWN,buff=0.1)        textfootnotesize.next_to(textsmall,DOWN,buff=0.1)        textscriptsize.next_to(textfootnotesize,DOWN,buff=0.1)        texttiny.next_to(textscriptsize,DOWN,buff=0.1)        self.add(textHuge,texthuge,textLARGE,textLarge,textlarge,textNormal,textsmall,textfootnotesize,textscriptsize,texttiny)        self.wait(3)</code></pre><p><img src="1565704370228.png" alt="1565704370228"></p></li><li><p><strong>TextMobject(string1,string2,string3,…)：</strong>传入多个字符串，返回TextMobject数组，可以按照下表索引数组的值</p></li></ol><h2 id="7-LaTeX文本类-TexMobject"><a href="#7-LaTeX文本类-TexMobject" class="headerlink" title="7. LaTeX文本类 TexMobject"></a>7. LaTeX文本类 TexMobject</h2><p><strong><em>\manimlib\mobject\svg\tex_mobject.py</em></strong></p><p>显示为LaTeX格式(在想要LaTeX字符串按照数组显示时必须使用这个实现)</p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "template_tex_file_body": TEMPLATE_TEX_FILE_BODY,        # 笔画宽度        "stroke_width": 0,        # 填充不透明度        "fill_opacity": 1.0,        # 笔画的描边宽度        "background_stroke_width": 1,        # 笔画的描边颜色        "background_stroke_color": BLACK,        "should_center": True,        "height": None,        "organize_left_to_right": False,        "alignment": "",    }</code></pre><p>例：</p><pre class=" language-lang-python"><code class="language-lang-python">class Formula(Scene):     def construct(self):         formula = TexMobject("This is a sentence")        self.play(Write(formula))        self.wait(3)</code></pre><p><img src="1565769340216.png" alt="1565769340216"></p><h2 id="8-二维图形类"><a href="#8-二维图形类" class="headerlink" title="8. 二维图形类"></a>8. 二维图形类</h2><p><strong><em>\manimlib\mobject\geometry.py</em></strong></p><p>TODO：待完善</p><h3 id="8-1-点Dot"><a href="#8-1-点Dot" class="headerlink" title="8.1 点Dot"></a>8.1 点Dot</h3><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "radius": DEFAULT_DOT_RADIUS,        "stroke_width": 0,        "fill_opacity": 1.0,        "color": WHITE    }</code></pre><h3 id="8-2-圆形Circle"><a href="#8-2-圆形Circle" class="headerlink" title="8.2 圆形Circle"></a>8.2 圆形Circle</h3><p>继承自Arc</p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "color": RED,        "close_new_points": True,        "anchors_span_full_range": False    }</code></pre><h3 id="8-3-环Annulus"><a href="#8-3-环Annulus" class="headerlink" title="8.3 环Annulus"></a>8.3 环Annulus</h3><p>继承自圆形</p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "inner_radius": 1,        "outer_radius": 2,        "fill_opacity": 1,        "stroke_width": 0,        "color": WHITE,        "mark_paths_closed": False,    }</code></pre><h3 id="8-4-长方形Rectangle"><a href="#8-4-长方形Rectangle" class="headerlink" title="8.4 长方形Rectangle"></a>8.4 长方形Rectangle</h3><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "color": WHITE,        "height": 2.0,        "width": 4.0,        "mark_paths_closed": True,        "close_new_points": True,    }</code></pre><h3 id="8-5-方形Square"><a href="#8-5-方形Square" class="headerlink" title="8.5 方形Square"></a>8.5 方形Square</h3><p>继承自长方形</p><pre class=" language-lang-python"><code class="language-lang-python"> CONFIG = {         # 边长        "side_length": 2.0,    }</code></pre><h3 id="8-6-椭圆Ellipse"><a href="#8-6-椭圆Ellipse" class="headerlink" title="8.6 椭圆Ellipse"></a>8.6 椭圆Ellipse</h3><p>继承自圆形</p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "width": 2,        "height": 1    }</code></pre><h3 id="8-7-弧Arc"><a href="#8-7-弧Arc" class="headerlink" title="8.7 弧Arc"></a>8.7 弧Arc</h3><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "radius": 1.0,        "num_components": 9,        "anchors_span_full_range": True,        "arc_center": ORIGIN,    }</code></pre><h3 id="8-8-线Line"><a href="#8-8-线Line" class="headerlink" title="8.8 线Line"></a>8.8 线Line</h3><p><strong>Line(start=LEFT, end=RIGHT, **kwargs)</strong></p><p>start,end:起点终点，形式是np向量</p><p>kwargs为配置信息，继承自VMobject</p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "fill_color": None,        "fill_opacity": 0.0,        "stroke_color": None,        "stroke_opacity": 1.0,        "stroke_width": DEFAULT_STROKE_WIDTH,        # The purpose of background stroke is to have        # something that won't overlap the fill, e.g.        # For text against some textured background        "background_stroke_color": BLACK,        "background_stroke_opacity": 1.0,        "background_stroke_width": 0,        # When a color c is set, there will be a second color        # computed based on interpolating c to WHITE by with        # sheen_factor, and the display will gradient to this        # secondary color in the direction of sheen_direction.        "sheen_factor": 0.0,        "sheen_direction": UL,        # Indicates that it will not be displayed, but        # that it should count in parent mobject's path        "close_new_points": False,        "pre_function_handle_to_anchor_scale_factor": 0.01,        "make_smooth_after_applying_functions": False,        "background_image_file": None,        "shade_in_3d": False,        # This is within a pixel        # TODO, do we care about accounting for        # varying zoom levels?        "tolerance_for_point_equality": 1e-6,        "n_points_per_cubic_curve": 4,    }</code></pre><h2 id="9-三维图形类"><a href="#9-三维图形类" class="headerlink" title="9. 三维图形类"></a>9. 三维图形类</h2><p><strong><em>\manimlib\mobject\three_dimensions.py</em></strong></p><h3 id="9-1-球-Sphere"><a href="#9-1-球-Sphere" class="headerlink" title="9.1 球 Sphere"></a>9.1 球 Sphere</h3><p>继承自ParametricSurface,实现通过绘制三维多边形曲面实现的，具体看源码</p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "resolution": (12, 24),        "radius": 1,        "u_min": 0.001,        "u_max": PI - 0.001,        "v_min": 0,        "v_max": TAU,    }</code></pre><h3 id="9-2-立方-Cube"><a href="#9-2-立方-Cube" class="headerlink" title="9.2 立方 Cube"></a>9.2 立方 Cube</h3><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "fill_opacity": 0.75,        "fill_color": BLUE,        "stroke_width": 0,        "side_length": 2,    }</code></pre><h3 id="9-3-棱柱Prism"><a href="#9-3-棱柱Prism" class="headerlink" title="9.3 棱柱Prism"></a>9.3 棱柱Prism</h3><p>继承自cube</p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "dimensions": [3, 2, 1]    }</code></pre><h3 id="9-4-参数曲面-ParametricSurface"><a href="#9-4-参数曲面-ParametricSurface" class="headerlink" title="9.4 参数曲面 ParametricSurface"></a>9.4 参数曲面 ParametricSurface</h3><p>参数方程表达的曲面</p><p><strong>ParametricSurface(func, **kwargs)</strong></p><pre class=" language-lang-python"><code class="language-lang-python"> CONFIG = {        "u_min": 0,        "u_max": 1,        "v_min": 0,        "v_max": 1,        "resolution": 32,        "surface_piece_config": {},        "fill_color": BLUE_D,        "fill_opacity": 1.0,        "checkerboard_colors": [BLUE_D, BLUE_E],        "stroke_color": LIGHT_GREY,        "stroke_width": 0.5,        "should_make_jagged": False,        "pre_function_handle_to_anchor_scale_factor": 0.00001,    }</code></pre><p>func:自定义的方程，此方程传入两个参数，返回三维向量，每一个分量均是传入两个自变量的表达式</p><p>如：</p><pre class=" language-lang-python"><code class="language-lang-python">def func(x, y):    return np.array([x**2,y+2,x**2 - y**2])</code></pre><p>绘制三维曲面的例子：</p><pre class=" language-lang-python"><code class="language-lang-python">class SurfacesAnimation(ThreeDScene):    def construct(self):        axes = ThreeDAxes()        cylinder = ParametricSurface(            lambda u, v: np.array([                np.cos(TAU * v),                np.sin(TAU * v),                2 * (1 - u)            ]),            resolution=(6, 32)).fade(0.5) #Resolution of the surfaces        paraboloid = ParametricSurface(            lambda u, v: np.array([                np.cos(v)*u,                np.sin(v)*u,                u**2            ]),v_max=TAU,            checkerboard_colors=[PURPLE_D, PURPLE_E],            resolution=(10, 32)).scale(2)        para_hyp = ParametricSurface(            lambda u, v: np.array([                u,                v,                u**2-v**2            ]),v_min=-2,v_max=2,u_min=-2,u_max=2,checkerboard_colors=[BLUE_D, BLUE_E],            resolution=(15, 32)).scale(1)        cone = ParametricSurface(            lambda u, v: np.array([                u*np.cos(v),                u*np.sin(v),                u            ]),v_min=0,v_max=TAU,u_min=-2,u_max=2,checkerboard_colors=[GREEN_D, GREEN_E],            resolution=(15, 32)).scale(1)        hip_one_side = ParametricSurface(            lambda u, v: np.array([                np.cosh(u)*np.cos(v),                np.cosh(u)*np.sin(v),                np.sinh(u)            ]),v_min=0,v_max=TAU,u_min=-2,u_max=2,checkerboard_colors=[YELLOW_D, YELLOW_E],            resolution=(15, 32))        ellipsoid=ParametricSurface(            lambda u, v: np.array([                1*np.cos(u)*np.cos(v),                2*np.cos(u)*np.sin(v),                0.5*np.sin(u)            ]),v_min=0,v_max=TAU,u_min=-PI/2,u_max=PI/2,checkerboard_colors=[TEAL_D, TEAL_E],            resolution=(15, 32)).scale(2)        sphere = ParametricSurface(            lambda u, v: np.array([                1.5*np.cos(u)*np.cos(v),                1.5*np.cos(u)*np.sin(v),                1.5*np.sin(u)            ]),v_min=0,v_max=TAU,u_min=-PI/2,u_max=PI/2,checkerboard_colors=[RED_D, RED_E],            resolution=(15, 32)).scale(2)        self.set_camera_orientation(phi=75 * DEGREES)        self.begin_ambient_camera_rotation(rate=0.2)        self.add(axes)        self.play(Write(sphere))        self.wait()        self.play(ReplacementTransform(sphere,ellipsoid))        self.wait()        self.play(ReplacementTransform(ellipsoid,cone))        self.wait()        self.play(ReplacementTransform(cone,hip_one_side))        self.wait()        self.play(ReplacementTransform(hip_one_side,para_hyp))        self.wait()        self.play(ReplacementTransform(para_hyp,paraboloid))        self.wait()        self.play(ReplacementTransform(paraboloid,cylinder))        self.wait()        self.play(FadeOut(cylinder))</code></pre><h3 id="9-5-参数曲线-ParametricFunction"><a href="#9-5-参数曲线-ParametricFunction" class="headerlink" title="9.5 参数曲线 ParametricFunction"></a>9.5 参数曲线 ParametricFunction</h3><p><strong>ParametricSurface(func, **kwargs)</strong></p><p>func:自定义的方程，此方程传入一个参数，返回三维向量，每一个分量均是传入自变量的表达式</p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "t_min": 0,        "t_max": 1,        "step_size": 0.01,  # Use "auto" (lowercase) for automatic step size        "dt": 1e-8,        # TODO, be smarter about figuring these out?        "discontinuities": [],    }</code></pre><p>例：</p><pre class=" language-lang-python"><code class="language-lang-python">class ParametricCurve2(ThreeDScene):    def construct(self):        curve1=ParametricFunction(                lambda u : np.array([                1.2*np.cos(u),                1.2*np.sin(u),                u/2            ]),color=RED,t_min=-TAU,t_max=TAU,            )        curve2=ParametricFunction(                lambda u : np.array([                1.2*np.cos(u),                1.2*np.sin(u),                u            ]),color=RED,t_min=-TAU,t_max=TAU,            )        curve1.set_shade_in_3d(True)        curve2.set_shade_in_3d(True)        axes = ThreeDAxes()        self.add(axes)        self.set_camera_orientation(phi=80 * DEGREES,theta=-60*DEGREES)        self.begin_ambient_camera_rotation(rate=0.1)         self.play(ShowCreation(curve1))        self.wait()        self.play(Transform(curve1,curve2),rate_func=there_and_back,run_time=3)        self.wait()</code></pre><h2 id="10-群组类VGroup"><a href="#10-群组类VGroup" class="headerlink" title="10. 群组类VGroup"></a>10. 群组类VGroup</h2><p>可以将多个图像合并为一个组进行批量同步操作(自我理解为Vector Group的缩写)</p><p><strong>someObjectGroup = VGroup(someObject1,someObject2,…)</strong></p><h3 id="10-1-arrange"><a href="#10-1-arrange" class="headerlink" title="10.1 arrange()"></a>10.1 arrange()</h3><p><strong>someObjectGroup.arrange(DIRECTION,aligned_edge = DIRECTION,buff=number)</strong></p><p><strong>DIRECTION：</strong>以someObject1,someObject2,…顺序按照此方向排列</p><p><strong>aligned_edge：</strong>对齐</p><p><strong>buff：</strong>成员之间的距离</p><p>例：</p><pre class=" language-lang-python"><code class="language-lang-python">class ArrangeObjects(Scene):    def construct(self):        text1 = TextMobject("text1")        text2 = TextMobject("text2 text2")        text3 = TextMobject("text3 text3 text3")        textgroup = VGroup(text1,text2,text3)        textgroup.arrange(            UP,            aligned_edge = LEFT,            buff=0.4        )        self.add(textgroup)        self.wait()</code></pre><p><img src="1565844643807.png" alt="1565844643807"></p><p>动画效果：</p><p>因为arrange第一个参数不在config里面，需要单独放在外面</p><pre class=" language-lang-python"><code class="language-lang-python">self.play(            text_group.arrange,            UP,            {"aligned_edge":RIGHT,"buff":2}        )</code></pre><h2 id="11-相机参数"><a href="#11-相机参数" class="headerlink" title="11. 相机参数"></a>11. 相机参数</h2><p>相机是针对3D动画类(<strong>ThreeDScene</strong>)的方法</p><p><strong>\manimlib\scene\three_d_scene.py</strong></p><p>将视频的视窗看做相机，就可以通过调整相机的远近，角度来观察三维物体，这就是相机类的作用</p><h3 id="11-1-set-camera-orientation"><a href="#11-1-set-camera-orientation" class="headerlink" title="11.1 set_camera_orientation"></a>11.1 set_camera_orientation</h3><p><strong>threeDScene.set_camera_orientation(phi=degrees1,theta=degrees2,gamma=degrees3,distance=number)</strong></p><p>设置相机的角度</p><h3 id="11-2-move-camera"><a href="#11-2-move-camera" class="headerlink" title="11.2 move_camera"></a>11.2 move_camera</h3><p><strong>threeDScene.move_camera(phi=None,theta=None, distance=None, gamma=None, frame_center=None,added_anims=[],**kwargs)</strong></p><p>例子：</p><pre class=" language-lang-python"><code class="language-lang-python">class MoveCamera2(ThreeDScene):    def construct(self):        axes = ThreeDAxes()        circle=Circle()        self.set_camera_orientation(phi=80 * DEGREES)                   self.play(ShowCreation(circle),ShowCreation(axes))        #Start move camera        self.begin_ambient_camera_rotation(rate=0.1)                    self.wait(5)        #Stop move camera        self.stop_ambient_camera_rotation()                             #Return the position of the camera        self.move_camera(phi=80*DEGREES,theta=-PI/2)                    self.wait()</code></pre><h3 id="11-3-set-to-default-angled-camera-orientation"><a href="#11-3-set-to-default-angled-camera-orientation" class="headerlink" title="11.3 set_to_default_angled_camera_orientation"></a>11.3 set_to_default_angled_camera_orientation</h3><p>还原为默认角度</p><h3 id="11-4-add-fixed-in-frame-mobjects"><a href="#11-4-add-fixed-in-frame-mobjects" class="headerlink" title="11.4 add_fixed_in_frame_mobjects"></a>11.4 add_fixed_in_frame_mobjects</h3><p>加入固定在屏幕的图像，此图像不随相机变化而变化</p><p><strong>add_fixed_in_frame_mobjects(*mobjects)</strong></p><p>例：</p><pre class=" language-lang-python"><code class="language-lang-python">class Text3D3(ThreeDScene):    def construct(self):        axes = ThreeDAxes()        self.set_camera_orientation(phi=75 * DEGREES,theta=-45*DEGREES)        text3d=TextMobject("This is a 3D text")        self.add_fixed_in_frame_mobjects(text3d) #<----- Add this        text3d.to_corner(UL)        self.add(axes)        self.begin_ambient_camera_rotation()        self.play(Write(text3d))        sphere = ParametricSurface(            lambda u, v: np.array([                1.5*np.cos(u)*np.cos(v),                1.5*np.cos(u)*np.sin(v),                1.5*np.sin(u)            ]),v_min=0,v_max=TAU,u_min=-PI/2,u_max=PI/2,checkerboard_colors=[RED_D, RED_E],            resolution=(15, 32)).scale(2)        self.play(LaggedStart(ShowCreation,sphere))        self.wait(2)</code></pre><h2 id="12-坐标系类"><a href="#12-坐标系类" class="headerlink" title="12. 坐标系类"></a>12. 坐标系类</h2><h3 id="12-0-数轴类-NumberLine"><a href="#12-0-数轴类-NumberLine" class="headerlink" title="12.0 数轴类 NumberLine"></a>12.0 数轴类 NumberLine</h3><p>继承于Line,属性如下：</p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "color": LIGHT_GREY,        # X的范围        "x_min": -FRAME_X_RADIUS,        "x_max": FRAME_X_RADIUS,        # 单元格的大小，默认和单位长度一致        "unit_size": 1,        # 是否包含刻度tick        "include_ticks": True,        # tick的尺寸，大小为：2个单位*tick_size        "tick_size": 0.1,        # tick的分布密度        "tick_frequency": 1,        # Defaults to value near x_min s.t. 0 is a tick        # TODO, rename this        "leftmost_tick": None,        # Change name        # 最长的tick,作者原意应该是作为数轴标识的tick,一般为中间的tick即原点，会画长一点        "numbers_with_elongated_ticks": [0],        # 标上数字        "include_numbers": False,        # 显示的数字格式        "numbers_to_show": None,        "longer_tick_multiple": 2,        # 中间的数字        "number_at_center": 0,        "number_scale_val": 0.75,        "label_direction": DOWN,        "line_to_number_buff": MED_SMALL_BUFF,        # 包含箭头        "include_tip": False,        # tip:箭头，下面两个是其尺寸设置        "tip_width": 0.25,        "tip_height": 0.25,        "decimal_number_config": {            "num_decimal_places": 0,        },        # 从数字标记中去掉0这个标记        "exclude_zero_from_default_numbers": False,    }</code></pre><p>注意其中x_min，x_max均为帧的左右范围即每帧的最左边和最右边</p><p><img src="1567675075732.png" alt="1567675075732"></p><p>本质上来说，数轴是一条线（Line），每一个间隔（tick）均为小的线(Line)</p><p>整个构建流程是，先画出横线作为坐标轴，然后从左到右画出一个个小竖线，最后增加数字，箭头等小部件</p><h3 id="12-1-坐标系抽象类-CoordinateSystem"><a href="#12-1-坐标系抽象类-CoordinateSystem" class="headerlink" title="12.1 坐标系抽象类 CoordinateSystem"></a>12.1 坐标系抽象类 CoordinateSystem</h3><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "dimension": 2,        "x_min": -FRAME_X_RADIUS,        "x_max": FRAME_X_RADIUS,        "y_min": -FRAME_Y_RADIUS,        "y_max": FRAME_Y_RADIUS,    }</code></pre><p>主要的几个抽象方法：</p><p><strong>coords指的是坐标轴中的点的值,point指没有坐标轴时真实的坐标，在创建坐标轴时候中心设置在ORIGIN，坐标大小没有缩放的时候两者是一样的</strong></p><ul><li><p>coords_to_point(*coords)；c2p(*coords):将坐标系中的点的坐标值转换为屏幕上的点</p></li><li><p>point_to_coords(point)；p2c(point)：coords_to_point逆方法</p></li><li><p>get_axes():得到CoordinateSystem对象，一般为包含x,y,z坐标的数组</p></li><li><p>get_axis(index):得到index对应的坐标，xyz坐标对应的index分别为1，2，3</p></li><li><p>get_x_axis();get_y_axis();get_z_axis()</p></li><li><p>get_axis_label一类：给对应的坐标（轴）添加标签，显示标签，并返回标签对象</p><ul><li>get_axis_label(label_tex, axis, edge, direction, buff=MED_SMALL_BUFF):</li><li><p>get_axis_labels(x_label_tex=”x”, y_label_tex=”y”)：</p></li><li><p>get_x_axis_label(label_tex, edge=RIGHT, direction=DL, **kwargs)：</p></li><li><p>get_y_axis_label(label_tex, edge=UP, direction=DR, **kwargs):</p></li></ul><p>label_tex:坐标标签，使用latex字符串(TexMobject)</p><p>axis:想获取的坐标标签的对应的坐标对象</p><p>edge:四个边缘位置</p><p>direction：在坐标轴的相对位置</p><p>**kwargs:其他在config内的配置，如颜色等，自行修改</p></li></ul><p>get_graph(function, **kwargs):给定方程，绘制图像并返回</p><p>get_parametric_curve(function, **kwargs):绘制给定参数曲线方程并返回</p><p>input_to_graph_point(x, graph):暂时没搞清楚啥玩意</p><h3 id="12-2-二维坐标类-Axes"><a href="#12-2-二维坐标类-Axes" class="headerlink" title="12.2 二维坐标类 Axes"></a>12.2 二维坐标类 Axes</h3><p>继承CoordinateSystem</p><p>实质是创造两个NumberLine数轴，然后将其中一个按照中心旋转90度，作为Y轴，然后对X，Y轴进行其他的属性进行调整，所以配置里面有”number_line_config”</p><p><strong>Axes(**kwargs)</strong></p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        # 数轴的配置        "number_line_config": {            "color": LIGHT_GREY,            "include_tip": True,            "exclude_zero_from_default_numbers": True,        },        # 横坐标轴和数轴的默认配置一样不需要修改        "x_axis_config": {},        "y_axis_config": {            # 默认将“y”这个标签放在纵坐标轴的左侧            "label_direction": LEFT,        },        # 原点默认和帧图的中心点一致        "center_point": ORIGIN,    }</code></pre><p>实现了：</p><ol><li><p>coords_to_point(*coords)；c2p(*coords):将坐标系中的点的坐标值转换为屏幕（帧图）上的点</p><p>分析一下源码：</p></li></ol><pre class=" language-lang-python"><code class="language-lang-python">def coords_to_point(self, *coords):        # 将坐标轴中的原点0换算为对应的帧图中的坐标        origin = self.x_axis.number_to_point(0)        # 将帧图坐标转换为向量        result = np.array(origin)        # result = 原点对应的帧图的坐标+coord相对帧图中原点的坐标 = coord在帧图中的实际坐标        for axis, coord in zip(self.get_axes(), coords):            result += (axis.number_to_point(coord) - origin)        return result</code></pre><ol><li>point_to_coords(point)；p2c(point)</li></ol><p>增加了方法：</p><p>get_coordinate_labels(x_vals=None, y_vals=None)：传入x,y标签的latex字符串，得到对应的x,y坐标轴的标签的对象</p><p>add_coordinates(x_vals=None, y_vals=None):和get_coordinate_labels相似，但是将其加入了自己的成员变量并返回了自己</p><h3 id="12-3-三维坐标系类-ThreeDAxes"><a href="#12-3-三维坐标系类-ThreeDAxes" class="headerlink" title="12.3 三维坐标系类 ThreeDAxes"></a>12.3 三维坐标系类 ThreeDAxes</h3><p>继承自Axes</p><p><strong>ThreeDAxes(**kwargs)</strong></p><pre class=" language-lang-python"><code class="language-lang-python">CONFIG = {        "dimension": 3,        "x_min": -5.5,        "x_max": 5.5,        "y_min": -5.5,        "y_max": 5.5,        "z_axis_config": {},        "z_min": -3.5,        "z_max": 3.5,        "z_normal": DOWN,        "num_axis_pieces": 20,        "light_source": 9 * DOWN + 7 * LEFT + 10 * OUT,    }</code></pre><h3 id="12-4-NumberPlane"><a href="#12-4-NumberPlane" class="headerlink" title="12.4 NumberPlane"></a>12.4 NumberPlane</h3><h3 id="12-5-ComplexPlane"><a href="#12-5-ComplexPlane" class="headerlink" title="12.5  ComplexPlane"></a>12.5  ComplexPlane</h3><p>复数坐标系，继承于NumberPlane</p><pre class=" language-lang-python"><code class="language-lang-python"># author:TBclass ComplexPlaneScene(Scene):    def construct(self):        # See manimlib/mobject/number_line.py and coordinate_systems.py        cp = ComplexPlane(                        y_axis_config={"decimal_number_config":{"unit": "i"}},                        number_line_config={"include_numbers":True}                        )        x_axis = cp[-2]        y_axis = cp[-1]        x_axis.set_color(RED)        y_axis.set_color(PURPLE)        x_labels = x_axis[1]        x_labels.set_color(ORANGE)        y_labels = y_axis[1]        y_labels.set_color(YELLOW)        for y in y_labels:            y.rotate(-PI/2)        x_label = TexMobject("x")        x_label.move_to(cp.c2p(6.8,x_label.get_height()))        y_label = TexMobject("y")        y_label.move_to(cp.c2p(-y_label.get_width(),3.8))        self.add(cp,x_label,y_label)        self.wait()</code></pre><h2 id="附录A：常见的常数"><a href="#附录A：常见的常数" class="headerlink" title="附录A：常见的常数"></a>附录A：常见的常数</h2><p><strong><em>\manimlib\constants.py</em></strong></p><h3 id="1-颜色"><a href="#1-颜色" class="headerlink" title="1. 颜色"></a>1. 颜色</h3><p>见constants.py中<strong>COLOR_MAP</strong>中的列表</p><h3 id="2-方向"><a href="#2-方向" class="headerlink" title="2. 方向"></a>2. 方向</h3><pre class=" language-lang-python"><code class="language-lang-python">ORIGIN = np.array((0., 0., 0.))UP = np.array((0., 1., 0.))DOWN = np.array((0., -1., 0.))RIGHT = np.array((1., 0., 0.))LEFT = np.array((-1., 0., 0.))IN = np.array((0., 0., -1.))OUT = np.array((0., 0., 1.))X_AXIS = np.array((1., 0., 0.))Y_AXIS = np.array((0., 1., 0.))Z_AXIS = np.array((0., 0., 1.))# Useful abbreviations for diagonalsUL = UP + LEFTUR = UP + RIGHTDL = DOWN + LEFTDR = DOWN + RIGHTTOP = FRAME_Y_RADIUS * UPBOTTOM = FRAME_Y_RADIUS * DOWNLEFT_SIDE = FRAME_X_RADIUS * LEFTRIGHT_SIDE = FRAME_X_RADIUS * RIGHT</code></pre><h3 id="3-角度"><a href="#3-角度" class="headerlink" title="3. 角度"></a>3. 角度</h3><pre class=" language-lang-python"><code class="language-lang-python">PI = np.piTAU = 2 * PIDEGREES = TAU / 360</code></pre><h3 id="4-距离"><a href="#4-距离" class="headerlink" title="4. 距离"></a>4. 距离</h3><pre class=" language-lang-python"><code class="language-lang-python">SMALL_BUFF = 0.1MED_SMALL_BUFF = 0.25MED_LARGE_BUFF = 0.5LARGE_BUFF = 1DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFFDEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> manim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> manim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/26/hello-world/"/>
      <url>/2020/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>大家好,这个是我的个人博客<br>第一次部署博客可能有点生疏,而且这个博客仅仅是我武汉疫情期间的无聊消遣的时候搭建的<br>如果做的不好大家就谅解一下吧</p><h2 id="以下是博客功能的测试"><a href="#以下是博客功能的测试" class="headerlink" title="以下是博客功能的测试:"></a>以下是博客功能的测试:</h2><ol><li>视频播放: <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;box-shadow: 10px 10px 5px #888888;">     <iframe src="//player.bilibili.com/player.html?aid=3746956&amp;bvid=BV1ys411X7Gt&amp;cid=6008537&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;border-radius: 8px;">      </iframe> </div></li></ol><ol><li><p>嵌入数学公式的书写<br> 欧拉公式:$e^{i\pi}+1=0$非常漂亮</p></li><li><p>数学公式</p><script type="math/tex; mode=display"> \sum_{n=1}^{\infty}\frac{1}{n^2}=\frac{1}{1^2}+\frac{1}{2^2}+\frac{1}{3^2}+...=\frac{\pi^{2}}{6}</script></li><li><p>嵌入代码</p><pre class=" language-lang-python"><code class="language-lang-python"> while(True):         print("hello world!!")</code></pre></li></ol><h2 id="搭建的参考资料"><a href="#搭建的参考资料" class="headerlink" title="搭建的参考资料:"></a>搭建的参考资料:</h2><ol><li>基本的搭建:<br> <a href="https://www.jianshu.com/p/a1a4ebf0e5fc" target="_blank" rel="noopener">https://www.jianshu.com/p/a1a4ebf0e5fc</a><br> <a href="https://www.jianshu.com/p/e995fd69c519" target="_blank" rel="noopener">https://www.jianshu.com/p/e995fd69c519</a></li><li>markdown添加图片遇到坑:<br> <a href="https://www.jianshu.com/p/db02d775aed0" target="_blank" rel="noopener">https://www.jianshu.com/p/db02d775aed0</a><br> <a href="https://blog.csdn.net/xjm850552586/article/details/84101345" target="_blank" rel="noopener">https://blog.csdn.net/xjm850552586/article/details/84101345</a></li><li>每页的front-matter设置:<br> <a href="https://www.dazhuanlan.com/2019/11/30/5de154d0810af/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/11/30/5de154d0810af/</a></li><li>文章字数统计与阅读时长:<br> <a href="https://www.jianshu.com/p/f615e79a50d7" target="_blank" rel="noopener">https://www.jianshu.com/p/f615e79a50d7</a></li><li>分类及标签:<br> <a href="https://www.jianshu.com/p/e17711e44e00" target="_blank" rel="noopener">https://www.jianshu.com/p/e17711e44e00</a></li><li>邮箱链接:<br> <a href="https://blog.csdn.net/qq_42893625/article/details/102671013" target="_blank" rel="noopener">https://blog.csdn.net/qq_42893625/article/details/102671013</a></li><li>自适应BiliBili视频大小:<br> <a href="https://teamssix.com/year/190614-111512.html" target="_blank" rel="noopener">https://teamssix.com/year/190614-111512.html</a></li><li>评论系统—Gitalk:<br><a href="https://www.jianshu.com/p/656e6101bf0f" target="_blank" rel="noopener">https://www.jianshu.com/p/656e6101bf0f</a></li><li>coding与github双部署:<br><a href="https://blog.csdn.net/qq_41890607/article/details/104338125" target="_blank" rel="noopener">https://blog.csdn.net/qq_41890607/article/details/104338125</a></li></ol><h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p>主题开发者: <a href="https://jerryc.me/" target="_blank" rel="noopener">https://jerryc.me/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csapp-chapter02</title>
      <link href="/2020/03/25/chapter02/"/>
      <url>/2020/03/25/chapter02/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><h3 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h3><p><img src="image-20200320224158463.png" alt="image-20200320224158463" style="zoom:50%;"></p><h3 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h3><p>在计算机内存中，通常是以字节（Byte），也就是 8 个位（Bit）为基本存储单元（也有以 16 位为基本存储单元的）。对于跨越多个字节的数据类型（比如 int 长 4 个字节），如何在内存中对这些字节进行排序有两种常见的方法：大端法（Big-endian）和小端法（Little-endian）。</p><p><strong>【注】不管是大端法还是小端法存储，计算机在内存中存放数据的顺序都是从低地址到高地址，所不同的是首先取低字节的数据存放在低地址还是取高字节数据存放在低地址。</strong></p><ul><li>若首先取高字节的数据存放在低地址，则是大端法</li><li>若首先取低字节的数据存放在低地址，则是小端法</li></ul><p><img src="image-20200321000815181.png" alt="image-20200321000815181" style="zoom:50%;"></p><p>大多数Intel兼容机是小端法</p><h3 id="2-1-9-C语言中的移位运算"><a href="#2-1-9-C语言中的移位运算" class="headerlink" title="2.1.9 C语言中的移位运算"></a>2.1.9 C语言中的移位运算</h3><p><img src="image-20200321181504713.png" alt="image-20200321181504713" style="zoom:50%;"></p><p><strong>遇到一行多个移位运算的时候要记得打括号</strong></p><h2 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h2><h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><p>为了表示负数,最常见的计算机表示方式就是补码,将最高位表示为负权:</p><p><img src="image-20200322211917167.png" alt="image-20200322211917167"></p><p>最高位表示的权重为$-2^{w-1}$.</p><p>补码和计算机表示的二进制码的转换是一一对应的(双射)</p><blockquote><p>为什么不用原码和反码表示负数:</p><ul><li>原码:最高位表示符号,剩下位表示数字</li><li>反码:和补码类似,不过最高位表示的权重为$-(2^{w-1}-1)$</li></ul><p>这两个编码有一个不好的性质,对数字0有两个不同的编码:</p><ul><li>原码中[00..0]表示+0,[10..0]表示-0</li><li>反码中[00..0]表示+0,[11..1]表示-0</li></ul><p>即表示的编码不是一一对应的双射关系</p></blockquote><h3 id="2-2-4-C语言中有符号数和无符号数之间的转换"><a href="#2-2-4-C语言中有符号数和无符号数之间的转换" class="headerlink" title="2.2.4 C语言中有符号数和无符号数之间的转换"></a>2.2.4 C语言中有符号数和无符号数之间的转换</h3><p>强制转换对于有一点编程经验的人来说,看似习以为常,但是在设计强制转换的时候可以选择很多规则,C语言转换规则是:从位级来看,而不是从数值来看.即对应的二进制不变.</p><h3 id="2-2-6-扩展一个数字的位表示"><a href="#2-2-6-扩展一个数字的位表示" class="headerlink" title="2.2.6 扩展一个数字的位表示"></a>2.2.6 扩展一个数字的位表示</h3><p>较大的数据类型转换位较小的可能会出错,但是从较小的数字转换为较大的应该是可以实现的.</p><ul><li><p>将一个无符号数转换为更大的数据类型,只需在开头加0即可,称为<strong>零扩展</strong>:</p><p><img src="image-20200322153501910.png" alt="image-20200322153501910"></p></li><li><p>将一个补码数字转换为更大的数据类型,可以在在前面填充最高有效位的值,称为符号扩展:</p><p><img src="image-20200322153834509.png" alt="image-20200322153834509"></p><p>其中$x_{w-1}$为符号位</p></li></ul><h2 id="2-3-整数运算"><a href="#2-3-整数运算" class="headerlink" title="2.3 整数运算"></a>2.3 整数运算</h2><h3 id="2-3-1-无符号加法"><a href="#2-3-1-无符号加法" class="headerlink" title="2.3.1 无符号加法"></a>2.3.1 无符号加法</h3><p>考虑两个非负数x,y,满足$0 \le x,y\le 2^w-1$,每个数都能表示为w位无符号数,则有$0 \le x+y\le 2^{w+1}-2$,表示这个和可能需要w+1位表示.</p><p>一般常见的编程语言仅仅支持固定精度的计算,因此会产生溢出:</p><p><img src="image-20200322175257127.png" alt="image-20200322175257127"></p><p>上述的也可以称为模数加法,形成了一个数学结构,阿贝尔群,满足如下性质:</p><ul><li>可交换</li><li>仅有一个单位元(这里单位元是0)</li><li>每个元素有一个加法逆元</li></ul><p>所以对于无符号数$x$都有唯一一个逆元$-_w^u x$:</p><p><img src="image-20200322181059389.png" alt="image-20200322181059389"></p><h3 id="2-3-2-补码加法"><a href="#2-3-2-补码加法" class="headerlink" title="2.3.2 补码加法"></a>2.3.2 补码加法</h3><p>补码加法和无符号加法,对于计算机来说处理是一样的,即截断,然后计算机会将截断后的数字当做补码进行解读.</p><p><img src="image-20200322195842080.png" alt="image-20200322195842080"></p><h3 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h3><p>范围在$TMin_w \le x\le TMax_w$中的每个数字x都有$+^t_w$下的加法逆元$-^t_w$,称为补码的非:</p><p><img src="image-20200322211418982.png" alt="image-20200322211418982"></p><h3 id="2-3-4-无符号乘法"><a href="#2-3-4-无符号乘法" class="headerlink" title="2.3.4 无符号乘法"></a>2.3.4 无符号乘法</h3><p>范围在$0\le x,y\le2^w-1$内的整数x,y可以被表示为w位的无符号数,对应的乘积$x \cdot y$的取值范围为$[0,2^{2w}-2^{w+1}+1]$需要2w位表示,但是C语言是用w位表示的,所以有截断:</p><p><img src="image-20200322214057227.png" alt="image-20200322214057227"></p><h3 id="2-3-5-补码乘法"><a href="#2-3-5-补码乘法" class="headerlink" title="2.3.5 补码乘法"></a>2.3.5 补码乘法</h3><p>范围在$-2^{w-1}\le x,y\le 2^{w-1}-1$内的整数x,y可以被表示位w位的补码,但是成乘积范围在$-2^{w-1}\cdot (2^{w-1}-1)=-2^{2w-2}+2^{w-1}$到$-2^{w-1}\cdot -2^{w-1}=2^{2w-2}$之间,这个范围需要2w位表示,C语言将其截断为w位,将其记为$x*_w^t y$.</p><p>上述机器计算的结果,可以用算法表示为:先将乘积得到的值模$2^w$,得到的无符号数转换为补码:</p><p><img src="image-20200322223742838.png" alt="image-20200322223742838"></p><p>根据书上的证明有如下结论:相同位表示的无符号数乘法和补码乘法得到的二进制数结果是一样的:</p><p><img src="image-20200322230146529.png" alt="image-20200322230146529"></p><h3 id="2-3-6-乘以常数"><a href="#2-3-6-乘以常数" class="headerlink" title="2.3.6 乘以常数"></a>2.3.6 乘以常数</h3><p>大多数机器上整数乘法指令相当慢,大多需要10+个时钟周期,编译器因此进行了一定的优化:试着用位移和加法运算的组合来代替乘以常数因子的乘法.</p><p>下面首先说说乘以2的幂的情况:</p><p><img src="image-20200322231300422.png" alt="image-20200322231300422"></p><p>因此,左移一个数值等价于一个与2的幂相乘的无符号乘法:</p><p><img src="image-20200322231444005.png" alt="image-20200322231444005"></p><p>无论是无符号还是补码运算,乘以2的幂都会导致溢出,但是即使溢出,通过移位的结果都是一样的</p><p>为了减少代价,许多C语言编译器试图以位移,加法减法消除很多整数乘以常数的情况,例如x*14可以重写为:(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1),更好地有:(x&lt;&lt;4)-(x&lt;&lt;1)</p><p><strong>选择上述的方法还是使用乘法指令,取决于指令的相对速度,而这个与机器高度相关,一般只在仅需要少量位移,加法减法就足够的时候使用这种优化</strong></p><h3 id="2-3-7-除以2的幂"><a href="#2-3-7-除以2的幂" class="headerlink" title="2.3.7 除以2的幂"></a>2.3.7 除以2的幂</h3><p>一般地,整数除法比整数乘法更慢—需要30+个周期,但是除以2的运算可以通过右移计算.无符号和补码数分别通过逻辑右移和算数右移实现.</p><ol><li><p>无符号右移非常简单,因为一定是逻辑右移:</p><p><img src="image-20200322234628390.png" alt="image-20200322234628390"></p></li><li><p>除以2的幂的补码运算,情况稍有复杂,首先为了保证为负,需要算术右移:</p><p><img src="image-20200322235518595.png" alt="image-20200322235518595"></p><p><img src="image-20200323000249985.png" alt="image-20200323000249985"></p><p><strong>注意:上图中向上舍入原理,经过与英文版比较,最后应为”产生数值$\lceil  x/2^k\rceil$”</strong>,定义偏量为$(1&lt;&lt;k)-1$,下面有几个例子:</p><p><img src="image-20200323003738528.png" alt="image-20200323003738528"></p><p>根据下图的几个数据与相关的证明可以知道:</p><ul><li>对于不需要舍入的情况,加上偏量只会影响最后被移掉的位</li><li>对于需要舍入的情况,加上偏量会导致较高的位加1,这个会导致向0舍入</li></ul><blockquote><p>偏置技术用的数学知识:$\lceil x/y\rceil=\lfloor (x+y-1)/y\rfloor$(x,y为整数)</p><p>所以上面的式子:(x+(1&lt;<k)-1)>&gt;k,中,y为$2^k$,$(x+2^k-1)/2^k$就表示$\lceil  x/2^k\rceil$</k)-1)></p></blockquote></li></ol><p>综合1,2两个情况,得到C的算术右移的补码机器,计算$x/2^k$:</p><pre class=" language-lang-c++"><code class="language-lang-c++">(x<0 ? x+(1<<k)-1 : x)>>k</code></pre><p>可惜的是,不能将除以2的幂推广到一般除法.</p><h2 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h2><p>与十进制类似,形如$b<em>mb</em>{m-1}…b<em>1b_0.b</em>{-1}b<em>{-2}…b</em>{-n-1}b_{-n}$的二进制数,其对应的十进制的值为:</p><script type="math/tex; mode=display">b=\sum_{i=-n}^{m}2^i\times b_i</script><p>有限长度的编码不能表示如$\frac{1}{3},\frac{5}{7}$的数字,小数的二进制表示法仅能表示能被写成$x\times2^y$的数.</p><h3 id="2-4-2-IEEE浮点表示"><a href="#2-4-2-IEEE浮点表示" class="headerlink" title="2.4.2 IEEE浮点表示"></a>2.4.2 IEEE浮点表示</h3><p><img src="image-20200323182025508.png" alt="image-20200323182025508"></p><p>下图是常见的单双精度的浮点数的格式:</p><p><img src="image-20200323183711302.png" alt="image-20200323183711302"></p><p>上图说明了:</p><div class="table-container"><table><thead><tr><th>精度</th><th>s位数</th><th>exp位数</th><th>frac位数</th></tr></thead><tbody><tr><td>单</td><td>1</td><td>8</td><td>23</td></tr><tr><td>双</td><td>1</td><td>11</td><td>52</td></tr></tbody></table></div><p>给定位表示,根据exp的值,被编码的值可以分成三种不同的情况(最后一种有两个不同的变种),下图为单精度的数字表示:</p><p><img src="image-20200323192300543.png" alt="image-20200323192300543"></p><p>由上图有以下几个解码:</p><ol><li><p>规格化的数值</p><p>此时,阶码的值E=e-Bias,e是exp字段对应的无符号数,Bias为$2^{k-1}-1$,其中k为exp的位数,因此产生的指数E的范围对于单精度为-126~+127,对于双精度为-1022~+1023</p><p>frac是小数值$f$,$0\le f &lt; 1$,二进制表示为$0.f_{n-1}…f_1f_0$,为数M定义为$M=1+f$,因为对于二进制来说,按照十进制的科学计数法的规则,二进制科学计数法第一位一定为1,为了节省比特位,直接将其隐藏,这种方法也叫隐含的以1开头的表示.</p></li><li><p>非规格化的值</p><p>当阶码域exp全部是0的时候,所表示的数字是非规格化的形式,此时阶码$E=1-Bias$,尾数的值是$M=f$,也就是小数字段的值,不包含隐含的1</p><blockquote><p>为什么要对于非规格化的值设置这样的偏置值:</p><p>这样可以让从非规格化到规格化的转换平滑</p></blockquote><p>非规格化的用途:</p><ul><li><p>提供一种表示0的方法,如果使用规格化数,必须$M\ge 1$,所以不能表示0,$+0.0$的浮点表示位模式为所有位为0,此时$M=f=0$,当符号位为1,其他所有位为0的的时候,表示$-0.0$.</p><p>IEEE的浮点格式表示,$+0.0$和$-0.0$在某些方面是不同的</p></li><li><p>表示那些非常接近0.0的数,非规格化提供一种属性:逐渐溢出(gradual underflow),表示一个数与0的距离非常小</p></li></ul></li><li><p>特殊值</p><ul><li>3a: 当阶码域exp全是1,小数域全是0,得到的值表示无穷,s决定是正无穷还是负无穷,当把两个非常大的数字相乘或者进行了除以0的操作后,无穷能表示溢出</li><li>3b: 当小数域非0的时候,结果值为NaN(Not a Number),这用于表示不是实数或者无穷:$\sqrt{-1}或\infty - \infty $等</li></ul></li></ol><h3 id="2-4-3-数字示例"><a href="#2-4-3-数字示例" class="headerlink" title="2.4.3 数字示例"></a>2.4.3 数字示例</h3><p><img src="image-20200323232701819.png" alt="image-20200323232701819"></p><p><img src="image-20200323232716933.png" alt="image-20200323232716933"></p><h3 id="2-4-4-舍入"><a href="#2-4-4-舍入" class="headerlink" title="2.4.4 舍入"></a>2.4.4 舍入</h3><p>默认的方式为:向偶数舍入,也被称为向最近的值舍入(round-to-nearest),又叫向偶数舍入(round-to-even).方法为”四舍六入五成双”,使得到的最低有效位为偶数</p><p>其他的几种有:向零舍入,向下舍入,向上舍入</p><p>向偶舍入的原因:为了将50%的几率向上舍入和50%几率向下舍入</p><p>向偶舍入也可以应用到二进制:将最低有效位的值为0认为是偶数,1为奇数</p><h3 id="2-4-5-浮点运算"><a href="#2-4-5-浮点运算" class="headerlink" title="2.4.5 浮点运算"></a>2.4.5 浮点运算</h3><p>IEEE标准制定了简单的规则确定加法乘法这样的算术运算结果:</p><p>由于精度的限制,对于两个浮点数x,y,某个运算$x\bigodot y$产生的值,计算机会再进行舍入:$Round(x\bigodot y)$</p><p>当其中有一个为特殊值的时候(如-0,无穷,NaN),IEEE定义了一些更合理的规则:1/-0产生$-\infty$,1/+0产生$+\infty$.</p><p>整数加法形成了阿贝尔群,IEEE标准实数加法也构成了阿贝尔群,但是证明过程需要加上Round()函数的证明:</p><p>将$x+^fy$定义为$Round(x+y)$,如果不考虑溢出则直接可以得到就是阿贝尔群,但是如果考虑溢出:</p><ol><li><p>交换律</p><p>交换律:交换x,y是都会同样的方式溢出,所以$+^f$是可交换的;</p></li><li><p>不可结合:例如,使用单精度浮点(3.14+1e10)-1e10=0.0因为3.14作为尾数被舍入,减去1e10变为0,而3.14+(1e10-1e10)=3.14）</p></li><li><p>逆元</p><p>对于x,不考虑溢出明显有逆元-x,如果考虑溢出:$x+^f(-x)$一般都为0,但是有例外$+\infty+^f(-\infty)=NaN$,$NaN+^fx=NaN$</p><p>可见这个逆元不能普适,所以也不存在单位元,所以$+^{f}$不是阿贝尔群</p></li><li><p>另外浮点加法的性质还包含单调性</p></li></ol><p>浮点乘法具有:</p><ol><li><p>交换律</p></li><li><p>不可结合</p></li><li><p>对加法不具有分配律</p></li><li><p>单调性:</p><script type="math/tex; mode=display">a \ge b 且 c \ge 0 \to a * ^f c\ge b*^fc\\a \ge b 且 c \le 0 \to a * ^f c\le b*^fc</script></li><li><p>平方大于等于0:</p><p>若$a\ne 0:a*a\ge0$</p></li></ol><p>缺乏结合性和分配性对科学计算程序员和编译器的编写造成麻烦</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 深入理解计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深入理解计算机系统读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
